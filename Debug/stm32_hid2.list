
stm32_hid2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000298  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00007b5c  080002a0  080002a0  000012a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000009c0  08007dfc  08007dfc  00008dfc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  080087bc  080087bc  000097bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  080087c4  080087c4  000097c4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .fini_array   00000004  080087c8  080087c8  000097c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .data         00000090  24000000  080087cc  0000a000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .tyjRamFunc   00000000  00000000  00000000  0000b018  2**0
                  CONTENTS
  8 .bss          00001128  24000090  24000090  0000a090  2**3
                  ALLOC
  9 ._user_heap   00001000  240011b8  240011b8  0000a090  2**0
                  ALLOC
 10 .RAM_D2       00000018  30000000  30000000  0000b000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .RAM_D3       00000000  38000000  38000000  0000b018  2**0
                  CONTENTS
 12 .tyjDTCM      00000000  20000000  20000000  0000b018  2**0
                  CONTENTS
 13 ._user_stack  00001000  20000000  20000000  0000b000  2**0
                  ALLOC
 14 .ARM.attributes 0000002e  00000000  00000000  0000b018  2**0
                  CONTENTS, READONLY
 15 .debug_info   00034814  00000000  00000000  0000b046  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 00007d4a  00000000  00000000  0003f85a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_loclists 00011224  00000000  00000000  000475a4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 00001638  00000000  00000000  000587c8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 0000251c  00000000  00000000  00059e00  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  00045703  00000000  00000000  0005c31c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   00033738  00000000  00000000  000a1a1f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    0018d854  00000000  00000000  000d5157  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000043  00000000  00000000  002629ab  2**0
                  CONTENTS, READONLY
 24 .debug_frame  000041a4  00000000  00000000  002629f0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_line_str 00000062  00000000  00000000  00266b94  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080002a0 <__do_global_dtors_aux>:
 80002a0:	b510      	push	{r4, lr}
 80002a2:	4c05      	ldr	r4, [pc, #20]	@ (80002b8 <__do_global_dtors_aux+0x18>)
 80002a4:	7823      	ldrb	r3, [r4, #0]
 80002a6:	b933      	cbnz	r3, 80002b6 <__do_global_dtors_aux+0x16>
 80002a8:	4b04      	ldr	r3, [pc, #16]	@ (80002bc <__do_global_dtors_aux+0x1c>)
 80002aa:	b113      	cbz	r3, 80002b2 <__do_global_dtors_aux+0x12>
 80002ac:	4804      	ldr	r0, [pc, #16]	@ (80002c0 <__do_global_dtors_aux+0x20>)
 80002ae:	f3af 8000 	nop.w
 80002b2:	2301      	movs	r3, #1
 80002b4:	7023      	strb	r3, [r4, #0]
 80002b6:	bd10      	pop	{r4, pc}
 80002b8:	24000090 	.word	0x24000090
 80002bc:	00000000 	.word	0x00000000
 80002c0:	08007de4 	.word	0x08007de4

080002c4 <frame_dummy>:
 80002c4:	b508      	push	{r3, lr}
 80002c6:	4b03      	ldr	r3, [pc, #12]	@ (80002d4 <frame_dummy+0x10>)
 80002c8:	b11b      	cbz	r3, 80002d2 <frame_dummy+0xe>
 80002ca:	4903      	ldr	r1, [pc, #12]	@ (80002d8 <frame_dummy+0x14>)
 80002cc:	4803      	ldr	r0, [pc, #12]	@ (80002dc <frame_dummy+0x18>)
 80002ce:	f3af 8000 	nop.w
 80002d2:	bd08      	pop	{r3, pc}
 80002d4:	00000000 	.word	0x00000000
 80002d8:	24000094 	.word	0x24000094
 80002dc:	08007de4 	.word	0x08007de4

080002e0 <memchr>:
 80002e0:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 80002e4:	2a10      	cmp	r2, #16
 80002e6:	db2b      	blt.n	8000340 <memchr+0x60>
 80002e8:	f010 0f07 	tst.w	r0, #7
 80002ec:	d008      	beq.n	8000300 <memchr+0x20>
 80002ee:	f810 3b01 	ldrb.w	r3, [r0], #1
 80002f2:	3a01      	subs	r2, #1
 80002f4:	428b      	cmp	r3, r1
 80002f6:	d02d      	beq.n	8000354 <memchr+0x74>
 80002f8:	f010 0f07 	tst.w	r0, #7
 80002fc:	b342      	cbz	r2, 8000350 <memchr+0x70>
 80002fe:	d1f6      	bne.n	80002ee <memchr+0xe>
 8000300:	b4f0      	push	{r4, r5, r6, r7}
 8000302:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000306:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800030a:	f022 0407 	bic.w	r4, r2, #7
 800030e:	f07f 0700 	mvns.w	r7, #0
 8000312:	2300      	movs	r3, #0
 8000314:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000318:	3c08      	subs	r4, #8
 800031a:	ea85 0501 	eor.w	r5, r5, r1
 800031e:	ea86 0601 	eor.w	r6, r6, r1
 8000322:	fa85 f547 	uadd8	r5, r5, r7
 8000326:	faa3 f587 	sel	r5, r3, r7
 800032a:	fa86 f647 	uadd8	r6, r6, r7
 800032e:	faa5 f687 	sel	r6, r5, r7
 8000332:	b98e      	cbnz	r6, 8000358 <memchr+0x78>
 8000334:	d1ee      	bne.n	8000314 <memchr+0x34>
 8000336:	bcf0      	pop	{r4, r5, r6, r7}
 8000338:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 800033c:	f002 0207 	and.w	r2, r2, #7
 8000340:	b132      	cbz	r2, 8000350 <memchr+0x70>
 8000342:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000346:	3a01      	subs	r2, #1
 8000348:	ea83 0301 	eor.w	r3, r3, r1
 800034c:	b113      	cbz	r3, 8000354 <memchr+0x74>
 800034e:	d1f8      	bne.n	8000342 <memchr+0x62>
 8000350:	2000      	movs	r0, #0
 8000352:	4770      	bx	lr
 8000354:	3801      	subs	r0, #1
 8000356:	4770      	bx	lr
 8000358:	2d00      	cmp	r5, #0
 800035a:	bf06      	itte	eq
 800035c:	4635      	moveq	r5, r6
 800035e:	3803      	subeq	r0, #3
 8000360:	3807      	subne	r0, #7
 8000362:	f015 0f01 	tst.w	r5, #1
 8000366:	d107      	bne.n	8000378 <memchr+0x98>
 8000368:	3001      	adds	r0, #1
 800036a:	f415 7f80 	tst.w	r5, #256	@ 0x100
 800036e:	bf02      	ittt	eq
 8000370:	3001      	addeq	r0, #1
 8000372:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 8000376:	3001      	addeq	r0, #1
 8000378:	bcf0      	pop	{r4, r5, r6, r7}
 800037a:	3801      	subs	r0, #1
 800037c:	4770      	bx	lr
 800037e:	bf00      	nop

08000380 <bsp_init_scd>:
// RAM_D2 是没有cache加速的，所以才能与DMA配合使用
uint8_t scd_rev_2buffer[2][USART_REV_BUFF_SIZE] __attribute__((section(".RAM_D2")));
uint8_t scd_send_2buffer[2][USART_SEND_BUFF_SIZE] __attribute__((section(".RAM_D2")));

void bsp_init_scd()
{
 8000380:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000382:	4c33      	ldr	r4, [pc, #204]	@ (8000450 <bsp_init_scd+0xd0>)
    // uart debug output
    scd_init_1();
 8000384:	f001 fa04 	bl	8001790 <scd_init_1>
    // fill the send buffer
    for (int j = 0; j < 2; j++)
    {
        for (int i = 0; i < USART_SEND_BUFF_SIZE; i++)
        {
            scd_send_2buffer[j][i] = scd_send1Byte(&scd_1);
 8000388:	4e32      	ldr	r6, [pc, #200]	@ (8000454 <bsp_init_scd+0xd4>)
 800038a:	1c67      	adds	r7, r4, #1
 800038c:	f104 0508 	add.w	r5, r4, #8
 8000390:	4630      	mov	r0, r6
 8000392:	f001 f9db 	bl	800174c <scd_send1Byte>
 8000396:	f804 0f01 	strb.w	r0, [r4, #1]!
        for (int i = 0; i < USART_SEND_BUFF_SIZE; i++)
 800039a:	42ac      	cmp	r4, r5
 800039c:	d1f8      	bne.n	8000390 <bsp_init_scd+0x10>
 800039e:	4c2e      	ldr	r4, [pc, #184]	@ (8000458 <bsp_init_scd+0xd8>)
 80003a0:	f107 060f 	add.w	r6, r7, #15
            scd_send_2buffer[j][i] = scd_send1Byte(&scd_1);
 80003a4:	4d2b      	ldr	r5, [pc, #172]	@ (8000454 <bsp_init_scd+0xd4>)
 80003a6:	4628      	mov	r0, r5
 80003a8:	f001 f9d0 	bl	800174c <scd_send1Byte>
 80003ac:	f804 0f01 	strb.w	r0, [r4, #1]!
        for (int i = 0; i < USART_SEND_BUFF_SIZE; i++)
 80003b0:	42b4      	cmp	r4, r6
 80003b2:	d1f8      	bne.n	80003a6 <bsp_init_scd+0x26>
  */
__STATIC_INLINE void LL_DMA_EnableDoubleBufferMode(DMA_TypeDef *DMAx, uint32_t Stream)
{
  uint32_t dma_base_addr = (uint32_t)DMAx;

  SET_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_DBM);
 80003b4:	4b29      	ldr	r3, [pc, #164]	@ (800045c <bsp_init_scd+0xdc>)
    }

    // rev 2 buff dma config
    LL_DMA_EnableDoubleBufferMode(DMA1, LL_DMA_STREAM_0);
    LL_DMA_SetPeriphAddress(DMA1, LL_DMA_STREAM_0, LL_USART_DMA_GetRegAddr(USART1, LL_USART_DMA_REG_DATA_RECEIVE));
    LL_DMA_SetMemoryAddress(DMA1, LL_DMA_STREAM_0, (uint32_t)scd_rev_2buffer[0]);
 80003b6:	492a      	ldr	r1, [pc, #168]	@ (8000460 <bsp_init_scd+0xe0>)
 80003b8:	691a      	ldr	r2, [r3, #16]
  */
__STATIC_INLINE void LL_DMA_SetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Stream, uint32_t PeriphAddress)
{
  uint32_t dma_base_addr = (uint32_t)DMAx;

  WRITE_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->PAR, PeriphAddress);
 80003ba:	4c2a      	ldr	r4, [pc, #168]	@ (8000464 <bsp_init_scd+0xe4>)
  SET_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_DBM);
 80003bc:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->NDTR, DMA_SxNDT, NbData);
 80003c0:	4829      	ldr	r0, [pc, #164]	@ (8000468 <bsp_init_scd+0xe8>)
  SET_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_DBM);
 80003c2:	611a      	str	r2, [r3, #16]
    LL_DMA_SetMemory1Address(DMA1, LL_DMA_STREAM_0, (uint32_t)scd_rev_2buffer[1]);
 80003c4:	1d0a      	adds	r2, r1, #4
  WRITE_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->PAR, PeriphAddress);
 80003c6:	619c      	str	r4, [r3, #24]
  WRITE_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->M0AR, MemoryAddress);
 80003c8:	61d9      	str	r1, [r3, #28]
  */
__STATIC_INLINE void LL_DMA_SetMemory1Address(DMA_TypeDef *DMAx, uint32_t Stream, uint32_t Address)
{
  uint32_t dma_base_addr = (uint32_t)DMAx;

  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->M1AR, DMA_SxM1AR_M1A, Address);
 80003ca:	6a19      	ldr	r1, [r3, #32]
 80003cc:	621a      	str	r2, [r3, #32]
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->NDTR, DMA_SxNDT, NbData);
 80003ce:	695a      	ldr	r2, [r3, #20]
  WRITE_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->PAR, PeriphAddress);
 80003d0:	4926      	ldr	r1, [pc, #152]	@ (800046c <bsp_init_scd+0xec>)
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->NDTR, DMA_SxNDT, NbData);
 80003d2:	4002      	ands	r2, r0
 80003d4:	f042 0204 	orr.w	r2, r2, #4
 80003d8:	615a      	str	r2, [r3, #20]
  */
__STATIC_INLINE void LL_DMA_EnableIT_TC(DMA_TypeDef *DMAx, uint32_t Stream)
{
  uint32_t dma_base_addr = (uint32_t)DMAx;

  SET_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_TCIE);
 80003da:	691a      	ldr	r2, [r3, #16]
 80003dc:	f042 0210 	orr.w	r2, r2, #16
 80003e0:	611a      	str	r2, [r3, #16]
  SET_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_DBM);
 80003e2:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80003e4:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 80003e8:	629a      	str	r2, [r3, #40]	@ 0x28

    // send 2 buff dma config
    LL_DMA_EnableDoubleBufferMode(DMA1, LL_DMA_STREAM_1);
    LL_DMA_SetPeriphAddress(DMA1, LL_DMA_STREAM_1, LL_USART_DMA_GetRegAddr(USART1, LL_USART_DMA_REG_DATA_TRANSMIT));
    LL_DMA_SetMemoryAddress(DMA1, LL_DMA_STREAM_1, (uint32_t)scd_send_2buffer[0]);
    LL_DMA_SetMemory1Address(DMA1, LL_DMA_STREAM_1, (uint32_t)scd_send_2buffer[1]);
 80003ea:	4a21      	ldr	r2, [pc, #132]	@ (8000470 <bsp_init_scd+0xf0>)
  WRITE_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->PAR, PeriphAddress);
 80003ec:	6319      	str	r1, [r3, #48]	@ 0x30
  WRITE_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->M0AR, MemoryAddress);
 80003ee:	635f      	str	r7, [r3, #52]	@ 0x34
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->M1AR, DMA_SxM1AR_M1A, Address);
 80003f0:	6b99      	ldr	r1, [r3, #56]	@ 0x38
 80003f2:	639a      	str	r2, [r3, #56]	@ 0x38
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->NDTR, DMA_SxNDT, NbData);
 80003f4:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80003f6:	4a1f      	ldr	r2, [pc, #124]	@ (8000474 <bsp_init_scd+0xf4>)
 80003f8:	4001      	ands	r1, r0
 80003fa:	f041 0108 	orr.w	r1, r1, #8
 80003fe:	62d9      	str	r1, [r3, #44]	@ 0x2c
  SET_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_TCIE);
 8000400:	6a99      	ldr	r1, [r3, #40]	@ 0x28
 8000402:	f041 0110 	orr.w	r1, r1, #16
 8000406:	6299      	str	r1, [r3, #40]	@ 0x28
 8000408:	f102 0308 	add.w	r3, r2, #8
 800040c:	e853 3f00 	ldrex	r3, [r3]
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_EnableDMAReq_RX(USART_TypeDef *USARTx)
{
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8000410:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8000414:	f102 0008 	add.w	r0, r2, #8
 8000418:	e840 3100 	strex	r1, r3, [r0]
 800041c:	2900      	cmp	r1, #0
 800041e:	d1f3      	bne.n	8000408 <bsp_init_scd+0x88>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8000420:	4a14      	ldr	r2, [pc, #80]	@ (8000474 <bsp_init_scd+0xf4>)
 8000422:	f102 0308 	add.w	r3, r2, #8
 8000426:	e853 3f00 	ldrex	r3, [r3]
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_EnableDMAReq_TX(USART_TypeDef *USARTx)
{
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 800042a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800042e:	f102 0008 	add.w	r0, r2, #8
 8000432:	e840 3100 	strex	r1, r3, [r0]
 8000436:	2900      	cmp	r1, #0
 8000438:	d1f3      	bne.n	8000422 <bsp_init_scd+0xa2>
  SET_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_EN);
 800043a:	4b08      	ldr	r3, [pc, #32]	@ (800045c <bsp_init_scd+0xdc>)
 800043c:	691a      	ldr	r2, [r3, #16]
 800043e:	f042 0201 	orr.w	r2, r2, #1
 8000442:	611a      	str	r2, [r3, #16]
 8000444:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8000446:	f042 0201 	orr.w	r2, r2, #1
 800044a:	629a      	str	r2, [r3, #40]	@ 0x28

    // enable dma stream
    LL_DMA_EnableStream(DMA1, LL_DMA_STREAM_0);
    LL_DMA_EnableStream(DMA1, LL_DMA_STREAM_1);
    return;
}
 800044c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800044e:	bf00      	nop
 8000450:	2fffffff 	.word	0x2fffffff
 8000454:	24000270 	.word	0x24000270
 8000458:	30000007 	.word	0x30000007
 800045c:	40020000 	.word	0x40020000
 8000460:	30000010 	.word	0x30000010
 8000464:	40011024 	.word	0x40011024
 8000468:	ffff0000 	.word	0xffff0000
 800046c:	40011028 	.word	0x40011028
 8000470:	30000008 	.word	0x30000008
 8000474:	40011000 	.word	0x40011000

08000478 <MX_DMA_Init>:
  * @retval None
*/
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB1ENR, Periphs);
 8000478:	4b25      	ldr	r3, [pc, #148]	@ (8000510 <MX_DMA_Init+0x98>)

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 800047a:	b082      	sub	sp, #8
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800047c:	4925      	ldr	r1, [pc, #148]	@ (8000514 <MX_DMA_Init+0x9c>)
 800047e:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000482:	4825      	ldr	r0, [pc, #148]	@ (8000518 <MX_DMA_Init+0xa0>)
 8000484:	f042 0201 	orr.w	r2, r2, #1
 8000488:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 800048c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8000490:	f003 0301 	and.w	r3, r3, #1
 8000494:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8000496:	9b01      	ldr	r3, [sp, #4]
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000498:	68cb      	ldr	r3, [r1, #12]
 800049a:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800049e:	f1c3 0107 	rsb	r1, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80004a2:	1d1a      	adds	r2, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80004a4:	2904      	cmp	r1, #4
 80004a6:	bf28      	it	cs
 80004a8:	2104      	movcs	r1, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80004aa:	2a06      	cmp	r2, #6
 80004ac:	bf88      	it	hi
 80004ae:	1eda      	subhi	r2, r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80004b0:	f04f 33ff 	mov.w	r3, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80004b4:	bf98      	it	ls
 80004b6:	2200      	movls	r2, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80004b8:	408b      	lsls	r3, r1
 80004ba:	43db      	mvns	r3, r3
 80004bc:	f003 030d 	and.w	r3, r3, #13
 80004c0:	4093      	lsls	r3, r2
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80004c2:	011b      	lsls	r3, r3, #4
 80004c4:	b2db      	uxtb	r3, r3
 80004c6:	f880 330b 	strb.w	r3, [r0, #779]	@ 0x30b
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80004ca:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 80004ce:	6003      	str	r3, [r0, #0]
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80004d0:	4b10      	ldr	r3, [pc, #64]	@ (8000514 <MX_DMA_Init+0x9c>)
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80004d2:	4811      	ldr	r0, [pc, #68]	@ (8000518 <MX_DMA_Init+0xa0>)
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80004d4:	68db      	ldr	r3, [r3, #12]
 80004d6:	f3c3 2302 	ubfx	r3, r3, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80004da:	f1c3 0107 	rsb	r1, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80004de:	1d1a      	adds	r2, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80004e0:	2904      	cmp	r1, #4
 80004e2:	bf28      	it	cs
 80004e4:	2104      	movcs	r1, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80004e6:	2a06      	cmp	r2, #6
 80004e8:	bf88      	it	hi
 80004ea:	1eda      	subhi	r2, r3, #3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80004ec:	f04f 33ff 	mov.w	r3, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80004f0:	bf98      	it	ls
 80004f2:	2200      	movls	r2, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80004f4:	408b      	lsls	r3, r1
 80004f6:	43db      	mvns	r3, r3
 80004f8:	f003 030e 	and.w	r3, r3, #14
 80004fc:	4093      	lsls	r3, r2
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80004fe:	011b      	lsls	r3, r3, #4
 8000500:	b2db      	uxtb	r3, r3
 8000502:	f880 330c 	strb.w	r3, [r0, #780]	@ 0x30c
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8000506:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 800050a:	6003      	str	r3, [r0, #0]
  NVIC_EnableIRQ(DMA1_Stream0_IRQn);
  /* DMA1_Stream1_IRQn interrupt configuration */
  NVIC_SetPriority(DMA1_Stream1_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),14, 0));
  NVIC_EnableIRQ(DMA1_Stream1_IRQn);

}
 800050c:	b002      	add	sp, #8
 800050e:	4770      	bx	lr
 8000510:	58024400 	.word	0x58024400
 8000514:	e000ed00 	.word	0xe000ed00
 8000518:	e000e100 	.word	0xe000e100
 800051c:	00000000 	.word	0x00000000

08000520 <MX_GPIO_Init>:
        * EXTI
        * Free pins are configured automatically as Analog (this feature is enabled through
        * the Code Generation settings)
*/
void MX_GPIO_Init(void)
{
 8000520:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  * @retval None
*/
__STATIC_INLINE void LL_AHB4_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB4ENR, Periphs);
 8000524:	4b70      	ldr	r3, [pc, #448]	@ (80006e8 <MX_GPIO_Init+0x1c8>)
 8000526:	b08d      	sub	sp, #52	@ 0x34

  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000528:	2500      	movs	r5, #0
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BSRR, PinMask);
 800052a:	4f70      	ldr	r7, [pc, #448]	@ (80006ec <MX_GPIO_Init+0x1cc>)
 800052c:	4e70      	ldr	r6, [pc, #448]	@ (80006f0 <MX_GPIO_Init+0x1d0>)
 800052e:	f44f 6bc0 	mov.w	fp, #1536	@ 0x600
 8000532:	4c70      	ldr	r4, [pc, #448]	@ (80006f4 <MX_GPIO_Init+0x1d4>)
 8000534:	f44f 6a80 	mov.w	sl, #1024	@ 0x400
 8000538:	f8df 81c0 	ldr.w	r8, [pc, #448]	@ 80006fc <MX_GPIO_Init+0x1dc>
 800053c:	f04f 0908 	mov.w	r9, #8
  GPIO_InitStruct.Pin = LL_GPIO_PIN_3|LL_GPIO_PIN_4|LL_GPIO_PIN_5|LL_GPIO_PIN_6
                          |LL_GPIO_PIN_7|LL_GPIO_PIN_8|LL_GPIO_PIN_15|LL_GPIO_PIN_0
                          |LL_GPIO_PIN_1;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  LL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8000540:	a906      	add	r1, sp, #24
 8000542:	4638      	mov	r0, r7
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000544:	e9cd 5508 	strd	r5, r5, [sp, #32]
 8000548:	e9cd 550a 	strd	r5, r5, [sp, #40]	@ 0x28
 800054c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8000550:	f042 0210 	orr.w	r2, r2, #16
 8000554:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB4ENR, Periphs);
 8000558:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800055c:	f002 0210 	and.w	r2, r2, #16
 8000560:	9205      	str	r2, [sp, #20]
  (void)tmpreg;
 8000562:	9a05      	ldr	r2, [sp, #20]
  SET_BIT(RCC->AHB4ENR, Periphs);
 8000564:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8000568:	f042 0204 	orr.w	r2, r2, #4
 800056c:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  tmpreg = READ_BIT(RCC->AHB4ENR, Periphs);
 8000570:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8000574:	f002 0204 	and.w	r2, r2, #4
 8000578:	9204      	str	r2, [sp, #16]
  (void)tmpreg;
 800057a:	9a04      	ldr	r2, [sp, #16]
  SET_BIT(RCC->AHB4ENR, Periphs);
 800057c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8000580:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 8000584:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  tmpreg = READ_BIT(RCC->AHB4ENR, Periphs);
 8000588:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800058c:	f002 0280 	and.w	r2, r2, #128	@ 0x80
 8000590:	9203      	str	r2, [sp, #12]
  (void)tmpreg;
 8000592:	9a03      	ldr	r2, [sp, #12]
  SET_BIT(RCC->AHB4ENR, Periphs);
 8000594:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8000598:	f042 0201 	orr.w	r2, r2, #1
 800059c:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  tmpreg = READ_BIT(RCC->AHB4ENR, Periphs);
 80005a0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 80005a4:	f002 0201 	and.w	r2, r2, #1
 80005a8:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 80005aa:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB4ENR, Periphs);
 80005ac:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 80005b0:	f042 0202 	orr.w	r2, r2, #2
 80005b4:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  tmpreg = READ_BIT(RCC->AHB4ENR, Periphs);
 80005b8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 80005bc:	f002 0202 	and.w	r2, r2, #2
 80005c0:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 80005c2:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB4ENR, Periphs);
 80005c4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 80005c8:	f042 0208 	orr.w	r2, r2, #8
 80005cc:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BSRR, PinMask << 16U);
 80005d0:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
  tmpreg = READ_BIT(RCC->AHB4ENR, Periphs);
 80005d4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80005d8:	f003 0308 	and.w	r3, r3, #8
 80005dc:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 80005de:	9b00      	ldr	r3, [sp, #0]
  WRITE_REG(GPIOx->BSRR, PinMask);
 80005e0:	2320      	movs	r3, #32
  GPIO_InitStruct.Pin = LL_GPIO_PIN_3|LL_GPIO_PIN_4|LL_GPIO_PIN_5|LL_GPIO_PIN_6
 80005e2:	ed9f 7b3b 	vldr	d7, [pc, #236]	@ 80006d0 <MX_GPIO_Init+0x1b0>
 80005e6:	61a3      	str	r3, [r4, #24]
 80005e8:	f8c7 b018 	str.w	fp, [r7, #24]
 80005ec:	f8c6 a018 	str.w	sl, [r6, #24]
 80005f0:	f8c8 9018 	str.w	r9, [r8, #24]
  WRITE_REG(GPIOx->BSRR, PinMask << 16U);
 80005f4:	61b2      	str	r2, [r6, #24]
 80005f6:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
 80005fa:	61ba      	str	r2, [r7, #24]
 80005fc:	ed8d 7b06 	vstr	d7, [sp, #24]
  LL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8000600:	f003 fbc2 	bl	8003d88 <LL_GPIO_Init>
  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_13|LL_GPIO_PIN_0|LL_GPIO_PIN_2|LL_GPIO_PIN_3
                          |LL_GPIO_PIN_6|LL_GPIO_PIN_7;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000604:	a906      	add	r1, sp, #24
 8000606:	483c      	ldr	r0, [pc, #240]	@ (80006f8 <MX_GPIO_Init+0x1d8>)
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000608:	950a      	str	r5, [sp, #40]	@ 0x28
  GPIO_InitStruct.Pin = LL_GPIO_PIN_13|LL_GPIO_PIN_0|LL_GPIO_PIN_2|LL_GPIO_PIN_3
 800060a:	ed9f 7b33 	vldr	d7, [pc, #204]	@ 80006d8 <MX_GPIO_Init+0x1b8>
 800060e:	ed8d 7b06 	vstr	d7, [sp, #24]
  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000612:	f003 fbb9 	bl	8003d88 <LL_GPIO_Init>
  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_0|LL_GPIO_PIN_3|LL_GPIO_PIN_4|LL_GPIO_PIN_6
                          |LL_GPIO_PIN_8|LL_GPIO_PIN_15;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000616:	a906      	add	r1, sp, #24
 8000618:	4620      	mov	r0, r4
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 800061a:	950a      	str	r5, [sp, #40]	@ 0x28
  GPIO_InitStruct.Pin = LL_GPIO_PIN_0|LL_GPIO_PIN_3|LL_GPIO_PIN_4|LL_GPIO_PIN_6
 800061c:	ed9f 7b30 	vldr	d7, [pc, #192]	@ 80006e0 <MX_GPIO_Init+0x1c0>
 8000620:	ed8d 7b06 	vstr	d7, [sp, #24]
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000624:	f003 fbb0 	bl	8003d88 <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = ETH_RST_Pin;
 8000628:	2320      	movs	r3, #32
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
  LL_GPIO_Init(ETH_RST_GPIO_Port, &GPIO_InitStruct);
 800062a:	4620      	mov	r0, r4
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 800062c:	2401      	movs	r4, #1
  LL_GPIO_Init(ETH_RST_GPIO_Port, &GPIO_InitStruct);
 800062e:	a906      	add	r1, sp, #24
  GPIO_InitStruct.Pin = ETH_RST_Pin;
 8000630:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8000632:	9509      	str	r5, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8000634:	940a      	str	r4, [sp, #40]	@ 0x28
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
 8000636:	e9cd 4407 	strd	r4, r4, [sp, #28]
  LL_GPIO_Init(ETH_RST_GPIO_Port, &GPIO_InitStruct);
 800063a:	f003 fba5 	bl	8003d88 <LL_GPIO_Init>
  GPIO_InitStruct.Pin = LED_0_Pin;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  LL_GPIO_Init(LED_0_GPIO_Port, &GPIO_InitStruct);
 800063e:	a906      	add	r1, sp, #24
 8000640:	4630      	mov	r0, r6
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000642:	950a      	str	r5, [sp, #40]	@ 0x28
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8000644:	e9cd 4406 	strd	r4, r4, [sp, #24]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8000648:	e9cd 4508 	strd	r4, r5, [sp, #32]
  LL_GPIO_Init(LED_0_GPIO_Port, &GPIO_InitStruct);
 800064c:	f003 fb9c 	bl	8003d88 <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_1|LL_GPIO_PIN_7;
 8000650:	2282      	movs	r2, #130	@ 0x82
 8000652:	2303      	movs	r3, #3
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000654:	a906      	add	r1, sp, #24
 8000656:	4630      	mov	r0, r6
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000658:	950a      	str	r5, [sp, #40]	@ 0x28
  GPIO_InitStruct.Pin = LL_GPIO_PIN_1|LL_GPIO_PIN_7;
 800065a:	e9cd 2306 	strd	r2, r3, [sp, #24]
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800065e:	f003 fb93 	bl	8003d88 <LL_GPIO_Init>
  GPIO_InitStruct.Pin = OLED_RST_Pin|OLED_DC_Pin;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
  LL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8000662:	a906      	add	r1, sp, #24
 8000664:	4638      	mov	r0, r7
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8000666:	940a      	str	r4, [sp, #40]	@ 0x28
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8000668:	e9cd b406 	strd	fp, r4, [sp, #24]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 800066c:	e9cd 4508 	strd	r4, r5, [sp, #32]
  LL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8000670:	f003 fb8a 	bl	8003d88 <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = LED_1_Pin;
 8000674:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  LL_GPIO_Init(LED_1_GPIO_Port, &GPIO_InitStruct);
 8000678:	a906      	add	r1, sp, #24
 800067a:	4638      	mov	r0, r7
  GPIO_InitStruct.Pin = LED_1_Pin;
 800067c:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
 800067e:	e9cd 4407 	strd	r4, r4, [sp, #28]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000682:	e9cd 5509 	strd	r5, r5, [sp, #36]	@ 0x24
  LL_GPIO_Init(LED_1_GPIO_Port, &GPIO_InitStruct);
 8000686:	f003 fb7f 	bl	8003d88 <LL_GPIO_Init>
  GPIO_InitStruct.Pin = EEPROM_SCL_Pin;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
  LL_GPIO_Init(EEPROM_SCL_GPIO_Port, &GPIO_InitStruct);
 800068a:	a906      	add	r1, sp, #24
 800068c:	4630      	mov	r0, r6
  GPIO_InitStruct.Pin = EEPROM_SCL_Pin;
 800068e:	f8cd a018 	str.w	sl, [sp, #24]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
 8000692:	e9cd 4407 	strd	r4, r4, [sp, #28]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8000696:	e9cd 5409 	strd	r5, r4, [sp, #36]	@ 0x24
  LL_GPIO_Init(EEPROM_SCL_GPIO_Port, &GPIO_InitStruct);
 800069a:	f003 fb75 	bl	8003d88 <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_8|LL_GPIO_PIN_9|LL_GPIO_PIN_10|LL_GPIO_PIN_14
 800069e:	f24c 7293 	movw	r2, #51091	@ 0xc793
 80006a2:	2303      	movs	r3, #3
                          |LL_GPIO_PIN_15|LL_GPIO_PIN_0|LL_GPIO_PIN_1|LL_GPIO_PIN_4
                          |LL_GPIO_PIN_7;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  LL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80006a4:	a906      	add	r1, sp, #24
 80006a6:	4640      	mov	r0, r8
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 80006a8:	950a      	str	r5, [sp, #40]	@ 0x28
  GPIO_InitStruct.Pin = LL_GPIO_PIN_8|LL_GPIO_PIN_9|LL_GPIO_PIN_10|LL_GPIO_PIN_14
 80006aa:	e9cd 2306 	strd	r2, r3, [sp, #24]
  LL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80006ae:	f003 fb6b 	bl	8003d88 <LL_GPIO_Init>
  GPIO_InitStruct.Pin = FLASH_CS_Pin;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
  LL_GPIO_Init(FLASH_CS_GPIO_Port, &GPIO_InitStruct);
 80006b2:	a906      	add	r1, sp, #24
 80006b4:	4640      	mov	r0, r8
  GPIO_InitStruct.Pin = FLASH_CS_Pin;
 80006b6:	f8cd 9018 	str.w	r9, [sp, #24]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
 80006ba:	e9cd 4407 	strd	r4, r4, [sp, #28]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 80006be:	e9cd 5409 	strd	r5, r4, [sp, #36]	@ 0x24
  LL_GPIO_Init(FLASH_CS_GPIO_Port, &GPIO_InitStruct);
 80006c2:	f003 fb61 	bl	8003d88 <LL_GPIO_Init>

}
 80006c6:	b00d      	add	sp, #52	@ 0x34
 80006c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80006cc:	f3af 8000 	nop.w
 80006d0:	000081fb 	.word	0x000081fb
 80006d4:	00000003 	.word	0x00000003
 80006d8:	000020cd 	.word	0x000020cd
 80006dc:	00000003 	.word	0x00000003
 80006e0:	00008159 	.word	0x00008159
 80006e4:	00000003 	.word	0x00000003
 80006e8:	58024400 	.word	0x58024400
 80006ec:	58021000 	.word	0x58021000
 80006f0:	58020400 	.word	0x58020400
 80006f4:	58020000 	.word	0x58020000
 80006f8:	58020800 	.word	0x58020800
 80006fc:	58020c00 	.word	0x58020c00

08000700 <SystemClock_Config>:
  *         @arg @ref LL_FLASH_LATENCY_7
  * @retval None
  */
__STATIC_INLINE void LL_FLASH_SetLatency(uint32_t Latency)
{
  MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 8000700:	4a5f      	ldr	r2, [pc, #380]	@ (8000880 <SystemClock_Config+0x180>)
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8000702:	b508      	push	{r3, lr}
 8000704:	6813      	ldr	r3, [r2, #0]
 8000706:	f023 030f 	bic.w	r3, r3, #15
 800070a:	f043 0302 	orr.w	r3, r3, #2
 800070e:	6013      	str	r3, [r2, #0]
  *         @arg @ref LL_FLASH_LATENCY_6
  *         @arg @ref LL_FLASH_LATENCY_7
  */
__STATIC_INLINE uint32_t LL_FLASH_GetLatency(void)
{
  return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
 8000710:	6813      	ldr	r3, [r2, #0]
 8000712:	f003 030f 	and.w	r3, r3, #15
  LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);
  while (LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2)
 8000716:	2b02      	cmp	r3, #2
 8000718:	d1fa      	bne.n	8000710 <SystemClock_Config+0x10>
  * @retval None
  */
__STATIC_INLINE void LL_PWR_ConfigSupply(uint32_t SupplySource)
{
  /* Set the power supply configuration */
  MODIFY_REG(PWR->CR3, (PWR_CR3_SCUEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS), SupplySource);
 800071a:	4a5a      	ldr	r2, [pc, #360]	@ (8000884 <SystemClock_Config+0x184>)
 800071c:	68d3      	ldr	r3, [r2, #12]
 800071e:	f023 0307 	bic.w	r3, r3, #7
 8000722:	f043 0302 	orr.w	r3, r3, #2
 8000726:	60d3      	str	r3, [r2, #12]
  * @retval None
  */
__STATIC_INLINE void LL_PWR_SetRegulVoltageScaling(uint32_t VoltageScaling)
{
#if defined (PWR_CPUCR_PDDS_D2)
  MODIFY_REG(PWR->D3CR, PWR_D3CR_VOS, VoltageScaling);
 8000728:	6993      	ldr	r3, [r2, #24]
 800072a:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
 800072e:	6193      	str	r3, [r2, #24]
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_VOS(void)
{
#if defined (PWR_CPUCR_PDDS_D2)
  return ((READ_BIT(PWR->D3CR, PWR_D3CR_VOSRDY) == (PWR_D3CR_VOSRDY)) ? 1UL : 0UL);
 8000730:	6993      	ldr	r3, [r2, #24]
 8000732:	0498      	lsls	r0, r3, #18
 8000734:	d5fc      	bpl.n	8000730 <SystemClock_Config+0x30>
  * @rmtoll CR           HSION         LL_RCC_HSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Enable(void)
{
  SET_BIT(RCC->CR, RCC_CR_HSION);
 8000736:	4b54      	ldr	r3, [pc, #336]	@ (8000888 <SystemClock_Config+0x188>)
 8000738:	681a      	ldr	r2, [r3, #0]
 800073a:	f042 0201 	orr.w	r2, r2, #1
 800073e:	601a      	str	r2, [r3, #0]
  * @rmtoll CR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8000740:	681a      	ldr	r2, [r3, #0]
 8000742:	0751      	lsls	r1, r2, #29
 8000744:	d5fc      	bpl.n	8000740 <SystemClock_Config+0x40>
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_SetCalibTrimming(uint32_t Value)
{
#if defined(RCC_VER_X)
  if ((DBGMCU->IDCODE & 0xF0000000U) == 0x10000000U)
 8000746:	4a51      	ldr	r2, [pc, #324]	@ (800088c <SystemClock_Config+0x18c>)
 8000748:	6812      	ldr	r2, [r2, #0]
 800074a:	f002 4270 	and.w	r2, r2, #4026531840	@ 0xf0000000
 800074e:	f1b2 5f80 	cmp.w	r2, #268435456	@ 0x10000000
  {
    /* STM32H7 Rev.Y */
    MODIFY_REG(RCC->HSICFGR, 0x3F000U, Value << 12U);
 8000752:	685a      	ldr	r2, [r3, #4]
  if ((DBGMCU->IDCODE & 0xF0000000U) == 0x10000000U)
 8000754:	f000 808d 	beq.w	8000872 <SystemClock_Config+0x172>
  }
  else
  {
    /* STM32H7 Rev.V */
    MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
 8000758:	f022 42fe 	bic.w	r2, r2, #2130706432	@ 0x7f000000
 800075c:	f042 4280 	orr.w	r2, r2, #1073741824	@ 0x40000000
 8000760:	605a      	str	r2, [r3, #4]
  MODIFY_REG(RCC->CR, RCC_CR_HSIDIV, Divider);
 8000762:	4b49      	ldr	r3, [pc, #292]	@ (8000888 <SystemClock_Config+0x188>)
 8000764:	681a      	ldr	r2, [r3, #0]
 8000766:	f022 0218 	bic.w	r2, r2, #24
 800076a:	601a      	str	r2, [r3, #0]
  * @rmtoll CR           HSI48ON         LL_RCC_HSI48_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI48_Enable(void)
{
  SET_BIT(RCC->CR, RCC_CR_HSI48ON);
 800076c:	681a      	ldr	r2, [r3, #0]
 800076e:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 8000772:	601a      	str	r2, [r3, #0]
  * @rmtoll CR           HSI48RDY        LL_RCC_HSI48_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI48_IsReady(void)
{
  return ((READ_BIT(RCC->CR, RCC_CR_HSI48RDY) == (RCC_CR_HSI48RDY)) ? 1UL : 0UL);
 8000774:	681a      	ldr	r2, [r3, #0]
 8000776:	0492      	lsls	r2, r2, #18
 8000778:	d5fc      	bpl.n	8000774 <SystemClock_Config+0x74>
  *         @arg @ref LL_RCC_PLLSOURCE_NONE
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_SetSource(uint32_t PLLSource)
{
  MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_PLLSRC, PLLSource);
 800077a:	6a99      	ldr	r1, [r3, #40]	@ 0x28
  * @rmtoll CR           PLL1RDY        LL_RCC_PLL1_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsReady(void)
{
  return ((READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == (RCC_CR_PLL1RDY)) ? 1UL : 0UL);
 800077c:	4a42      	ldr	r2, [pc, #264]	@ (8000888 <SystemClock_Config+0x188>)
  MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_PLLSRC, PLLSource);
 800077e:	f021 0103 	bic.w	r1, r1, #3
 8000782:	6299      	str	r1, [r3, #40]	@ 0x28
  * @rmtoll PLLCFGR           DIVP1EN         LL_RCC_PLL1P_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL1P_Enable(void)
{
  SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP1EN);
 8000784:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8000786:	f441 3180 	orr.w	r1, r1, #65536	@ 0x10000
 800078a:	62d9      	str	r1, [r3, #44]	@ 0x2c
  * @rmtoll PLLCFGR           DIVQ1EN         LL_RCC_PLL1Q_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL1Q_Enable(void)
{
  SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ1EN);
 800078c:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 800078e:	f441 3100 	orr.w	r1, r1, #131072	@ 0x20000
 8000792:	62d9      	str	r1, [r3, #44]	@ 0x2c
  * @rmtoll PLLCFGR           DIVR1EN         LL_RCC_PLL1R_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL1R_Enable(void)
{
  SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR1EN);
 8000794:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8000796:	f441 2180 	orr.w	r1, r1, #262144	@ 0x40000
 800079a:	62d9      	str	r1, [r3, #44]	@ 0x2c
  *         @arg @ref LL_RCC_PLLINPUTRANGE_8_16
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL1_SetVCOInputRange(uint32_t InputRange)
{
  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL1RGE, InputRange << RCC_PLLCFGR_PLL1RGE_Pos);
 800079c:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 800079e:	f041 010c 	orr.w	r1, r1, #12
 80007a2:	62d9      	str	r1, [r3, #44]	@ 0x2c
  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL1VCOSEL, VCORange << RCC_PLLCFGR_PLL1VCOSEL_Pos);
 80007a4:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 80007a6:	f021 0102 	bic.w	r1, r1, #2
 80007aa:	62d9      	str	r1, [r3, #44]	@ 0x2c
  * @rmtoll PLLCKSELR       DIVM1          LL_RCC_PLL1_SetM
  * @param  M parameter can be a value between 0 and 63
  */
__STATIC_INLINE void LL_RCC_PLL1_SetM(uint32_t M)
{
  MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM1, M << RCC_PLLCKSELR_DIVM1_Pos);
 80007ac:	6a99      	ldr	r1, [r3, #40]	@ 0x28
 80007ae:	f421 717c 	bic.w	r1, r1, #1008	@ 0x3f0
 80007b2:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
 80007b6:	6299      	str	r1, [r3, #40]	@ 0x28
  MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_N1, (N - 1UL) << RCC_PLL1DIVR_N1_Pos);
 80007b8:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 80007ba:	f36f 0108 	bfc	r1, #0, #9
 80007be:	f041 0131 	orr.w	r1, r1, #49	@ 0x31
 80007c2:	6319      	str	r1, [r3, #48]	@ 0x30
  *
  * (*) : For stm32h72xxx and stm32h73xxx family lines.
  */
__STATIC_INLINE void LL_RCC_PLL1_SetP(uint32_t P)
{
  MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_P1, (P - 1UL) << RCC_PLL1DIVR_P1_Pos);
 80007c4:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 80007c6:	f421 417e 	bic.w	r1, r1, #65024	@ 0xfe00
 80007ca:	f441 7100 	orr.w	r1, r1, #512	@ 0x200
 80007ce:	6319      	str	r1, [r3, #48]	@ 0x30
  * @rmtoll PLL1DIVR        Q1          LL_RCC_PLL1_SetQ
  * @param  Q parameter can be a value between 1 and 128
  */
__STATIC_INLINE void LL_RCC_PLL1_SetQ(uint32_t Q)
{
  MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_Q1, (Q - 1UL) << RCC_PLL1DIVR_Q1_Pos);
 80007d0:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 80007d2:	f421 01fe 	bic.w	r1, r1, #8323072	@ 0x7f0000
 80007d6:	f441 21e0 	orr.w	r1, r1, #458752	@ 0x70000
 80007da:	6319      	str	r1, [r3, #48]	@ 0x30
  * @rmtoll PLL1DIVR        R1          LL_RCC_PLL1_SetR
  * @param  R parameter can be a value between 1 and 128
  */
__STATIC_INLINE void LL_RCC_PLL1_SetR(uint32_t R)
{
  MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_R1, (R - 1UL) << RCC_PLL1DIVR_R1_Pos);
 80007dc:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 80007de:	f021 41fe 	bic.w	r1, r1, #2130706432	@ 0x7f000000
 80007e2:	f041 7180 	orr.w	r1, r1, #16777216	@ 0x1000000
 80007e6:	6319      	str	r1, [r3, #48]	@ 0x30
  SET_BIT(RCC->CR, RCC_CR_PLL1ON);
 80007e8:	6819      	ldr	r1, [r3, #0]
 80007ea:	f041 7180 	orr.w	r1, r1, #16777216	@ 0x1000000
 80007ee:	6019      	str	r1, [r3, #0]
  return ((READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == (RCC_CR_PLL1RDY)) ? 1UL : 0UL);
 80007f0:	6813      	ldr	r3, [r2, #0]
 80007f2:	019b      	lsls	r3, r3, #6
 80007f4:	d5fc      	bpl.n	80007f0 <SystemClock_Config+0xf0>
  MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, Prescaler);
 80007f6:	6993      	ldr	r3, [r2, #24]
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80007f8:	4923      	ldr	r1, [pc, #140]	@ (8000888 <SystemClock_Config+0x188>)
  MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, Prescaler);
 80007fa:	f023 030f 	bic.w	r3, r3, #15
 80007fe:	f043 0308 	orr.w	r3, r3, #8
 8000802:	6193      	str	r3, [r2, #24]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8000804:	6913      	ldr	r3, [r2, #16]
 8000806:	f023 0307 	bic.w	r3, r3, #7
 800080a:	f043 0303 	orr.w	r3, r3, #3
 800080e:	6113      	str	r3, [r2, #16]
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8000810:	690b      	ldr	r3, [r1, #16]
 8000812:	f003 0338 	and.w	r3, r3, #56	@ 0x38
  LL_RCC_SetAHBPrescaler(LL_RCC_AHB_DIV_2);

  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL1);

  /* Wait till System clock is ready */
  while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL1)
 8000816:	2b18      	cmp	r3, #24
 8000818:	d1fa      	bne.n	8000810 <SystemClock_Config+0x110>
  MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, Prescaler);
 800081a:	698b      	ldr	r3, [r1, #24]
  LL_RCC_SetAHBPrescaler(LL_RCC_AHB_DIV_2);
  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_2);
  LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_2);
  LL_RCC_SetAPB3Prescaler(LL_RCC_APB3_DIV_2);
  LL_RCC_SetAPB4Prescaler(LL_RCC_APB4_DIV_2);
  LL_SetSystemCoreClock(400000000);
 800081c:	481c      	ldr	r0, [pc, #112]	@ (8000890 <SystemClock_Config+0x190>)
 800081e:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 8000822:	618b      	str	r3, [r1, #24]
  MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, Prescaler);
 8000824:	698b      	ldr	r3, [r1, #24]
 8000826:	f023 030f 	bic.w	r3, r3, #15
 800082a:	f043 0308 	orr.w	r3, r3, #8
 800082e:	618b      	str	r3, [r1, #24]
  MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, Prescaler);
 8000830:	69cb      	ldr	r3, [r1, #28]
 8000832:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8000836:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800083a:	61cb      	str	r3, [r1, #28]
  MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, Prescaler);
 800083c:	69cb      	ldr	r3, [r1, #28]
 800083e:	f423 63e0 	bic.w	r3, r3, #1792	@ 0x700
 8000842:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8000846:	61cb      	str	r3, [r1, #28]
  MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, Prescaler);
 8000848:	698b      	ldr	r3, [r1, #24]
 800084a:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 800084e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8000852:	618b      	str	r3, [r1, #24]
  MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, Prescaler);
 8000854:	6a0b      	ldr	r3, [r1, #32]
 8000856:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 800085a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800085e:	620b      	str	r3, [r1, #32]
 8000860:	f004 fe0e 	bl	8005480 <LL_SetSystemCoreClock>

  /* Update the time base */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8000864:	200f      	movs	r0, #15
 8000866:	f001 fbad 	bl	8001fc4 <HAL_InitTick>
 800086a:	b108      	cbz	r0, 8000870 <SystemClock_Config+0x170>
  __ASM volatile ("cpsid i" : : : "memory");
 800086c:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 800086e:	e7fe      	b.n	800086e <SystemClock_Config+0x16e>
}
 8000870:	bd08      	pop	{r3, pc}
    MODIFY_REG(RCC->HSICFGR, 0x3F000U, Value << 12U);
 8000872:	f422 327c 	bic.w	r2, r2, #258048	@ 0x3f000
 8000876:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 800087a:	605a      	str	r2, [r3, #4]
 800087c:	e771      	b.n	8000762 <SystemClock_Config+0x62>
 800087e:	bf00      	nop
 8000880:	52002000 	.word	0x52002000
 8000884:	58024800 	.word	0x58024800
 8000888:	58024400 	.word	0x58024400
 800088c:	5c001000 	.word	0x5c001000
 8000890:	17d78400 	.word	0x17d78400

08000894 <main>:
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
 8000894:	4a59      	ldr	r2, [pc, #356]	@ (80009fc <main+0x168>)
{
 8000896:	b508      	push	{r3, lr}
 8000898:	6953      	ldr	r3, [r2, #20]
 800089a:	f413 3300 	ands.w	r3, r3, #131072	@ 0x20000
 800089e:	d111      	bne.n	80008c4 <main+0x30>
  __ASM volatile ("dsb 0xF":::"memory");
 80008a0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80008a4:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 80008a8:	f8c2 3250 	str.w	r3, [r2, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 80008ac:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80008b0:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 80008b4:	6953      	ldr	r3, [r2, #20]
 80008b6:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80008ba:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 80008bc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80008c0:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
 80008c4:	484d      	ldr	r0, [pc, #308]	@ (80009fc <main+0x168>)
 80008c6:	6943      	ldr	r3, [r0, #20]
 80008c8:	f413 3380 	ands.w	r3, r3, #65536	@ 0x10000
 80008cc:	d126      	bne.n	800091c <main+0x88>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 80008ce:	f8c0 3084 	str.w	r3, [r0, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 80008d2:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
 80008d6:	f8d0 3080 	ldr.w	r3, [r0, #128]	@ 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80008da:	f643 74e0 	movw	r4, #16352	@ 0x3fe0
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 80008de:	f3c3 3c4e 	ubfx	ip, r3, #13, #15
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80008e2:	f3c3 0ec9 	ubfx	lr, r3, #3, #10
 80008e6:	ea4f 1c4c 	mov.w	ip, ip, lsl #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80008ea:	ea0c 0104 	and.w	r1, ip, r4
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80008ee:	4673      	mov	r3, lr
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80008f0:	ea41 7283 	orr.w	r2, r1, r3, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 80008f4:	3b01      	subs	r3, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80008f6:	f8c0 2260 	str.w	r2, [r0, #608]	@ 0x260
      } while (ways-- != 0U);
 80008fa:	1c5a      	adds	r2, r3, #1
 80008fc:	d1f8      	bne.n	80008f0 <main+0x5c>
    } while(sets-- != 0U);
 80008fe:	f1ac 0c20 	sub.w	ip, ip, #32
 8000902:	f11c 0f20 	cmn.w	ip, #32
 8000906:	d1f0      	bne.n	80008ea <main+0x56>
 8000908:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 800090c:	6943      	ldr	r3, [r0, #20]
 800090e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8000912:	6143      	str	r3, [r0, #20]
 8000914:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000918:	f3bf 8f6f 	isb	sy
  HAL_Init();
 800091c:	f001 fb78 	bl	8002010 <HAL_Init>
  __ASM volatile ("dmb 0xF":::"memory");
 8000920:	f3bf 8f5f 	dmb	sy
__STATIC_INLINE void LL_MPU_Disable(void)
{
  /* Make sure outstanding transfers are done */
  __DMB();
  /* Disable MPU*/
  WRITE_REG(MPU->CTRL, 0U);
 8000924:	4b35      	ldr	r3, [pc, #212]	@ (80009fc <main+0x168>)
 8000926:	2200      	movs	r2, #0
  /* Set Region number */
  WRITE_REG(MPU->RNR, Region);
  /* Set base address */
  WRITE_REG(MPU->RBAR, (Address & 0xFFFFFFE0U));
  /* Configure MPU */
  WRITE_REG(MPU->RASR, (MPU_RASR_ENABLE_Msk | Attributes | (SubRegionDisable << MPU_RASR_SRD_Pos)));
 8000928:	4835      	ldr	r0, [pc, #212]	@ (8000a00 <main+0x16c>)
  WRITE_REG(MPU->RNR, Region);
 800092a:	2101      	movs	r1, #1
  WRITE_REG(MPU->CTRL, 0U);
 800092c:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
  WRITE_REG(MPU->RBAR, (Address & 0xFFFFFFE0U));
 8000930:	f04f 5410 	mov.w	r4, #603979776	@ 0x24000000
  WRITE_REG(MPU->RNR, Region);
 8000934:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
  WRITE_REG(MPU->RBAR, (Address & 0xFFFFFFE0U));
 8000938:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
  WRITE_REG(MPU->RASR, (MPU_RASR_ENABLE_Msk | Attributes | (SubRegionDisable << MPU_RASR_SRD_Pos)));
 800093c:	f8c3 00a0 	str.w	r0, [r3, #160]	@ 0xa0
 8000940:	f500 20df 	add.w	r0, r0, #456704	@ 0x6f800
  WRITE_REG(MPU->RNR, Region);
 8000944:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
  SET_BIT(MPU->RASR, MPU_RASR_ENABLE_Msk);
 8000948:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
  WRITE_REG(MPU->RASR, (MPU_RASR_ENABLE_Msk | Attributes | (SubRegionDisable << MPU_RASR_SRD_Pos)));
 800094c:	f200 70e6 	addw	r0, r0, #2022	@ 0x7e6
  SET_BIT(MPU->RASR, MPU_RASR_ENABLE_Msk);
 8000950:	430a      	orrs	r2, r1
 8000952:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
  WRITE_REG(MPU->RNR, Region);
 8000956:	f8c3 1098 	str.w	r1, [r3, #152]	@ 0x98
  WRITE_REG(MPU->RBAR, (Address & 0xFFFFFFE0U));
 800095a:	f8c3 409c 	str.w	r4, [r3, #156]	@ 0x9c
 800095e:	f04f 4410 	mov.w	r4, #2415919104	@ 0x90000000
  WRITE_REG(MPU->RASR, (MPU_RASR_ENABLE_Msk | Attributes | (SubRegionDisable << MPU_RASR_SRD_Pos)));
 8000962:	f8c3 00a0 	str.w	r0, [r3, #160]	@ 0xa0
 8000966:	300a      	adds	r0, #10
  WRITE_REG(MPU->RNR, Region);
 8000968:	f8c3 1098 	str.w	r1, [r3, #152]	@ 0x98
  WRITE_REG(MPU->RNR, Region);
 800096c:	2102      	movs	r1, #2
  SET_BIT(MPU->RASR, MPU_RASR_ENABLE_Msk);
 800096e:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
 8000972:	f042 0201 	orr.w	r2, r2, #1
 8000976:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
  WRITE_REG(MPU->RNR, Region);
 800097a:	f8c3 1098 	str.w	r1, [r3, #152]	@ 0x98
  WRITE_REG(MPU->RBAR, (Address & 0xFFFFFFE0U));
 800097e:	f8c3 409c 	str.w	r4, [r3, #156]	@ 0x9c
 8000982:	f04f 6400 	mov.w	r4, #134217728	@ 0x8000000
  WRITE_REG(MPU->RASR, (MPU_RASR_ENABLE_Msk | Attributes | (SubRegionDisable << MPU_RASR_SRD_Pos)));
 8000986:	f8c3 00a0 	str.w	r0, [r3, #160]	@ 0xa0
 800098a:	380e      	subs	r0, #14
  WRITE_REG(MPU->RNR, Region);
 800098c:	f8c3 1098 	str.w	r1, [r3, #152]	@ 0x98
  WRITE_REG(MPU->RNR, Region);
 8000990:	2103      	movs	r1, #3
  SET_BIT(MPU->RASR, MPU_RASR_ENABLE_Msk);
 8000992:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
 8000996:	f042 0201 	orr.w	r2, r2, #1
 800099a:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
  WRITE_REG(MPU->RNR, Region);
 800099e:	f8c3 1098 	str.w	r1, [r3, #152]	@ 0x98
  WRITE_REG(MPU->RBAR, (Address & 0xFFFFFFE0U));
 80009a2:	f8c3 409c 	str.w	r4, [r3, #156]	@ 0x9c
  WRITE_REG(MPU->RASR, (MPU_RASR_ENABLE_Msk | Attributes | (SubRegionDisable << MPU_RASR_SRD_Pos)));
 80009a6:	f8c3 00a0 	str.w	r0, [r3, #160]	@ 0xa0
  WRITE_REG(MPU->RNR, Region);
 80009aa:	f8c3 1098 	str.w	r1, [r3, #152]	@ 0x98
  WRITE_REG(MPU->CTRL, (MPU_CTRL_ENABLE_Msk | Options));
 80009ae:	2105      	movs	r1, #5
  SET_BIT(MPU->RASR, MPU_RASR_ENABLE_Msk);
 80009b0:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
 80009b4:	f042 0201 	orr.w	r2, r2, #1
 80009b8:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
  WRITE_REG(MPU->CTRL, (MPU_CTRL_ENABLE_Msk | Options));
 80009bc:	f8c3 1094 	str.w	r1, [r3, #148]	@ 0x94
  __ASM volatile ("dsb 0xF":::"memory");
 80009c0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80009c4:	f3bf 8f6f 	isb	sy
  SystemClock_Config();
 80009c8:	f7ff fe9a 	bl	8000700 <SystemClock_Config>
  MX_GPIO_Init();
 80009cc:	f7ff fda8 	bl	8000520 <MX_GPIO_Init>
  MX_DMA_Init();
 80009d0:	f7ff fd52 	bl	8000478 <MX_DMA_Init>
  MX_QUADSPI_Init();
 80009d4:	f000 f818 	bl	8000a08 <MX_QUADSPI_Init>
  MX_RAMECC_Init();
 80009d8:	f000 f8b0 	bl	8000b3c <MX_RAMECC_Init>
  MX_SDMMC1_SD_Init();
 80009dc:	f000 ff24 	bl	8001828 <MX_SDMMC1_SD_Init>
  MX_SPI1_Init();
 80009e0:	f000 ff24 	bl	800182c <MX_SPI1_Init>
  MX_SPI4_Init();
 80009e4:	f000 ff86 	bl	80018f4 <MX_SPI4_Init>
  MX_USART1_UART_Init();
 80009e8:	f001 f940 	bl	8001c6c <MX_USART1_UART_Init>
  MX_USART2_UART_Init();
 80009ec:	f001 fa24 	bl	8001e38 <MX_USART2_UART_Init>
  bsp_init_scd();
 80009f0:	f7ff fcc6 	bl	8000380 <bsp_init_scd>
    MX_USB_HOST_Process();
 80009f4:	f006 f9ee 	bl	8006dd4 <MX_USB_HOST_Process>
  while (1)
 80009f8:	e7fc      	b.n	80009f4 <main+0x160>
 80009fa:	bf00      	nop
 80009fc:	e000ed00 	.word	0xe000ed00
 8000a00:	0304003f 	.word	0x0304003f

08000a04 <Error_Handler>:
  __ASM volatile ("cpsid i" : : : "memory");
 8000a04:	b672      	cpsid	i
  while (1)
 8000a06:	e7fe      	b.n	8000a06 <Error_Handler+0x2>

08000a08 <MX_QUADSPI_Init>:

QSPI_HandleTypeDef hqspi;

/* QUADSPI init function */
void MX_QUADSPI_Init(void)
{
 8000a08:	b510      	push	{r4, lr}
  /* USER CODE END QUADSPI_Init 0 */

  /* USER CODE BEGIN QUADSPI_Init 1 */

  /* USER CODE END QUADSPI_Init 1 */
  hqspi.Instance = QUADSPI;
 8000a0a:	480b      	ldr	r0, [pc, #44]	@ (8000a38 <MX_QUADSPI_Init+0x30>)
  hqspi.Init.ClockPrescaler = 255;
 8000a0c:	2300      	movs	r3, #0
 8000a0e:	2201      	movs	r2, #1
  hqspi.Instance = QUADSPI;
 8000a10:	4c0a      	ldr	r4, [pc, #40]	@ (8000a3c <MX_QUADSPI_Init+0x34>)
  hqspi.Init.ClockPrescaler = 255;
 8000a12:	21ff      	movs	r1, #255	@ 0xff
 8000a14:	60c3      	str	r3, [r0, #12]
  hqspi.Instance = QUADSPI;
 8000a16:	6004      	str	r4, [r0, #0]
  hqspi.Init.ClockPrescaler = 255;
 8000a18:	6203      	str	r3, [r0, #32]
 8000a1a:	e9c0 1201 	strd	r1, r2, [r0, #4]
 8000a1e:	e9c0 2304 	strd	r2, r3, [r0, #16]
 8000a22:	e9c0 3306 	strd	r3, r3, [r0, #24]
  hqspi.Init.FlashSize = 1;
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
  hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;
  hqspi.Init.FlashID = QSPI_FLASH_ID_1;
  hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
  if (HAL_QSPI_Init(&hqspi) != HAL_OK)
 8000a26:	f003 f859 	bl	8003adc <HAL_QSPI_Init>
 8000a2a:	b900      	cbnz	r0, 8000a2e <MX_QUADSPI_Init+0x26>
  }
  /* USER CODE BEGIN QUADSPI_Init 2 */

  /* USER CODE END QUADSPI_Init 2 */

}
 8000a2c:	bd10      	pop	{r4, pc}
 8000a2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    Error_Handler();
 8000a32:	f7ff bfe7 	b.w	8000a04 <Error_Handler>
 8000a36:	bf00      	nop
 8000a38:	24000160 	.word	0x24000160
 8000a3c:	52005000 	.word	0x52005000

08000a40 <HAL_QSPI_MspInit>:

void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(qspiHandle->Instance==QUADSPI)
 8000a40:	4b39      	ldr	r3, [pc, #228]	@ (8000b28 <HAL_QSPI_MspInit+0xe8>)
 8000a42:	6802      	ldr	r2, [r0, #0]
{
 8000a44:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(qspiHandle->Instance==QUADSPI)
 8000a46:	429a      	cmp	r2, r3
{
 8000a48:	b08b      	sub	sp, #44	@ 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000a4a:	f04f 0400 	mov.w	r4, #0
 8000a4e:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8000a52:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8000a56:	9408      	str	r4, [sp, #32]
  if(qspiHandle->Instance==QUADSPI)
 8000a58:	d001      	beq.n	8000a5e <HAL_QSPI_MspInit+0x1e>

  /* USER CODE BEGIN QUADSPI_MspInit 1 */

  /* USER CODE END QUADSPI_MspInit 1 */
  }
}
 8000a5a:	b00b      	add	sp, #44	@ 0x2c
 8000a5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  MODIFY_REG(RCC->D1CCIPR, RCC_D1CCIPR_QSPISEL, ClkSource);
 8000a5e:	4b33      	ldr	r3, [pc, #204]	@ (8000b2c <HAL_QSPI_MspInit+0xec>)
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000a60:	2503      	movs	r5, #3
 8000a62:	2709      	movs	r7, #9
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8000a64:	4832      	ldr	r0, [pc, #200]	@ (8000b30 <HAL_QSPI_MspInit+0xf0>)
 8000a66:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000a68:	2602      	movs	r6, #2
 8000a6a:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
 8000a6e:	64da      	str	r2, [r3, #76]	@ 0x4c
    __HAL_RCC_QSPI_CLK_ENABLE();
 8000a70:	f8d3 20d4 	ldr.w	r2, [r3, #212]	@ 0xd4
 8000a74:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 8000a78:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
 8000a7c:	f8d3 20d4 	ldr.w	r2, [r3, #212]	@ 0xd4
 8000a80:	f402 4280 	and.w	r2, r2, #16384	@ 0x4000
 8000a84:	9200      	str	r2, [sp, #0]
 8000a86:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8000a88:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8000a8c:	f042 0210 	orr.w	r2, r2, #16
 8000a90:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 8000a94:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8000a98:	f002 0210 	and.w	r2, r2, #16
 8000a9c:	9201      	str	r2, [sp, #4]
 8000a9e:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8000aa0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8000aa4:	f042 0202 	orr.w	r2, r2, #2
 8000aa8:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 8000aac:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8000ab0:	f002 0202 	and.w	r2, r2, #2
 8000ab4:	9202      	str	r2, [sp, #8]
 8000ab6:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8000ab8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8000abc:	f042 0208 	orr.w	r2, r2, #8
 8000ac0:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8000ac4:	2204      	movs	r2, #4
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8000ac6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8000aca:	f003 0308 	and.w	r3, r3, #8
 8000ace:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8000ad0:	2302      	movs	r3, #2
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8000ad2:	9903      	ldr	r1, [sp, #12]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8000ad4:	a904      	add	r1, sp, #16
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8000ad6:	e9cd 2304 	strd	r2, r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000ada:	e9cd 5707 	strd	r5, r7, [sp, #28]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8000ade:	f001 fbff 	bl	80022e0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8000ae2:	2304      	movs	r3, #4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000ae4:	a904      	add	r1, sp, #16
 8000ae6:	4813      	ldr	r0, [pc, #76]	@ (8000b34 <HAL_QSPI_MspInit+0xf4>)
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8000ae8:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
 8000aea:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000aec:	9605      	str	r6, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000aee:	e9cd 4506 	strd	r4, r5, [sp, #24]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000af2:	f001 fbf5 	bl	80022e0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13;
 8000af6:	f44f 5360 	mov.w	r3, #14336	@ 0x3800
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8000afa:	a904      	add	r1, sp, #16
 8000afc:	480e      	ldr	r0, [pc, #56]	@ (8000b38 <HAL_QSPI_MspInit+0xf8>)
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13;
 8000afe:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
 8000b00:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000b02:	9507      	str	r5, [sp, #28]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b04:	e9cd 6405 	strd	r6, r4, [sp, #20]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8000b08:	f001 fbea 	bl	80022e0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 8000b0c:	2240      	movs	r2, #64	@ 0x40
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 8000b0e:	230a      	movs	r3, #10
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000b10:	a904      	add	r1, sp, #16
 8000b12:	4808      	ldr	r0, [pc, #32]	@ (8000b34 <HAL_QSPI_MspInit+0xf4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000b14:	9605      	str	r6, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 8000b16:	9204      	str	r2, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b18:	9406      	str	r4, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 8000b1a:	e9cd 5307 	strd	r5, r3, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000b1e:	f001 fbdf 	bl	80022e0 <HAL_GPIO_Init>
}
 8000b22:	b00b      	add	sp, #44	@ 0x2c
 8000b24:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000b26:	bf00      	nop
 8000b28:	52005000 	.word	0x52005000
 8000b2c:	58024400 	.word	0x58024400
 8000b30:	58021000 	.word	0x58021000
 8000b34:	58020400 	.word	0x58020400
 8000b38:	58020c00 	.word	0x58020c00

08000b3c <MX_RAMECC_Init>:
RAMECC_HandleTypeDef hramecc3_m1;
RAMECC_HandleTypeDef hramecc3_m2;

/* RAMECC init function */
void MX_RAMECC_Init(void)
{
 8000b3c:	b508      	push	{r3, lr}

  /* USER CODE END RAMECC_Init 1 */

  /** Initialize RAMECC1 M1 : AXI SRAM
  */
  hramecc1_m1.Instance = RAMECC1_Monitor1;
 8000b3e:	483a      	ldr	r0, [pc, #232]	@ (8000c28 <MX_RAMECC_Init+0xec>)
 8000b40:	4b3a      	ldr	r3, [pc, #232]	@ (8000c2c <MX_RAMECC_Init+0xf0>)
 8000b42:	6003      	str	r3, [r0, #0]
  if (HAL_RAMECC_Init(&hramecc1_m1) != HAL_OK)
 8000b44:	f003 f828 	bl	8003b98 <HAL_RAMECC_Init>
 8000b48:	2800      	cmp	r0, #0
 8000b4a:	d148      	bne.n	8000bde <MX_RAMECC_Init+0xa2>
    Error_Handler();
  }

  /** Initialize RAMECC1 M2 : ITCM-RAM
  */
  hramecc1_m2.Instance = RAMECC1_Monitor2;
 8000b4c:	4838      	ldr	r0, [pc, #224]	@ (8000c30 <MX_RAMECC_Init+0xf4>)
 8000b4e:	4b39      	ldr	r3, [pc, #228]	@ (8000c34 <MX_RAMECC_Init+0xf8>)
 8000b50:	6003      	str	r3, [r0, #0]
  if (HAL_RAMECC_Init(&hramecc1_m2) != HAL_OK)
 8000b52:	f003 f821 	bl	8003b98 <HAL_RAMECC_Init>
 8000b56:	2800      	cmp	r0, #0
 8000b58:	d163      	bne.n	8000c22 <MX_RAMECC_Init+0xe6>
    Error_Handler();
  }

  /** Initialize RAMECC1 M3 : D0TCM-RAM
  */
  hramecc1_m3.Instance = RAMECC1_Monitor3;
 8000b5a:	4837      	ldr	r0, [pc, #220]	@ (8000c38 <MX_RAMECC_Init+0xfc>)
 8000b5c:	4b37      	ldr	r3, [pc, #220]	@ (8000c3c <MX_RAMECC_Init+0x100>)
 8000b5e:	6003      	str	r3, [r0, #0]
  if (HAL_RAMECC_Init(&hramecc1_m3) != HAL_OK)
 8000b60:	f003 f81a 	bl	8003b98 <HAL_RAMECC_Init>
 8000b64:	2800      	cmp	r0, #0
 8000b66:	d159      	bne.n	8000c1c <MX_RAMECC_Init+0xe0>
    Error_Handler();
  }

  /** Initialize RAMECC1 M4 : D1TCM-RAM
  */
  hramecc1_m4.Instance = RAMECC1_Monitor4;
 8000b68:	4835      	ldr	r0, [pc, #212]	@ (8000c40 <MX_RAMECC_Init+0x104>)
 8000b6a:	4b36      	ldr	r3, [pc, #216]	@ (8000c44 <MX_RAMECC_Init+0x108>)
 8000b6c:	6003      	str	r3, [r0, #0]
  if (HAL_RAMECC_Init(&hramecc1_m4) != HAL_OK)
 8000b6e:	f003 f813 	bl	8003b98 <HAL_RAMECC_Init>
 8000b72:	2800      	cmp	r0, #0
 8000b74:	d14f      	bne.n	8000c16 <MX_RAMECC_Init+0xda>
    Error_Handler();
  }

  /** Initialize RAMECC1 M5 : ETM RAM
  */
  hramecc1_m5.Instance = RAMECC1_Monitor5;
 8000b76:	4834      	ldr	r0, [pc, #208]	@ (8000c48 <MX_RAMECC_Init+0x10c>)
 8000b78:	4b34      	ldr	r3, [pc, #208]	@ (8000c4c <MX_RAMECC_Init+0x110>)
 8000b7a:	6003      	str	r3, [r0, #0]
  if (HAL_RAMECC_Init(&hramecc1_m5) != HAL_OK)
 8000b7c:	f003 f80c 	bl	8003b98 <HAL_RAMECC_Init>
 8000b80:	2800      	cmp	r0, #0
 8000b82:	d145      	bne.n	8000c10 <MX_RAMECC_Init+0xd4>
    Error_Handler();
  }

  /** Initialize RAMECC2 M1 : SRAM1_0
  */
  hramecc2_m1.Instance = RAMECC2_Monitor1;
 8000b84:	4832      	ldr	r0, [pc, #200]	@ (8000c50 <MX_RAMECC_Init+0x114>)
 8000b86:	4b33      	ldr	r3, [pc, #204]	@ (8000c54 <MX_RAMECC_Init+0x118>)
 8000b88:	6003      	str	r3, [r0, #0]
  if (HAL_RAMECC_Init(&hramecc2_m1) != HAL_OK)
 8000b8a:	f003 f805 	bl	8003b98 <HAL_RAMECC_Init>
 8000b8e:	2800      	cmp	r0, #0
 8000b90:	d13b      	bne.n	8000c0a <MX_RAMECC_Init+0xce>
    Error_Handler();
  }

  /** Initialize RAMECC2 M2 SRAM1_1
  */
  hramecc2_m2.Instance = RAMECC2_Monitor2;
 8000b92:	4831      	ldr	r0, [pc, #196]	@ (8000c58 <MX_RAMECC_Init+0x11c>)
 8000b94:	4b31      	ldr	r3, [pc, #196]	@ (8000c5c <MX_RAMECC_Init+0x120>)
 8000b96:	6003      	str	r3, [r0, #0]
  if (HAL_RAMECC_Init(&hramecc2_m2) != HAL_OK)
 8000b98:	f002 fffe 	bl	8003b98 <HAL_RAMECC_Init>
 8000b9c:	2800      	cmp	r0, #0
 8000b9e:	d131      	bne.n	8000c04 <MX_RAMECC_Init+0xc8>
    Error_Handler();
  }

  /** Initialize RAMECC2 M3 : SRAM2_0
  */
  hramecc2_m3.Instance = RAMECC2_Monitor3;
 8000ba0:	482f      	ldr	r0, [pc, #188]	@ (8000c60 <MX_RAMECC_Init+0x124>)
 8000ba2:	4b30      	ldr	r3, [pc, #192]	@ (8000c64 <MX_RAMECC_Init+0x128>)
 8000ba4:	6003      	str	r3, [r0, #0]
  if (HAL_RAMECC_Init(&hramecc2_m3) != HAL_OK)
 8000ba6:	f002 fff7 	bl	8003b98 <HAL_RAMECC_Init>
 8000baa:	bb40      	cbnz	r0, 8000bfe <MX_RAMECC_Init+0xc2>
    Error_Handler();
  }

  /** Initialize RAMECC2 M4 : SRAM2_1
  */
  hramecc2_m4.Instance = RAMECC2_Monitor4;
 8000bac:	482e      	ldr	r0, [pc, #184]	@ (8000c68 <MX_RAMECC_Init+0x12c>)
 8000bae:	4b2f      	ldr	r3, [pc, #188]	@ (8000c6c <MX_RAMECC_Init+0x130>)
 8000bb0:	6003      	str	r3, [r0, #0]
  if (HAL_RAMECC_Init(&hramecc2_m4) != HAL_OK)
 8000bb2:	f002 fff1 	bl	8003b98 <HAL_RAMECC_Init>
 8000bb6:	b9f8      	cbnz	r0, 8000bf8 <MX_RAMECC_Init+0xbc>
    Error_Handler();
  }

  /** Initialize RAMECC2 M5 : SRAM3
  */
  hramecc2_m5.Instance = RAMECC2_Monitor5;
 8000bb8:	482d      	ldr	r0, [pc, #180]	@ (8000c70 <MX_RAMECC_Init+0x134>)
 8000bba:	4b2e      	ldr	r3, [pc, #184]	@ (8000c74 <MX_RAMECC_Init+0x138>)
 8000bbc:	6003      	str	r3, [r0, #0]
  if (HAL_RAMECC_Init(&hramecc2_m5) != HAL_OK)
 8000bbe:	f002 ffeb 	bl	8003b98 <HAL_RAMECC_Init>
 8000bc2:	b9b0      	cbnz	r0, 8000bf2 <MX_RAMECC_Init+0xb6>
    Error_Handler();
  }

  /** Initialize RAMECC3 M1 : SRAM4
  */
  hramecc3_m1.Instance = RAMECC3_Monitor1;
 8000bc4:	482c      	ldr	r0, [pc, #176]	@ (8000c78 <MX_RAMECC_Init+0x13c>)
 8000bc6:	4b2d      	ldr	r3, [pc, #180]	@ (8000c7c <MX_RAMECC_Init+0x140>)
 8000bc8:	6003      	str	r3, [r0, #0]
  if (HAL_RAMECC_Init(&hramecc3_m1) != HAL_OK)
 8000bca:	f002 ffe5 	bl	8003b98 <HAL_RAMECC_Init>
 8000bce:	b968      	cbnz	r0, 8000bec <MX_RAMECC_Init+0xb0>
    Error_Handler();
  }

  /** Initialize RAMECC3 M2 : Backup RAM
  */
  hramecc3_m2.Instance = RAMECC3_Monitor2;
 8000bd0:	482b      	ldr	r0, [pc, #172]	@ (8000c80 <MX_RAMECC_Init+0x144>)
 8000bd2:	4b2c      	ldr	r3, [pc, #176]	@ (8000c84 <MX_RAMECC_Init+0x148>)
 8000bd4:	6003      	str	r3, [r0, #0]
  if (HAL_RAMECC_Init(&hramecc3_m2) != HAL_OK)
 8000bd6:	f002 ffdf 	bl	8003b98 <HAL_RAMECC_Init>
 8000bda:	b918      	cbnz	r0, 8000be4 <MX_RAMECC_Init+0xa8>
  }
  /* USER CODE BEGIN RAMECC_Init 2 */

  /* USER CODE END RAMECC_Init 2 */

}
 8000bdc:	bd08      	pop	{r3, pc}
    Error_Handler();
 8000bde:	f7ff ff11 	bl	8000a04 <Error_Handler>
 8000be2:	e7b3      	b.n	8000b4c <MX_RAMECC_Init+0x10>
}
 8000be4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8000be8:	f7ff bf0c 	b.w	8000a04 <Error_Handler>
    Error_Handler();
 8000bec:	f7ff ff0a 	bl	8000a04 <Error_Handler>
 8000bf0:	e7ee      	b.n	8000bd0 <MX_RAMECC_Init+0x94>
    Error_Handler();
 8000bf2:	f7ff ff07 	bl	8000a04 <Error_Handler>
 8000bf6:	e7e5      	b.n	8000bc4 <MX_RAMECC_Init+0x88>
    Error_Handler();
 8000bf8:	f7ff ff04 	bl	8000a04 <Error_Handler>
 8000bfc:	e7dc      	b.n	8000bb8 <MX_RAMECC_Init+0x7c>
    Error_Handler();
 8000bfe:	f7ff ff01 	bl	8000a04 <Error_Handler>
 8000c02:	e7d3      	b.n	8000bac <MX_RAMECC_Init+0x70>
    Error_Handler();
 8000c04:	f7ff fefe 	bl	8000a04 <Error_Handler>
 8000c08:	e7ca      	b.n	8000ba0 <MX_RAMECC_Init+0x64>
    Error_Handler();
 8000c0a:	f7ff fefb 	bl	8000a04 <Error_Handler>
 8000c0e:	e7c0      	b.n	8000b92 <MX_RAMECC_Init+0x56>
    Error_Handler();
 8000c10:	f7ff fef8 	bl	8000a04 <Error_Handler>
 8000c14:	e7b6      	b.n	8000b84 <MX_RAMECC_Init+0x48>
    Error_Handler();
 8000c16:	f7ff fef5 	bl	8000a04 <Error_Handler>
 8000c1a:	e7ac      	b.n	8000b76 <MX_RAMECC_Init+0x3a>
    Error_Handler();
 8000c1c:	f7ff fef2 	bl	8000a04 <Error_Handler>
 8000c20:	e7a2      	b.n	8000b68 <MX_RAMECC_Init+0x2c>
    Error_Handler();
 8000c22:	f7ff feef 	bl	8000a04 <Error_Handler>
 8000c26:	e798      	b.n	8000b5a <MX_RAMECC_Init+0x1e>
 8000c28:	2400025c 	.word	0x2400025c
 8000c2c:	52009020 	.word	0x52009020
 8000c30:	2400024c 	.word	0x2400024c
 8000c34:	52009040 	.word	0x52009040
 8000c38:	2400023c 	.word	0x2400023c
 8000c3c:	52009060 	.word	0x52009060
 8000c40:	2400022c 	.word	0x2400022c
 8000c44:	52009080 	.word	0x52009080
 8000c48:	2400021c 	.word	0x2400021c
 8000c4c:	520090a0 	.word	0x520090a0
 8000c50:	2400020c 	.word	0x2400020c
 8000c54:	48023020 	.word	0x48023020
 8000c58:	240001fc 	.word	0x240001fc
 8000c5c:	48023040 	.word	0x48023040
 8000c60:	240001ec 	.word	0x240001ec
 8000c64:	48023060 	.word	0x48023060
 8000c68:	240001dc 	.word	0x240001dc
 8000c6c:	48023080 	.word	0x48023080
 8000c70:	240001cc 	.word	0x240001cc
 8000c74:	480230a0 	.word	0x480230a0
 8000c78:	240001bc 	.word	0x240001bc
 8000c7c:	58027020 	.word	0x58027020
 8000c80:	240001ac 	.word	0x240001ac
 8000c84:	58027040 	.word	0x58027040

08000c88 <SCO_get>:

#if SCD_IF_USE_RAM_FUNCS
#pragma CODE_SECTION(SCO_get, MEM_MACRO);
#endif
static uint16_t SCO_get(struct SCD_CTRL_STRUCT *scd)
{
 8000c88:	b410      	push	{r4}
#define SCO_STARTBYTE_NUM 0
#define SCO_ENDBYTE_NUM 4

    // 起始位和结束位定义
    const unsigned char startByte[SCO_STARTBYTE_NUM + 1] = {0x00};
    const unsigned char endByte[SCO_ENDBYTE_NUM + 1] = {0x00, 0x00, 0x80, 0x7f};
 8000c8a:	2100      	movs	r1, #0
{
 8000c8c:	b083      	sub	sp, #12
    const unsigned char endByte[SCO_ENDBYTE_NUM + 1] = {0x00, 0x00, 0x80, 0x7f};
 8000c8e:	f04f 44ff 	mov.w	r4, #2139095040	@ 0x7f800000
{
 8000c92:	4603      	mov	r3, r0

    if (scd->structToSend == 0)
 8000c94:	f8b3 204c 	ldrh.w	r2, [r3, #76]	@ 0x4c
    const unsigned char endByte[SCO_ENDBYTE_NUM + 1] = {0x00, 0x00, 0x80, 0x7f};
 8000c98:	9400      	str	r4, [sp, #0]
    if (scd->structToSend == 0)
 8000c9a:	b210      	sxth	r0, r2
    const unsigned char endByte[SCO_ENDBYTE_NUM + 1] = {0x00, 0x00, 0x80, 0x7f};
 8000c9c:	f88d 1004 	strb.w	r1, [sp, #4]
    if (scd->structToSend == 0)
 8000ca0:	b968      	cbnz	r0, 8000cbe <SCO_get+0x36>
    {
        // 起始位
        if (scd->byteToSend < SCO_STARTBYTE_NUM)
 8000ca2:	f8b3 c04a 	ldrh.w	ip, [r3, #74]	@ 0x4a
 8000ca6:	f41c 4f00 	tst.w	ip, #32768	@ 0x8000
 8000caa:	d122      	bne.n	8000cf2 <SCO_get+0x6a>
        {
            return startByte[scd->byteToSend++];
        }
        else
        {
            scd->byteToSend = 0;
 8000cac:	f8a3 204a 	strh.w	r2, [r3, #74]	@ 0x4a
            scd->structToSend++;
 8000cb0:	f8b3 204c 	ldrh.w	r2, [r3, #76]	@ 0x4c
 8000cb4:	3201      	adds	r2, #1
 8000cb6:	b212      	sxth	r2, r2
 8000cb8:	f8a3 204c 	strh.w	r2, [r3, #76]	@ 0x4c
            // 起始位发送完成，递归找下一数据
            return SCO_get(scd);
 8000cbc:	e7ea      	b.n	8000c94 <SCO_get+0xc>
        }
    }
    else if (scd->structToSendTab[scd->structToSend - 1] > scd->structNum)
 8000cbe:	f8b3 204c 	ldrh.w	r2, [r3, #76]	@ 0x4c
 8000cc2:	b212      	sxth	r2, r2
 8000cc4:	3a01      	subs	r2, #1
 8000cc6:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
 8000cca:	f8b3 2044 	ldrh.w	r2, [r3, #68]	@ 0x44
 8000cce:	b200      	sxth	r0, r0
 8000cd0:	b212      	sxth	r2, r2
 8000cd2:	4290      	cmp	r0, r2
    {
        // 结束位
        if (scd->byteToSend < SCO_ENDBYTE_NUM)
 8000cd4:	f8b3 204a 	ldrh.w	r2, [r3, #74]	@ 0x4a
 8000cd8:	b212      	sxth	r2, r2
    else if (scd->structToSendTab[scd->structToSend - 1] > scd->structNum)
 8000cda:	dc14      	bgt.n	8000d06 <SCO_get+0x7e>
        }
    }
    else
    {
        //数据位
        if (scd->byteToSend < (4))
 8000cdc:	2a03      	cmp	r2, #3
 8000cde:	dd23      	ble.n	8000d28 <SCO_get+0xa0>
                return (*tempPtr) & 0xffu;
            }
        }
        else
        {
            scd->byteToSend = 0;
 8000ce0:	f8a3 104a 	strh.w	r1, [r3, #74]	@ 0x4a
            scd->structToSend++;
 8000ce4:	f8b3 204c 	ldrh.w	r2, [r3, #76]	@ 0x4c
 8000ce8:	3201      	adds	r2, #1
 8000cea:	b212      	sxth	r2, r2
 8000cec:	f8a3 204c 	strh.w	r2, [r3, #76]	@ 0x4c
            // 数据位发送完成，递归找下一数据
            return SCO_get(scd);
 8000cf0:	e7d0      	b.n	8000c94 <SCO_get+0xc>
            return startByte[scd->byteToSend++];
 8000cf2:	f8b3 204a 	ldrh.w	r2, [r3, #74]	@ 0x4a
 8000cf6:	3201      	adds	r2, #1
 8000cf8:	b212      	sxth	r2, r2
 8000cfa:	f8a3 204a 	strh.w	r2, [r3, #74]	@ 0x4a
        }
    }
}
 8000cfe:	b003      	add	sp, #12
 8000d00:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000d04:	4770      	bx	lr
        if (scd->byteToSend < SCO_ENDBYTE_NUM)
 8000d06:	2a03      	cmp	r2, #3
 8000d08:	dc4e      	bgt.n	8000da8 <SCO_get+0x120>
            return endByte[scd->byteToSend++];
 8000d0a:	f8b3 204a 	ldrh.w	r2, [r3, #74]	@ 0x4a
 8000d0e:	a802      	add	r0, sp, #8
 8000d10:	1c51      	adds	r1, r2, #1
 8000d12:	fa00 f282 	sxtah	r2, r0, r2
 8000d16:	b209      	sxth	r1, r1
 8000d18:	f812 0c08 	ldrb.w	r0, [r2, #-8]
 8000d1c:	f8a3 104a 	strh.w	r1, [r3, #74]	@ 0x4a
}
 8000d20:	b003      	add	sp, #12
 8000d22:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000d26:	4770      	bx	lr
            if (scd->byteToSend == 0)
 8000d28:	f8b3 204a 	ldrh.w	r2, [r3, #74]	@ 0x4a
 8000d2c:	b212      	sxth	r2, r2
 8000d2e:	bb02      	cbnz	r2, 8000d72 <SCO_get+0xea>
                uint16_t judgeType = (scd->_unit_struct[scd->structToSendTab[scd->structToSend - 1]]._type) & 0xffu;
 8000d30:	f8b3 204c 	ldrh.w	r2, [r3, #76]	@ 0x4c
 8000d34:	6bdc      	ldr	r4, [r3, #60]	@ 0x3c
 8000d36:	b212      	sxth	r2, r2
 8000d38:	3a01      	subs	r2, #1
 8000d3a:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
                void *tempCommonPtr = (void *)scd->_unit_struct[scd->structToSendTab[scd->structToSend - 1]]._addr;
 8000d3e:	f8b3 104c 	ldrh.w	r1, [r3, #76]	@ 0x4c
                uint16_t judgeType = (scd->_unit_struct[scd->structToSendTab[scd->structToSend - 1]]._type) & 0xffu;
 8000d42:	b212      	sxth	r2, r2
                void *tempCommonPtr = (void *)scd->_unit_struct[scd->structToSendTab[scd->structToSend - 1]]._addr;
 8000d44:	b209      	sxth	r1, r1
                uint16_t judgeType = (scd->_unit_struct[scd->structToSendTab[scd->structToSend - 1]]._type) & 0xffu;
 8000d46:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
                void *tempCommonPtr = (void *)scd->_unit_struct[scd->structToSendTab[scd->structToSend - 1]]._addr;
 8000d4a:	3901      	subs	r1, #1
 8000d4c:	7910      	ldrb	r0, [r2, #4]
 8000d4e:	f833 1011 	ldrh.w	r1, [r3, r1, lsl #1]
 8000d52:	2814      	cmp	r0, #20
 8000d54:	b20a      	sxth	r2, r1
 8000d56:	f854 2032 	ldr.w	r2, [r4, r2, lsl #3]
                if (judgeType == TYJ_uint16_t)
 8000d5a:	d045      	beq.n	8000de8 <SCO_get+0x160>
 8000d5c:	dc2e      	bgt.n	8000dbc <SCO_get+0x134>
 8000d5e:	2802      	cmp	r0, #2
 8000d60:	d03a      	beq.n	8000dd8 <SCO_get+0x150>
 8000d62:	2804      	cmp	r0, #4
 8000d64:	d147      	bne.n	8000df6 <SCO_get+0x16e>
                    scd->tempBuff = *tempPtr;
 8000d66:	edd2 7a00 	vldr	s15, [r2]
 8000d6a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8000d6e:	edc3 7a10 	vstr	s15, [r3, #64]	@ 0x40
            tempPtr = &tempPtr[scd->byteToSend >> 1];
 8000d72:	f8b3 104a 	ldrh.w	r1, [r3, #74]	@ 0x4a
            uint16_t *tempPtr = (uint16_t *)(void *)&(scd->tempBuff);
 8000d76:	f103 0440 	add.w	r4, r3, #64	@ 0x40
            if (scd->byteToSend++ & 0x1)
 8000d7a:	f8b3 004a 	ldrh.w	r0, [r3, #74]	@ 0x4a
            tempPtr = &tempPtr[scd->byteToSend >> 1];
 8000d7e:	f341 014e 	sbfx	r1, r1, #1, #15
            if (scd->byteToSend++ & 0x1)
 8000d82:	1c42      	adds	r2, r0, #1
 8000d84:	b212      	sxth	r2, r2
 8000d86:	f8a3 204a 	strh.w	r2, [r3, #74]	@ 0x4a
 8000d8a:	07c3      	lsls	r3, r0, #31
 8000d8c:	d506      	bpl.n	8000d9c <SCO_get+0x114>
                return ((*tempPtr) >> 8) & 0xffu;
 8000d8e:	f834 0011 	ldrh.w	r0, [r4, r1, lsl #1]
 8000d92:	0a00      	lsrs	r0, r0, #8
}
 8000d94:	b003      	add	sp, #12
 8000d96:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000d9a:	4770      	bx	lr
                return (*tempPtr) & 0xffu;
 8000d9c:	f814 0011 	ldrb.w	r0, [r4, r1, lsl #1]
}
 8000da0:	b003      	add	sp, #12
 8000da2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000da6:	4770      	bx	lr
            return 0x100u;
 8000da8:	f44f 7080 	mov.w	r0, #256	@ 0x100
            scd->byteToSend = 0;
 8000dac:	f8a3 104a 	strh.w	r1, [r3, #74]	@ 0x4a
            scd->structToSend = 0;
 8000db0:	f8a3 104c 	strh.w	r1, [r3, #76]	@ 0x4c
}
 8000db4:	b003      	add	sp, #12
 8000db6:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000dba:	4770      	bx	lr
 8000dbc:	2824      	cmp	r0, #36	@ 0x24
 8000dbe:	d008      	beq.n	8000dd2 <SCO_get+0x14a>
 8000dc0:	2832      	cmp	r0, #50	@ 0x32
 8000dc2:	d118      	bne.n	8000df6 <SCO_get+0x16e>
                    scd->tempBuff = (uint32_t)tempCommonPtr;
 8000dc4:	ee07 2a90 	vmov	s15, r2
 8000dc8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8000dcc:	edc3 7a10 	vstr	s15, [r3, #64]	@ 0x40
 8000dd0:	e7cf      	b.n	8000d72 <SCO_get+0xea>
                    scd->tempBuff = *tempPtr;
 8000dd2:	6812      	ldr	r2, [r2, #0]
 8000dd4:	641a      	str	r2, [r3, #64]	@ 0x40
 8000dd6:	e7cc      	b.n	8000d72 <SCO_get+0xea>
                    scd->tempBuff = *tempPtr;
 8000dd8:	8812      	ldrh	r2, [r2, #0]
 8000dda:	ee07 2a90 	vmov	s15, r2
 8000dde:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8000de2:	edc3 7a10 	vstr	s15, [r3, #64]	@ 0x40
 8000de6:	e7c4      	b.n	8000d72 <SCO_get+0xea>
                    scd->tempBuff = *tempPtr;
 8000de8:	edd2 7a00 	vldr	s15, [r2]
 8000dec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8000df0:	edc3 7a10 	vstr	s15, [r3, #64]	@ 0x40
 8000df4:	e7bd      	b.n	8000d72 <SCO_get+0xea>
                    scd->tempBuff = *tempPtr;
 8000df6:	f9b2 2000 	ldrsh.w	r2, [r2]
 8000dfa:	ee07 2a90 	vmov	s15, r2
 8000dfe:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8000e02:	edc3 7a10 	vstr	s15, [r3, #64]	@ 0x40
 8000e06:	e7b4      	b.n	8000d72 <SCO_get+0xea>

08000e08 <SCO_VAR>:

#if SCD_IF_USE_RAM_FUNCS
#pragma CODE_SECTION(SCO_VAR, MEM_MACRO);
#endif
static uint16_t SCO_VAR(struct SCD_CTRL_STRUCT *scd)
{
 8000e08:	b570      	push	{r4, r5, r6, lr}
 8000e0a:	4d61      	ldr	r5, [pc, #388]	@ (8000f90 <SCO_VAR+0x188>)
        {
            scd->byteToSend2 = 0;
            scd->structToSend2++;
            // 起始位发送完成，递归找下一数据
            // 将checkSum设为初值
            checkUint16Sum = 0;
 8000e0c:	2400      	movs	r4, #0
{
 8000e0e:	4603      	mov	r3, r0
 8000e10:	8829      	ldrh	r1, [r5, #0]
                return (*tempPtr) & 0xffu;
            }
        }
        else
        {
            scd->byteToSend2 = 0;
 8000e12:	46a4      	mov	ip, r4
    if (scd->structToSend2 == 0)
 8000e14:	f8b3 2054 	ldrh.w	r2, [r3, #84]	@ 0x54
            scd->structToSend2++;
            // 数据位发送完成，递归找下一数据
            // 将checkSum放到结尾包里
            scd->_endbyte1[0] = checkUint16Sum & 0xffu;
 8000e18:	b2ce      	uxtb	r6, r1
            scd->_endbyte1[1] = (checkUint16Sum >> 8) & 0xffu;
 8000e1a:	ea4f 2e11 	mov.w	lr, r1, lsr #8
    if (scd->structToSend2 == 0)
 8000e1e:	b210      	sxth	r0, r2
 8000e20:	b970      	cbnz	r0, 8000e40 <SCO_VAR+0x38>
        if (scd->byteToSend2 < SCO_STARTBYTE_NUM1)
 8000e22:	f8b3 6052 	ldrh.w	r6, [r3, #82]	@ 0x52
 8000e26:	0436      	lsls	r6, r6, #16
 8000e28:	d425      	bmi.n	8000e76 <SCO_VAR+0x6e>
            scd->byteToSend2 = 0;
 8000e2a:	f8a3 2052 	strh.w	r2, [r3, #82]	@ 0x52
            return SCO_VAR(scd);
 8000e2e:	2401      	movs	r4, #1
            scd->structToSend2++;
 8000e30:	f8b3 2054 	ldrh.w	r2, [r3, #84]	@ 0x54
            checkUint16Sum = 0;
 8000e34:	4601      	mov	r1, r0
            scd->structToSend2++;
 8000e36:	4422      	add	r2, r4
 8000e38:	b212      	sxth	r2, r2
 8000e3a:	f8a3 2054 	strh.w	r2, [r3, #84]	@ 0x54
            return SCO_VAR(scd);
 8000e3e:	e7e9      	b.n	8000e14 <SCO_VAR+0xc>
    else if (scd->structToSend2 > scd->structNum)
 8000e40:	f8b3 0054 	ldrh.w	r0, [r3, #84]	@ 0x54
 8000e44:	f8b3 2044 	ldrh.w	r2, [r3, #68]	@ 0x44
 8000e48:	b200      	sxth	r0, r0
 8000e4a:	b212      	sxth	r2, r2
 8000e4c:	4290      	cmp	r0, r2
 8000e4e:	dc1c      	bgt.n	8000e8a <SCO_VAR+0x82>
        if (scd->byteToSend2 < (4))
 8000e50:	f8b3 2052 	ldrh.w	r2, [r3, #82]	@ 0x52
 8000e54:	b212      	sxth	r2, r2
 8000e56:	2a03      	cmp	r2, #3
 8000e58:	dd29      	ble.n	8000eae <SCO_VAR+0xa6>
            scd->byteToSend2 = 0;
 8000e5a:	f8a3 c052 	strh.w	ip, [r3, #82]	@ 0x52
            scd->structToSend2++;
 8000e5e:	f8b3 2054 	ldrh.w	r2, [r3, #84]	@ 0x54
            scd->_endbyte1[0] = checkUint16Sum & 0xffu;
 8000e62:	6b18      	ldr	r0, [r3, #48]	@ 0x30
            scd->structToSend2++;
 8000e64:	3201      	adds	r2, #1
 8000e66:	b212      	sxth	r2, r2
 8000e68:	f8a3 2054 	strh.w	r2, [r3, #84]	@ 0x54
            scd->_endbyte1[0] = checkUint16Sum & 0xffu;
 8000e6c:	7006      	strb	r6, [r0, #0]
            scd->_endbyte1[1] = (checkUint16Sum >> 8) & 0xffu;
 8000e6e:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8000e70:	f882 e001 	strb.w	lr, [r2, #1]
            return SCO_VAR(scd);
 8000e74:	e7ce      	b.n	8000e14 <SCO_VAR+0xc>
 8000e76:	b104      	cbz	r4, 8000e7a <SCO_VAR+0x72>
 8000e78:	8029      	strh	r1, [r5, #0]
            return startByte[scd->byteToSend2++];
 8000e7a:	f8b3 2052 	ldrh.w	r2, [r3, #82]	@ 0x52
 8000e7e:	2000      	movs	r0, #0
 8000e80:	3201      	adds	r2, #1
 8000e82:	b212      	sxth	r2, r2
 8000e84:	f8a3 2052 	strh.w	r2, [r3, #82]	@ 0x52
        }
    }
}
 8000e88:	bd70      	pop	{r4, r5, r6, pc}
 8000e8a:	b104      	cbz	r4, 8000e8e <SCO_VAR+0x86>
 8000e8c:	8029      	strh	r1, [r5, #0]
        if (scd->byteToSend2 < SCO_ENDBYTE_NUM1)
 8000e8e:	f8b3 2052 	ldrh.w	r2, [r3, #82]	@ 0x52
 8000e92:	b212      	sxth	r2, r2
 8000e94:	2a03      	cmp	r2, #3
 8000e96:	dc45      	bgt.n	8000f24 <SCO_VAR+0x11c>
            return scd->_endbyte1[scd->byteToSend2++];
 8000e98:	f8b3 2052 	ldrh.w	r2, [r3, #82]	@ 0x52
 8000e9c:	6b18      	ldr	r0, [r3, #48]	@ 0x30
 8000e9e:	1c51      	adds	r1, r2, #1
 8000ea0:	b212      	sxth	r2, r2
 8000ea2:	b209      	sxth	r1, r1
 8000ea4:	f8a3 1052 	strh.w	r1, [r3, #82]	@ 0x52
 8000ea8:	5c80      	ldrb	r0, [r0, r2]
 8000eaa:	b2c0      	uxtb	r0, r0
}
 8000eac:	bd70      	pop	{r4, r5, r6, pc}
 8000eae:	b104      	cbz	r4, 8000eb2 <SCO_VAR+0xaa>
 8000eb0:	8029      	strh	r1, [r5, #0]
            if (scd->byteToSend2 == 0)
 8000eb2:	f8b3 2052 	ldrh.w	r2, [r3, #82]	@ 0x52
 8000eb6:	b212      	sxth	r2, r2
 8000eb8:	b9e2      	cbnz	r2, 8000ef4 <SCO_VAR+0xec>
                uint16_t judgeType = (scd->_unit_struct[scd->structToSend2 - 1]._type) & 0xffu;
 8000eba:	f8b3 2054 	ldrh.w	r2, [r3, #84]	@ 0x54
 8000ebe:	f06f 4460 	mvn.w	r4, #3758096384	@ 0xe0000000
 8000ec2:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 8000ec4:	fa04 f282 	sxtah	r2, r4, r2
 8000ec8:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
 8000ecc:	7911      	ldrb	r1, [r2, #4]
                void *tempCommonPtr = (void *)scd->_unit_struct[scd->structToSend2 - 1]._addr;
 8000ece:	f8b3 2054 	ldrh.w	r2, [r3, #84]	@ 0x54
 8000ed2:	2914      	cmp	r1, #20
 8000ed4:	fa04 f282 	sxtah	r2, r4, r2
 8000ed8:	f850 2032 	ldr.w	r2, [r0, r2, lsl #3]
                if (judgeType == TYJ_uint16_t)
 8000edc:	d050      	beq.n	8000f80 <SCO_VAR+0x178>
 8000ede:	dc30      	bgt.n	8000f42 <SCO_VAR+0x13a>
 8000ee0:	2902      	cmp	r1, #2
 8000ee2:	d039      	beq.n	8000f58 <SCO_VAR+0x150>
 8000ee4:	2904      	cmp	r1, #4
 8000ee6:	d142      	bne.n	8000f6e <SCO_VAR+0x166>
                    scd->tempBuff = *tempPtr;
 8000ee8:	edd2 7a00 	vldr	s15, [r2]
 8000eec:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8000ef0:	edc3 7a10 	vstr	s15, [r3, #64]	@ 0x40
            tempPtr = &tempPtr[scd->byteToSend2 >> 1];
 8000ef4:	f8b3 2052 	ldrh.w	r2, [r3, #82]	@ 0x52
            uint16_t *tempPtr = (uint16_t *)(void *)&(scd->tempBuff);
 8000ef8:	f103 0440 	add.w	r4, r3, #64	@ 0x40
            if (scd->byteToSend2++ & 0x1)
 8000efc:	f8b3 0052 	ldrh.w	r0, [r3, #82]	@ 0x52
            tempPtr = &tempPtr[scd->byteToSend2 >> 1];
 8000f00:	f342 014e 	sbfx	r1, r2, #1, #15
            if (scd->byteToSend2++ & 0x1)
 8000f04:	1c42      	adds	r2, r0, #1
 8000f06:	f010 0f01 	tst.w	r0, #1
 8000f0a:	b212      	sxth	r2, r2
 8000f0c:	f8a3 2052 	strh.w	r2, [r3, #82]	@ 0x52
                return ((*tempPtr) >> 8) & 0xffu;
 8000f10:	f834 0011 	ldrh.w	r0, [r4, r1, lsl #1]
            if (scd->byteToSend2++ & 0x1)
 8000f14:	d001      	beq.n	8000f1a <SCO_VAR+0x112>
                return ((*tempPtr) >> 8) & 0xffu;
 8000f16:	0a00      	lsrs	r0, r0, #8
}
 8000f18:	bd70      	pop	{r4, r5, r6, pc}
                checkUint16Sum += *tempPtr;
 8000f1a:	882b      	ldrh	r3, [r5, #0]
 8000f1c:	4403      	add	r3, r0
                return (*tempPtr) & 0xffu;
 8000f1e:	b2c0      	uxtb	r0, r0
                checkUint16Sum += *tempPtr;
 8000f20:	802b      	strh	r3, [r5, #0]
}
 8000f22:	bd70      	pop	{r4, r5, r6, pc}
            scd->byteToSend2 = 0;
 8000f24:	2100      	movs	r1, #0
 8000f26:	f8a3 1052 	strh.w	r1, [r3, #82]	@ 0x52
            scd->structToSend2 = 0;
 8000f2a:	f8a3 1054 	strh.w	r1, [r3, #84]	@ 0x54
            if (scd->sco_protocol_num_next == 1)
 8000f2e:	f8b3 2050 	ldrh.w	r2, [r3, #80]	@ 0x50
 8000f32:	b212      	sxth	r2, r2
 8000f34:	2a01      	cmp	r2, #1
 8000f36:	d101      	bne.n	8000f3c <SCO_VAR+0x134>
                scd->sco_protocol_num_next = 0;
 8000f38:	f8a3 1050 	strh.w	r1, [r3, #80]	@ 0x50
            return 0x100u;
 8000f3c:	f44f 7080 	mov.w	r0, #256	@ 0x100
}
 8000f40:	bd70      	pop	{r4, r5, r6, pc}
 8000f42:	2924      	cmp	r1, #36	@ 0x24
 8000f44:	d010      	beq.n	8000f68 <SCO_VAR+0x160>
 8000f46:	2932      	cmp	r1, #50	@ 0x32
 8000f48:	d111      	bne.n	8000f6e <SCO_VAR+0x166>
                    scd->tempBuff = (uint32_t)tempCommonPtr;
 8000f4a:	ee07 2a90 	vmov	s15, r2
 8000f4e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8000f52:	edc3 7a10 	vstr	s15, [r3, #64]	@ 0x40
 8000f56:	e7cd      	b.n	8000ef4 <SCO_VAR+0xec>
                    scd->tempBuff = *tempPtr;
 8000f58:	8812      	ldrh	r2, [r2, #0]
 8000f5a:	ee07 2a90 	vmov	s15, r2
 8000f5e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8000f62:	edc3 7a10 	vstr	s15, [r3, #64]	@ 0x40
 8000f66:	e7c5      	b.n	8000ef4 <SCO_VAR+0xec>
                    scd->tempBuff = *tempPtr;
 8000f68:	6812      	ldr	r2, [r2, #0]
 8000f6a:	641a      	str	r2, [r3, #64]	@ 0x40
 8000f6c:	e7c2      	b.n	8000ef4 <SCO_VAR+0xec>
                    scd->tempBuff = *tempPtr;
 8000f6e:	f9b2 2000 	ldrsh.w	r2, [r2]
 8000f72:	ee07 2a90 	vmov	s15, r2
 8000f76:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8000f7a:	edc3 7a10 	vstr	s15, [r3, #64]	@ 0x40
 8000f7e:	e7b9      	b.n	8000ef4 <SCO_VAR+0xec>
                    scd->tempBuff = *tempPtr;
 8000f80:	edd2 7a00 	vldr	s15, [r2]
 8000f84:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8000f88:	edc3 7a10 	vstr	s15, [r3, #64]	@ 0x40
 8000f8c:	e7b2      	b.n	8000ef4 <SCO_VAR+0xec>
 8000f8e:	bf00      	nop
 8000f90:	2400026c 	.word	0x2400026c

08000f94 <SCO_DEBUG>:
{
    // debug用，只会发0
    (void)scd;

    // 若模式没改就发0
    if (scd->sco_protocol_num_next == 2)
 8000f94:	f8b0 0050 	ldrh.w	r0, [r0, #80]	@ 0x50
 8000f98:	b200      	sxth	r0, r0
 8000f9a:	3802      	subs	r0, #2
 8000f9c:	bf18      	it	ne
 8000f9e:	2001      	movne	r0, #1
    {
        return 0;
    }
    // 否则发送0x100，切换协议
    return 0x100u;
}
 8000fa0:	0200      	lsls	r0, r0, #8
 8000fa2:	4770      	bx	lr

08000fa4 <SCO_DUMP>:
{
#define SCO_ENDBYTE_NUM2 8

    static uint16_t checkUint16Sum = 0;

    if (scd->structToSend3 >= scd->dumpNumCnt)
 8000fa4:	f8b0 2058 	ldrh.w	r2, [r0, #88]	@ 0x58
 8000fa8:	f8b0 305c 	ldrh.w	r3, [r0, #92]	@ 0x5c
 8000fac:	b212      	sxth	r2, r2
 8000fae:	b21b      	sxth	r3, r3
 8000fb0:	429a      	cmp	r2, r3
{
 8000fb2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (scd->structToSend3 >= scd->dumpNumCnt)
 8000fb6:	f280 8084 	bge.w	80010c2 <SCO_DUMP+0x11e>
 8000fba:	4d91      	ldr	r5, [pc, #580]	@ (8001200 <SCO_DUMP+0x25c>)
 8000fbc:	2400      	movs	r4, #0
            }
            // 正常结束，发送0x100;
            return 0x100u;
        }
    }
    else if (scd->dumpPkgCnt > MAX_NUMS_PER_FRAME)
 8000fbe:	f240 32e9 	movw	r2, #1001	@ 0x3e9
        else
        {
            scd->byteToSend3 = 0;
            checkUint16Sum = 0;
            // 设定包计数值为初值，这里考虑上结尾包
            scd->dumpPkgCnt = 2;
 8000fc2:	f04f 0e02 	mov.w	lr, #2
 8000fc6:	882b      	ldrh	r3, [r5, #0]
                return (*tempPtr) & 0xffu;
            }
        }
        else
        {
            scd->byteToSend3 = 0;
 8000fc8:	4621      	mov	r1, r4
            scd->ifContPkg = 1;
 8000fca:	f04f 0c01 	mov.w	ip, #1
                scd->_endbyte2[1] = 0xccu;
 8000fce:	f04f 09cc 	mov.w	r9, #204	@ 0xcc
                scd->_endbyte2[2] = 0x8cu;
 8000fd2:	f04f 0a8c 	mov.w	sl, #140	@ 0x8c
 8000fd6:	e02f      	b.n	8001038 <SCO_DUMP+0x94>
        if (scd->byteToSend3 == 0)
 8000fd8:	f8b0 7056 	ldrh.w	r7, [r0, #86]	@ 0x56
 8000fdc:	b23f      	sxth	r7, r7
 8000fde:	b9af      	cbnz	r7, 800100c <SCO_DUMP+0x68>
            if (scd->ifContPkg)
 8000fe0:	f8b0 7060 	ldrh.w	r7, [r0, #96]	@ 0x60
                scd->_endbyte2[3] = 0x3fu;
 8000fe4:	f04f 083f 	mov.w	r8, #63	@ 0x3f
                scd->_endbyte2[0] = 0xcdu;
 8000fe8:	f8d0 b034 	ldr.w	fp, [r0, #52]	@ 0x34
            if (scd->ifContPkg)
 8000fec:	b23f      	sxth	r7, r7
 8000fee:	2f00      	cmp	r7, #0
 8000ff0:	d04a      	beq.n	8001088 <SCO_DUMP+0xe4>
                scd->_endbyte2[0] = 0xcdu;
 8000ff2:	f06f 0632 	mvn.w	r6, #50	@ 0x32
 8000ff6:	f88b 6000 	strb.w	r6, [fp]
                scd->_endbyte2[1] = 0xccu;
 8000ffa:	6b46      	ldr	r6, [r0, #52]	@ 0x34
 8000ffc:	f886 9001 	strb.w	r9, [r6, #1]
                scd->_endbyte2[2] = 0x8cu;
 8001000:	6b46      	ldr	r6, [r0, #52]	@ 0x34
 8001002:	f886 a002 	strb.w	sl, [r6, #2]
                scd->_endbyte2[3] = 0x3fu;
 8001006:	6b46      	ldr	r6, [r0, #52]	@ 0x34
 8001008:	f886 8003 	strb.w	r8, [r6, #3]
        if (scd->byteToSend3 < SCO_ENDBYTE_NUM2)
 800100c:	f8b0 7056 	ldrh.w	r7, [r0, #86]	@ 0x56
 8001010:	b23f      	sxth	r7, r7
 8001012:	2f07      	cmp	r7, #7
 8001014:	dd45      	ble.n	80010a2 <SCO_DUMP+0xfe>
            return SCO_DUMP(scd);
 8001016:	2401      	movs	r4, #1
            checkUint16Sum = 0;
 8001018:	2300      	movs	r3, #0
            scd->byteToSend3 = 0;
 800101a:	f8a0 1056 	strh.w	r1, [r0, #86]	@ 0x56
            scd->dumpPkgCnt = 2;
 800101e:	f8a0 e05e 	strh.w	lr, [r0, #94]	@ 0x5e
            scd->ifContPkg = 1;
 8001022:	f8a0 c060 	strh.w	ip, [r0, #96]	@ 0x60
    if (scd->structToSend3 >= scd->dumpNumCnt)
 8001026:	f8b0 8058 	ldrh.w	r8, [r0, #88]	@ 0x58
 800102a:	f8b0 705c 	ldrh.w	r7, [r0, #92]	@ 0x5c
 800102e:	fa0f f888 	sxth.w	r8, r8
 8001032:	b23f      	sxth	r7, r7
 8001034:	45b8      	cmp	r8, r7
 8001036:	da42      	bge.n	80010be <SCO_DUMP+0x11a>
    else if (scd->dumpPkgCnt > MAX_NUMS_PER_FRAME)
 8001038:	f8b0 b05e 	ldrh.w	fp, [r0, #94]	@ 0x5e
            scd->structToSend3++;
            scd->dumpPkgCnt++;
            // 数据位发送完成，递归找下一数据
            // 将checkSum放到结尾包里
            scd->_endbyte2[4] = checkUint16Sum & 0xffu;
 800103c:	fa5f f883 	uxtb.w	r8, r3
            scd->_endbyte2[5] = (checkUint16Sum >> 8) & 0xffu;
 8001040:	0a1f      	lsrs	r7, r3, #8
    else if (scd->dumpPkgCnt > MAX_NUMS_PER_FRAME)
 8001042:	fa0f fb8b 	sxth.w	fp, fp
 8001046:	4593      	cmp	fp, r2
 8001048:	dcc6      	bgt.n	8000fd8 <SCO_DUMP+0x34>
        if (scd->byteToSend3 < (4))
 800104a:	f8b0 b056 	ldrh.w	fp, [r0, #86]	@ 0x56
 800104e:	fa0f fb8b 	sxth.w	fp, fp
 8001052:	f1bb 0f03 	cmp.w	fp, #3
 8001056:	dd5f      	ble.n	8001118 <SCO_DUMP+0x174>
            scd->byteToSend3 = 0;
 8001058:	f8a0 1056 	strh.w	r1, [r0, #86]	@ 0x56
            scd->structToSend3++;
 800105c:	f8b0 b058 	ldrh.w	fp, [r0, #88]	@ 0x58
            scd->_endbyte2[4] = checkUint16Sum & 0xffu;
 8001060:	6b46      	ldr	r6, [r0, #52]	@ 0x34
            scd->structToSend3++;
 8001062:	f10b 0b01 	add.w	fp, fp, #1
 8001066:	fa0f fb8b 	sxth.w	fp, fp
 800106a:	f8a0 b058 	strh.w	fp, [r0, #88]	@ 0x58
            scd->dumpPkgCnt++;
 800106e:	f8b0 b05e 	ldrh.w	fp, [r0, #94]	@ 0x5e
 8001072:	f10b 0b01 	add.w	fp, fp, #1
 8001076:	fa0f fb8b 	sxth.w	fp, fp
 800107a:	f8a0 b05e 	strh.w	fp, [r0, #94]	@ 0x5e
            scd->_endbyte2[4] = checkUint16Sum & 0xffu;
 800107e:	f886 8004 	strb.w	r8, [r6, #4]
            scd->_endbyte2[5] = (checkUint16Sum >> 8) & 0xffu;
 8001082:	6b46      	ldr	r6, [r0, #52]	@ 0x34
 8001084:	7177      	strb	r7, [r6, #5]
            return SCO_DUMP(scd);
 8001086:	e7ce      	b.n	8001026 <SCO_DUMP+0x82>
                scd->_endbyte2[0] = 0;
 8001088:	f88b 7000 	strb.w	r7, [fp]
                scd->_endbyte2[1] = 0;
 800108c:	6b46      	ldr	r6, [r0, #52]	@ 0x34
 800108e:	7077      	strb	r7, [r6, #1]
                scd->_endbyte2[2] = 0;
 8001090:	6b46      	ldr	r6, [r0, #52]	@ 0x34
 8001092:	70b7      	strb	r7, [r6, #2]
                scd->_endbyte2[3] = 0;
 8001094:	6b46      	ldr	r6, [r0, #52]	@ 0x34
 8001096:	70f7      	strb	r7, [r6, #3]
        if (scd->byteToSend3 < SCO_ENDBYTE_NUM2)
 8001098:	f8b0 7056 	ldrh.w	r7, [r0, #86]	@ 0x56
 800109c:	b23f      	sxth	r7, r7
 800109e:	2f07      	cmp	r7, #7
 80010a0:	dcb9      	bgt.n	8001016 <SCO_DUMP+0x72>
 80010a2:	b104      	cbz	r4, 80010a6 <SCO_DUMP+0x102>
 80010a4:	802b      	strh	r3, [r5, #0]
            return scd->_endbyte2[scd->byteToSend3++];
 80010a6:	f8b0 3056 	ldrh.w	r3, [r0, #86]	@ 0x56
 80010aa:	6b41      	ldr	r1, [r0, #52]	@ 0x34
 80010ac:	1c5a      	adds	r2, r3, #1
 80010ae:	b21b      	sxth	r3, r3
 80010b0:	b212      	sxth	r2, r2
 80010b2:	f8a0 2056 	strh.w	r2, [r0, #86]	@ 0x56
 80010b6:	5cc8      	ldrb	r0, [r1, r3]
 80010b8:	b2c0      	uxtb	r0, r0
        }
    }
}
 80010ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80010be:	b104      	cbz	r4, 80010c2 <SCO_DUMP+0x11e>
 80010c0:	802b      	strh	r3, [r5, #0]
        if (scd->byteToSend3 == 0)
 80010c2:	f8b0 3056 	ldrh.w	r3, [r0, #86]	@ 0x56
 80010c6:	b21b      	sxth	r3, r3
 80010c8:	b95b      	cbnz	r3, 80010e2 <SCO_DUMP+0x13e>
            scd->_endbyte2[0] = 0xcdu;
 80010ca:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 80010cc:	24cd      	movs	r4, #205	@ 0xcd
            scd->_endbyte2[1] = 0xccu;
 80010ce:	22cc      	movs	r2, #204	@ 0xcc
            scd->_endbyte2[2] = 0xcu;
 80010d0:	210c      	movs	r1, #12
            scd->_endbyte2[0] = 0xcdu;
 80010d2:	701c      	strb	r4, [r3, #0]
            scd->_endbyte2[1] = 0xccu;
 80010d4:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 80010d6:	705a      	strb	r2, [r3, #1]
            scd->_endbyte2[3] = 0x40u;
 80010d8:	2240      	movs	r2, #64	@ 0x40
            scd->_endbyte2[2] = 0xcu;
 80010da:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 80010dc:	7099      	strb	r1, [r3, #2]
            scd->_endbyte2[3] = 0x40u;
 80010de:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 80010e0:	70da      	strb	r2, [r3, #3]
        if (scd->byteToSend3 < SCO_ENDBYTE_NUM2)
 80010e2:	f8b0 3056 	ldrh.w	r3, [r0, #86]	@ 0x56
 80010e6:	b21b      	sxth	r3, r3
 80010e8:	2b07      	cmp	r3, #7
 80010ea:	dddc      	ble.n	80010a6 <SCO_DUMP+0x102>
            scd->byteToSend3 = 0;
 80010ec:	2300      	movs	r3, #0
            scd->dumpPkgCnt = 2;
 80010ee:	2202      	movs	r2, #2
            checkUint16Sum = 0;
 80010f0:	4943      	ldr	r1, [pc, #268]	@ (8001200 <SCO_DUMP+0x25c>)
            scd->byteToSend3 = 0;
 80010f2:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56
            scd->structToSend3 = 0;
 80010f6:	f8a0 3058 	strh.w	r3, [r0, #88]	@ 0x58
            scd->dumpPkgCnt = 2;
 80010fa:	f8a0 205e 	strh.w	r2, [r0, #94]	@ 0x5e
            scd->ifContPkg = 0;
 80010fe:	f8a0 3060 	strh.w	r3, [r0, #96]	@ 0x60
            if (scd->sco_protocol_num_next == 3)
 8001102:	f8b0 2050 	ldrh.w	r2, [r0, #80]	@ 0x50
            checkUint16Sum = 0;
 8001106:	800b      	strh	r3, [r1, #0]
            if (scd->sco_protocol_num_next == 3)
 8001108:	b212      	sxth	r2, r2
 800110a:	2a03      	cmp	r2, #3
 800110c:	d101      	bne.n	8001112 <SCO_DUMP+0x16e>
                scd->sco_protocol_num_next = 0;
 800110e:	f8a0 3050 	strh.w	r3, [r0, #80]	@ 0x50
            return 0x100u;
 8001112:	f44f 7080 	mov.w	r0, #256	@ 0x100
 8001116:	e7d0      	b.n	80010ba <SCO_DUMP+0x116>
 8001118:	b104      	cbz	r4, 800111c <SCO_DUMP+0x178>
 800111a:	802b      	strh	r3, [r5, #0]
            if (scd->byteToSend3 == 0)
 800111c:	f8b0 3056 	ldrh.w	r3, [r0, #86]	@ 0x56
 8001120:	b21b      	sxth	r3, r3
 8001122:	b9eb      	cbnz	r3, 8001160 <SCO_DUMP+0x1bc>
                uint16_t judgeType = (scd->_unit_struct[scd->dumpTarget]._type) & 0xffu;
 8001124:	f8b0 305a 	ldrh.w	r3, [r0, #90]	@ 0x5a
 8001128:	6bc1      	ldr	r1, [r0, #60]	@ 0x3c
 800112a:	b21b      	sxth	r3, r3
                void *tempCommonPtr = (void *)scd->_unit_struct[scd->dumpTarget]._addr;
 800112c:	f8b0 205a 	ldrh.w	r2, [r0, #90]	@ 0x5a
                uint16_t judgeType = (scd->_unit_struct[scd->dumpTarget]._type) & 0xffu;
 8001130:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
                void *tempCommonPtr = (void *)scd->_unit_struct[scd->dumpTarget]._addr;
 8001134:	b212      	sxth	r2, r2
 8001136:	791b      	ldrb	r3, [r3, #4]
 8001138:	f851 2032 	ldr.w	r2, [r1, r2, lsl #3]
                if (judgeType == TYJ_uint16_t)
 800113c:	2b14      	cmp	r3, #20
 800113e:	d047      	beq.n	80011d0 <SCO_DUMP+0x22c>
 8001140:	dc27      	bgt.n	8001192 <SCO_DUMP+0x1ee>
 8001142:	2b02      	cmp	r3, #2
 8001144:	d038      	beq.n	80011b8 <SCO_DUMP+0x214>
 8001146:	2b04      	cmp	r3, #4
 8001148:	d14e      	bne.n	80011e8 <SCO_DUMP+0x244>
                    scd->tempBuff = tempPtr[scd->structToSend3];
 800114a:	f8b0 3058 	ldrh.w	r3, [r0, #88]	@ 0x58
 800114e:	b21b      	sxth	r3, r3
 8001150:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8001154:	edd3 7a00 	vldr	s15, [r3]
 8001158:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800115c:	edc0 7a10 	vstr	s15, [r0, #64]	@ 0x40
            tempPtr = &tempPtr[scd->byteToSend3 >> 1];
 8001160:	f8b0 3056 	ldrh.w	r3, [r0, #86]	@ 0x56
            uint16_t *tempPtr = (uint16_t *)(void *)&(scd->tempBuff);
 8001164:	f100 0440 	add.w	r4, r0, #64	@ 0x40
            if (scd->byteToSend3++ & 0x1)
 8001168:	f8b0 1056 	ldrh.w	r1, [r0, #86]	@ 0x56
            tempPtr = &tempPtr[scd->byteToSend3 >> 1];
 800116c:	f343 024e 	sbfx	r2, r3, #1, #15
            if (scd->byteToSend3++ & 0x1)
 8001170:	1c4b      	adds	r3, r1, #1
 8001172:	b21b      	sxth	r3, r3
 8001174:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56
 8001178:	07cb      	lsls	r3, r1, #31
                return ((*tempPtr) >> 8) & 0xffu;
 800117a:	f834 0012 	ldrh.w	r0, [r4, r2, lsl #1]
            if (scd->byteToSend3++ & 0x1)
 800117e:	d502      	bpl.n	8001186 <SCO_DUMP+0x1e2>
                return ((*tempPtr) >> 8) & 0xffu;
 8001180:	0a00      	lsrs	r0, r0, #8
}
 8001182:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                checkUint16Sum += *tempPtr;
 8001186:	882b      	ldrh	r3, [r5, #0]
 8001188:	4403      	add	r3, r0
                return (*tempPtr) & 0xffu;
 800118a:	b2c0      	uxtb	r0, r0
                checkUint16Sum += *tempPtr;
 800118c:	802b      	strh	r3, [r5, #0]
}
 800118e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001192:	2b24      	cmp	r3, #36	@ 0x24
 8001194:	d008      	beq.n	80011a8 <SCO_DUMP+0x204>
 8001196:	2b32      	cmp	r3, #50	@ 0x32
 8001198:	d126      	bne.n	80011e8 <SCO_DUMP+0x244>
                    scd->tempBuff = (uint32_t)tempCommonPtr;
 800119a:	ee07 2a90 	vmov	s15, r2
 800119e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80011a2:	edc0 7a10 	vstr	s15, [r0, #64]	@ 0x40
 80011a6:	e7db      	b.n	8001160 <SCO_DUMP+0x1bc>
                    scd->tempBuff = tempPtr[scd->structToSend3];
 80011a8:	f8b0 3058 	ldrh.w	r3, [r0, #88]	@ 0x58
 80011ac:	b21b      	sxth	r3, r3
 80011ae:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80011b2:	681b      	ldr	r3, [r3, #0]
 80011b4:	6403      	str	r3, [r0, #64]	@ 0x40
 80011b6:	e7d3      	b.n	8001160 <SCO_DUMP+0x1bc>
                    scd->tempBuff = tempPtr[scd->structToSend3];
 80011b8:	f8b0 3058 	ldrh.w	r3, [r0, #88]	@ 0x58
 80011bc:	b21b      	sxth	r3, r3
 80011be:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80011c2:	ee07 3a90 	vmov	s15, r3
 80011c6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80011ca:	edc0 7a10 	vstr	s15, [r0, #64]	@ 0x40
 80011ce:	e7c7      	b.n	8001160 <SCO_DUMP+0x1bc>
                    scd->tempBuff = tempPtr[scd->structToSend3];
 80011d0:	f8b0 3058 	ldrh.w	r3, [r0, #88]	@ 0x58
 80011d4:	b21b      	sxth	r3, r3
 80011d6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80011da:	edd3 7a00 	vldr	s15, [r3]
 80011de:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80011e2:	edc0 7a10 	vstr	s15, [r0, #64]	@ 0x40
 80011e6:	e7bb      	b.n	8001160 <SCO_DUMP+0x1bc>
                    scd->tempBuff = tempPtr[scd->structToSend3];
 80011e8:	f8b0 3058 	ldrh.w	r3, [r0, #88]	@ 0x58
 80011ec:	b21b      	sxth	r3, r3
 80011ee:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
 80011f2:	ee07 3a90 	vmov	s15, r3
 80011f6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80011fa:	edc0 7a10 	vstr	s15, [r0, #64]	@ 0x40
 80011fe:	e7af      	b.n	8001160 <SCO_DUMP+0x1bc>
 8001200:	2400026e 	.word	0x2400026e

08001204 <SCO_PRINT>:
static uint16_t SCO_PRINT(struct SCD_CTRL_STRUCT *scd)
{
#define SCO_ENDBYTE_NUM3 2

    // 用判断代替求余
    if (scd->byteToSend4 == 4)
 8001204:	f8b0 2066 	ldrh.w	r2, [r0, #102]	@ 0x66
{
 8001208:	4603      	mov	r3, r0
    if (scd->byteToSend4 == 4)
 800120a:	b212      	sxth	r2, r2
 800120c:	2a04      	cmp	r2, #4
 800120e:	d102      	bne.n	8001216 <SCO_PRINT+0x12>
    {
        scd->byteToSend4 = 0;
 8001210:	2200      	movs	r2, #0
 8001212:	f8a0 2066 	strh.w	r2, [r0, #102]	@ 0x66
    }
    if (scd->byteToSend4 == 0)
 8001216:	f8b3 2066 	ldrh.w	r2, [r3, #102]	@ 0x66
 800121a:	b211      	sxth	r1, r2
 800121c:	bb41      	cbnz	r1, 8001270 <SCO_PRINT+0x6c>
    {
        // 规划帧
        if (scd->byteToPrint < scd->isPrintBusyFlg)
 800121e:	f8b3 c064 	ldrh.w	ip, [r3, #100]	@ 0x64
 8001222:	f8b3 0062 	ldrh.w	r0, [r3, #98]	@ 0x62
 8001226:	fa0f fc8c 	sxth.w	ip, ip
 800122a:	b200      	sxth	r0, r0
 800122c:	4584      	cmp	ip, r0
 800122e:	da2a      	bge.n	8001286 <SCO_PRINT+0x82>
        {
            scd->_endbyte3[0] = scd->_printBuff[scd->byteToPrint++];
 8001230:	f8b3 2064 	ldrh.w	r2, [r3, #100]	@ 0x64
 8001234:	b210      	sxth	r0, r2
 8001236:	3201      	adds	r2, #1
 8001238:	b212      	sxth	r2, r2
 800123a:	f8a3 2064 	strh.w	r2, [r3, #100]	@ 0x64
 800123e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8001240:	5c12      	ldrb	r2, [r2, r0]
 8001242:	6b98      	ldr	r0, [r3, #56]	@ 0x38
 8001244:	b2d2      	uxtb	r2, r2
 8001246:	7002      	strb	r2, [r0, #0]
            // 发完了
            scd->byteToPrint = 0;
            scd->isPrintBusyFlg = 0;
            return 0x100u;
        }
        if (scd->byteToPrint < scd->isPrintBusyFlg)
 8001248:	f8b3 0064 	ldrh.w	r0, [r3, #100]	@ 0x64
 800124c:	f8b3 2062 	ldrh.w	r2, [r3, #98]	@ 0x62
 8001250:	b200      	sxth	r0, r0
 8001252:	b212      	sxth	r2, r2
 8001254:	4290      	cmp	r0, r2
 8001256:	da1d      	bge.n	8001294 <SCO_PRINT+0x90>
        {
            scd->_endbyte3[1] = scd->_printBuff[scd->byteToPrint++];
 8001258:	f8b3 2064 	ldrh.w	r2, [r3, #100]	@ 0x64
 800125c:	6b98      	ldr	r0, [r3, #56]	@ 0x38
 800125e:	1c51      	adds	r1, r2, #1
 8001260:	b212      	sxth	r2, r2
 8001262:	b209      	sxth	r1, r1
 8001264:	f8a3 1064 	strh.w	r1, [r3, #100]	@ 0x64
 8001268:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 800126a:	5c8a      	ldrb	r2, [r1, r2]
 800126c:	b2d2      	uxtb	r2, r2
 800126e:	7042      	strb	r2, [r0, #1]
            // 第二字节，没东西但还是要发一帧
            scd->_endbyte3[1] = 0;
        }
        return scd->_endbyte3[scd->byteToSend4++];
    }
    return scd->_endbyte3[scd->byteToSend4++];
 8001270:	f8b3 2066 	ldrh.w	r2, [r3, #102]	@ 0x66
 8001274:	6b98      	ldr	r0, [r3, #56]	@ 0x38
 8001276:	1c51      	adds	r1, r2, #1
 8001278:	b212      	sxth	r2, r2
 800127a:	b209      	sxth	r1, r1
 800127c:	f8a3 1066 	strh.w	r1, [r3, #102]	@ 0x66
 8001280:	5c80      	ldrb	r0, [r0, r2]
 8001282:	b2c0      	uxtb	r0, r0
}
 8001284:	4770      	bx	lr
            scd->byteToPrint = 0;
 8001286:	f8a3 2064 	strh.w	r2, [r3, #100]	@ 0x64
            return 0x100u;
 800128a:	f44f 7080 	mov.w	r0, #256	@ 0x100
            scd->isPrintBusyFlg = 0;
 800128e:	f8a3 2062 	strh.w	r2, [r3, #98]	@ 0x62
            return 0x100u;
 8001292:	4770      	bx	lr
            scd->_endbyte3[1] = 0;
 8001294:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8001296:	7051      	strb	r1, [r2, #1]
        return scd->_endbyte3[scd->byteToSend4++];
 8001298:	e7ea      	b.n	8001270 <SCO_PRINT+0x6c>
 800129a:	bf00      	nop

0800129c <_cz_strtoxl.constprop.0>:
static uint32_t _cz_strtoxl(const char *nptr, const char **endptr, int ibase, int flags)
 800129c:	4602      	mov	r2, r0
 800129e:	b570      	push	{r4, r5, r6, lr}
    if (endptr != NULL)
 80012a0:	b101      	cbz	r1, 80012a4 <_cz_strtoxl.constprop.0+0x8>
        *endptr = nptr;
 80012a2:	6008      	str	r0, [r1, #0]
    while (cz_isspace((int)(unsigned char)c))
 80012a4:	4e38      	ldr	r6, [pc, #224]	@ (8001388 <_cz_strtoxl.constprop.0+0xec>)
    c = *p++;
 80012a6:	f812 3b01 	ldrb.w	r3, [r2], #1
    while (cz_isspace((int)(unsigned char)c))
 80012aa:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 80012ae:	0700      	lsls	r0, r0, #28
 80012b0:	d4f9      	bmi.n	80012a6 <_cz_strtoxl.constprop.0+0xa>
    if (c == '+')
 80012b2:	2b2b      	cmp	r3, #43	@ 0x2b
 80012b4:	d03b      	beq.n	800132e <_cz_strtoxl.constprop.0+0x92>
    if (c == '-')
 80012b6:	2b2d      	cmp	r3, #45	@ 0x2d
 80012b8:	d023      	beq.n	8001302 <_cz_strtoxl.constprop.0+0x66>
 80012ba:	f04f 0e00 	mov.w	lr, #0
 80012be:	2000      	movs	r0, #0
        if (number < maxval || (number == maxval &&
 80012c0:	4d32      	ldr	r5, [pc, #200]	@ (800138c <_cz_strtoxl.constprop.0+0xf0>)
 80012c2:	e004      	b.n	80012ce <_cz_strtoxl.constprop.0+0x32>
            number = number * ((uint32_t)ibase) + digval;
 80012c4:	eb03 004c 	add.w	r0, r3, ip, lsl #1
        flags |= IFL_READDIGIT;
 80012c8:	46a6      	mov	lr, r4
        c = *p++;
 80012ca:	f812 3b01 	ldrb.w	r3, [r2], #1
        if (cz_isdigit((int)(unsigned char)c))
 80012ce:	f856 4023 	ldr.w	r4, [r6, r3, lsl #2]
            digval = c - '0';
 80012d2:	3b30      	subs	r3, #48	@ 0x30
        if (cz_isdigit((int)(unsigned char)c))
 80012d4:	f014 0f04 	tst.w	r4, #4
            digval = (char)cz_toupper((unsigned char)c) - 'A' + 10;
 80012d8:	f3c4 2c07 	ubfx	ip, r4, #8, #8
        if (cz_isdigit((int)(unsigned char)c))
 80012dc:	d104      	bne.n	80012e8 <_cz_strtoxl.constprop.0+0x4c>
        else if (cz_isalpha((int)(unsigned char)c))
 80012de:	f014 0f03 	tst.w	r4, #3
            digval = (char)cz_toupper((unsigned char)c) - 'A' + 10;
 80012e2:	f1ac 0337 	sub.w	r3, ip, #55	@ 0x37
        else if (cz_isalpha((int)(unsigned char)c))
 80012e6:	d015      	beq.n	8001314 <_cz_strtoxl.constprop.0+0x78>
        if (digval >= (uint32_t)ibase)
 80012e8:	2b09      	cmp	r3, #9
        flags |= IFL_READDIGIT;
 80012ea:	f04e 0402 	orr.w	r4, lr, #2
            number = number * ((uint32_t)ibase) + digval;
 80012ee:	eb00 0c80 	add.w	ip, r0, r0, lsl #2
        if (digval >= (uint32_t)ibase)
 80012f2:	d80f      	bhi.n	8001314 <_cz_strtoxl.constprop.0+0x78>
        if (number < maxval || (number == maxval &&
 80012f4:	42a8      	cmp	r0, r5
 80012f6:	d9e5      	bls.n	80012c4 <_cz_strtoxl.constprop.0+0x28>
            flags |= IFL_OVERFLOW;
 80012f8:	f04e 0306 	orr.w	r3, lr, #6
            if (endptr == NULL)
 80012fc:	b349      	cbz	r1, 8001352 <_cz_strtoxl.constprop.0+0xb6>
            flags |= IFL_OVERFLOW;
 80012fe:	469e      	mov	lr, r3
 8001300:	e7e3      	b.n	80012ca <_cz_strtoxl.constprop.0+0x2e>
        flags |= IFL_NEG;
 8001302:	f04f 0e01 	mov.w	lr, #1
        c = *p++;
 8001306:	f812 3b01 	ldrb.w	r3, [r2], #1
    if (c == '+')
 800130a:	2b2b      	cmp	r3, #43	@ 0x2b
        c = *p++;
 800130c:	bf08      	it	eq
 800130e:	f812 3b01 	ldrbeq.w	r3, [r2], #1
 8001312:	e7d4      	b.n	80012be <_cz_strtoxl.constprop.0+0x22>
    if (!(flags & IFL_READDIGIT))
 8001314:	f01e 0f02 	tst.w	lr, #2
    --p;
 8001318:	f102 32ff 	add.w	r2, r2, #4294967295
              (((flags & IFL_NEG) && (number > limit)) ||
 800131c:	f00e 0301 	and.w	r3, lr, #1
    if (!(flags & IFL_READDIGIT))
 8001320:	d10c      	bne.n	800133c <_cz_strtoxl.constprop.0+0xa0>
        if (endptr)
 8001322:	b101      	cbz	r1, 8001326 <_cz_strtoxl.constprop.0+0x8a>
        *endptr = p;
 8001324:	600a      	str	r2, [r1, #0]
    if (flags & IFL_NEG)
 8001326:	b193      	cbz	r3, 800134e <_cz_strtoxl.constprop.0+0xb2>
 8001328:	2000      	movs	r0, #0
        number = (uint32_t)(-(int32_t)number);
 800132a:	4240      	negs	r0, r0
}
 800132c:	bd70      	pop	{r4, r5, r6, pc}
        c = *p++;
 800132e:	f812 3b01 	ldrb.w	r3, [r2], #1
    if (c == '-')
 8001332:	2b2d      	cmp	r3, #45	@ 0x2d
 8001334:	d0e5      	beq.n	8001302 <_cz_strtoxl.constprop.0+0x66>
 8001336:	f04f 0e00 	mov.w	lr, #0
 800133a:	e7e6      	b.n	800130a <_cz_strtoxl.constprop.0+0x6e>
    else if ((flags & IFL_OVERFLOW) ||
 800133c:	f01e 0f04 	tst.w	lr, #4
 8001340:	d011      	beq.n	8001366 <_cz_strtoxl.constprop.0+0xca>
        else if (flags & IFL_NEG)
 8001342:	b163      	cbz	r3, 800135e <_cz_strtoxl.constprop.0+0xc2>
    if (endptr)
 8001344:	b101      	cbz	r1, 8001348 <_cz_strtoxl.constprop.0+0xac>
        *endptr = p;
 8001346:	600a      	str	r2, [r1, #0]
            number = (uint32_t)CZ_INT32_MIN;
 8001348:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
 800134c:	e7ed      	b.n	800132a <_cz_strtoxl.constprop.0+0x8e>
 800134e:	4618      	mov	r0, r3
}
 8001350:	bd70      	pop	{r4, r5, r6, pc}
        else if (flags & IFL_NEG)
 8001352:	f01e 0f01 	tst.w	lr, #1
 8001356:	d1f7      	bne.n	8001348 <_cz_strtoxl.constprop.0+0xac>
            number = (uint32_t)CZ_INT32_MAX;
 8001358:	f06f 4000 	mvn.w	r0, #2147483648	@ 0x80000000
}
 800135c:	bd70      	pop	{r4, r5, r6, pc}
    if (endptr)
 800135e:	2900      	cmp	r1, #0
 8001360:	d0fa      	beq.n	8001358 <_cz_strtoxl.constprop.0+0xbc>
        *endptr = p;
 8001362:	600a      	str	r2, [r1, #0]
    if (flags & IFL_NEG)
 8001364:	e7f8      	b.n	8001358 <_cz_strtoxl.constprop.0+0xbc>
             (!(flags & IFL_UNSIGNED) &&
 8001366:	b143      	cbz	r3, 800137a <_cz_strtoxl.constprop.0+0xde>
              (((flags & IFL_NEG) && (number > limit)) ||
 8001368:	f1b0 4f00 	cmp.w	r0, #2147483648	@ 0x80000000
 800136c:	bf28      	it	cs
 800136e:	f04f 4000 	movcs.w	r0, #2147483648	@ 0x80000000
    if (endptr)
 8001372:	2900      	cmp	r1, #0
 8001374:	d0d9      	beq.n	800132a <_cz_strtoxl.constprop.0+0x8e>
        *endptr = p;
 8001376:	600a      	str	r2, [r1, #0]
    if (flags & IFL_NEG)
 8001378:	e7d7      	b.n	800132a <_cz_strtoxl.constprop.0+0x8e>
               (!(flags & IFL_NEG) && (number > limit - 1)))))
 800137a:	2800      	cmp	r0, #0
 800137c:	dbef      	blt.n	800135e <_cz_strtoxl.constprop.0+0xc2>
    if (endptr)
 800137e:	2900      	cmp	r1, #0
 8001380:	d0d4      	beq.n	800132c <_cz_strtoxl.constprop.0+0x90>
        *endptr = p;
 8001382:	600a      	str	r2, [r1, #0]
}
 8001384:	bd70      	pop	{r4, r5, r6, pc}
 8001386:	bf00      	nop
 8001388:	08008310 	.word	0x08008310
 800138c:	19999999 	.word	0x19999999

08001390 <SCD_CMD_CALL>:
{
 8001390:	b570      	push	{r4, r5, r6, lr}
    uint16_t judgeType = (scd->_unit_struct[targetNum]._type) & 0xffu;
 8001392:	6bc5      	ldr	r5, [r0, #60]	@ 0x3c
 8001394:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    if (judgeType == TYJ_function)
 8001398:	791b      	ldrb	r3, [r3, #4]
 800139a:	2b32      	cmp	r3, #50	@ 0x32
 800139c:	d000      	beq.n	80013a0 <SCD_CMD_CALL+0x10>
}
 800139e:	bd70      	pop	{r4, r5, r6, pc}
 80013a0:	4614      	mov	r4, r2
 80013a2:	4608      	mov	r0, r1
    return (int32_t)_cz_strtoxl(nptr, 0, 10, 0);
 80013a4:	2100      	movs	r1, #0
 80013a6:	f7ff ff79 	bl	800129c <_cz_strtoxl.constprop.0>
        (*funcPtr)(para);
 80013aa:	f855 3034 	ldr.w	r3, [r5, r4, lsl #3]
}
 80013ae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        (*funcPtr)(para);
 80013b2:	4718      	bx	r3

080013b4 <SCD_CMD_DUMP>:
{
 80013b4:	b510      	push	{r4, lr}
 80013b6:	4604      	mov	r4, r0
 80013b8:	4608      	mov	r0, r1
    return (int32_t)_cz_strtoxl(nptr, 0, 10, 0);
 80013ba:	2100      	movs	r1, #0
    scd->dumpTarget = targetNum;
 80013bc:	f8a4 205a 	strh.w	r2, [r4, #90]	@ 0x5a
    return (int32_t)_cz_strtoxl(nptr, 0, 10, 0);
 80013c0:	f7ff ff6c 	bl	800129c <_cz_strtoxl.constprop.0>
    if (p_num > SCD_MAX_DUMP_COUNT)
 80013c4:	f5b0 4ffa 	cmp.w	r0, #32000	@ 0x7d00
 80013c8:	bfa8      	it	ge
 80013ca:	f44f 40fa 	movge.w	r0, #32000	@ 0x7d00
    scd->dumpNumCnt = p_num;
 80013ce:	2801      	cmp	r0, #1
 80013d0:	bfb8      	it	lt
 80013d2:	2001      	movlt	r0, #1
 80013d4:	b203      	sxth	r3, r0
 80013d6:	f8a4 305c 	strh.w	r3, [r4, #92]	@ 0x5c
}
 80013da:	bd10      	pop	{r4, pc}

080013dc <SCD_CMD_CHG>:
{
 80013dc:	460a      	mov	r2, r1
    return (int32_t)_cz_strtoxl(nptr, 0, 10, 0);
 80013de:	2100      	movs	r1, #0
{
 80013e0:	b510      	push	{r4, lr}
 80013e2:	4604      	mov	r4, r0
    return (int32_t)_cz_strtoxl(nptr, 0, 10, 0);
 80013e4:	4610      	mov	r0, r2
 80013e6:	f7ff ff59 	bl	800129c <_cz_strtoxl.constprop.0>
    if (p_num >= 0 && p_num < SCD_PROTOCOL_NUM)
 80013ea:	2804      	cmp	r0, #4
 80013ec:	d802      	bhi.n	80013f4 <SCD_CMD_CHG+0x18>
        scd->sco_protocol_num_next = p_num;
 80013ee:	b203      	sxth	r3, r0
 80013f0:	f8a4 3050 	strh.w	r3, [r4, #80]	@ 0x50
}
 80013f4:	bd10      	pop	{r4, pc}
 80013f6:	bf00      	nop

080013f8 <SCD_CMD_CONF>:
{
 80013f8:	b538      	push	{r3, r4, r5, lr}
    if (targetNum >= 0 && targetNum < SCD_SEND_TAB_SIZE)
 80013fa:	b293      	uxth	r3, r2
 80013fc:	2b13      	cmp	r3, #19
 80013fe:	d900      	bls.n	8001402 <SCD_CMD_CONF+0xa>
}
 8001400:	bd38      	pop	{r3, r4, r5, pc}
 8001402:	4605      	mov	r5, r0
 8001404:	4608      	mov	r0, r1
    return (int32_t)_cz_strtoxl(nptr, 0, 10, 0);
 8001406:	2100      	movs	r1, #0
 8001408:	4614      	mov	r4, r2
 800140a:	f7ff ff47 	bl	800129c <_cz_strtoxl.constprop.0>
            scd->structToSendTab[targetNum] = varNum;
 800140e:	b200      	sxth	r0, r0
 8001410:	f825 0014 	strh.w	r0, [r5, r4, lsl #1]
}
 8001414:	bd38      	pop	{r3, r4, r5, pc}
 8001416:	bf00      	nop

08001418 <SCD_CMD_SET>:
{
 8001418:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (SCD_DATA_STRUCT_tab[targetNum]._type == TYJ_float)
 800141c:	6bc6      	ldr	r6, [r0, #60]	@ 0x3c
{
 800141e:	b082      	sub	sp, #8
 8001420:	4615      	mov	r5, r2
 8001422:	460c      	mov	r4, r1
    if (SCD_DATA_STRUCT_tab[targetNum]._type == TYJ_float)
 8001424:	eb06 07c2 	add.w	r7, r6, r2, lsl #3
 8001428:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 800142c:	2b24      	cmp	r3, #36	@ 0x24
 800142e:	d02c      	beq.n	800148a <SCD_CMD_SET+0x72>
    if (SCD_DATA_STRUCT_tab[targetNum]._type == TYJ_uint16_t)
 8001430:	2b02      	cmp	r3, #2
 8001432:	d01e      	beq.n	8001472 <SCD_CMD_SET+0x5a>
    if (SCD_DATA_STRUCT_tab[targetNum]._type == TYJ_int16_t)
 8001434:	2b12      	cmp	r3, #18
 8001436:	d010      	beq.n	800145a <SCD_CMD_SET+0x42>
    if (SCD_DATA_STRUCT_tab[targetNum]._type == TYJ_uint32_t)
 8001438:	2b04      	cmp	r3, #4
 800143a:	d004      	beq.n	8001446 <SCD_CMD_SET+0x2e>
    if (SCD_DATA_STRUCT_tab[targetNum]._type == TYJ_int32_t)
 800143c:	2b14      	cmp	r3, #20
 800143e:	d002      	beq.n	8001446 <SCD_CMD_SET+0x2e>
}
 8001440:	b002      	add	sp, #8
 8001442:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return (int32_t)_cz_strtoxl(nptr, 0, 10, 0);
 8001446:	2100      	movs	r1, #0
 8001448:	4620      	mov	r0, r4
        volatile int32_t *xtemp = (int32_t *)(void *)SCD_DATA_STRUCT_tab[targetNum]._addr;
 800144a:	f856 4035 	ldr.w	r4, [r6, r5, lsl #3]
    return (int32_t)_cz_strtoxl(nptr, 0, 10, 0);
 800144e:	f7ff ff25 	bl	800129c <_cz_strtoxl.constprop.0>
        *xtemp = cz_atol((const char *)paraPtr);
 8001452:	6020      	str	r0, [r4, #0]
}
 8001454:	b002      	add	sp, #8
 8001456:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return (int32_t)_cz_strtoxl(nptr, 0, 10, 0);
 800145a:	2100      	movs	r1, #0
 800145c:	4620      	mov	r0, r4
        volatile int16_t *xtemp = (int16_t *)(void *)SCD_DATA_STRUCT_tab[targetNum]._addr;
 800145e:	f856 8035 	ldr.w	r8, [r6, r5, lsl #3]
    return (int32_t)_cz_strtoxl(nptr, 0, 10, 0);
 8001462:	f7ff ff1b 	bl	800129c <_cz_strtoxl.constprop.0>
        *xtemp = cz_atol((const char *)paraPtr);
 8001466:	b200      	sxth	r0, r0
 8001468:	f8a8 0000 	strh.w	r0, [r8]
    if (SCD_DATA_STRUCT_tab[targetNum]._type == TYJ_uint32_t)
 800146c:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 8001470:	e7e2      	b.n	8001438 <SCD_CMD_SET+0x20>
    return (int32_t)_cz_strtoxl(nptr, 0, 10, 0);
 8001472:	2100      	movs	r1, #0
 8001474:	4620      	mov	r0, r4
        volatile uint16_t *xtemp = (uint16_t *)(void *)SCD_DATA_STRUCT_tab[targetNum]._addr;
 8001476:	f856 8032 	ldr.w	r8, [r6, r2, lsl #3]
    return (int32_t)_cz_strtoxl(nptr, 0, 10, 0);
 800147a:	f7ff ff0f 	bl	800129c <_cz_strtoxl.constprop.0>
        *xtemp = cz_atol((const char *)paraPtr);
 800147e:	b280      	uxth	r0, r0
 8001480:	f8a8 0000 	strh.w	r0, [r8]
    if (SCD_DATA_STRUCT_tab[targetNum]._type == TYJ_int16_t)
 8001484:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 8001488:	e7d4      	b.n	8001434 <SCD_CMD_SET+0x1c>
    const char *nextCharPtr = NULL;
 800148a:	2300      	movs	r3, #0
    while (!cz_isalnum((int)(unsigned char)(*chrIn)))
 800148c:	7809      	ldrb	r1, [r1, #0]
 800148e:	4a3c      	ldr	r2, [pc, #240]	@ (8001580 <SCD_CMD_SET+0x168>)
    const char *nextCharPtr = NULL;
 8001490:	9301      	str	r3, [sp, #4]
    while (!cz_isalnum((int)(unsigned char)(*chrIn)))
 8001492:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
        volatile float *xtemp = (float *)(void *)SCD_DATA_STRUCT_tab[targetNum]._addr;
 8001496:	f856 5035 	ldr.w	r5, [r6, r5, lsl #3]
    int sign = 1;
 800149a:	2601      	movs	r6, #1
    while (!cz_isalnum((int)(unsigned char)(*chrIn)))
 800149c:	0758      	lsls	r0, r3, #29
 800149e:	d024      	beq.n	80014ea <SCD_CMD_SET+0xd2>
    int32_t intPart = _cz_strtoxl(chrIn, &nextCharPtr, 10, 0);
 80014a0:	4620      	mov	r0, r4
 80014a2:	a901      	add	r1, sp, #4
 80014a4:	f7ff fefa 	bl	800129c <_cz_strtoxl.constprop.0>
 80014a8:	ee07 0a90 	vmov	s15, r0
    if (*nextCharPtr == '.')
 80014ac:	9801      	ldr	r0, [sp, #4]
 80014ae:	7802      	ldrb	r2, [r0, #0]
 80014b0:	2a2e      	cmp	r2, #46	@ 0x2e
 80014b2:	d040      	beq.n	8001536 <SCD_CMD_SET+0x11e>
    float decPart = 0;
 80014b4:	ed9f 7a33 	vldr	s14, [pc, #204]	@ 8001584 <SCD_CMD_SET+0x16c>
    if (*nextCharPtr == 'e' || *nextCharPtr == 'E')
 80014b8:	f002 02df 	and.w	r2, r2, #223	@ 0xdf
 80014bc:	2a45      	cmp	r2, #69	@ 0x45
 80014be:	d01a      	beq.n	80014f6 <SCD_CMD_SET+0xde>
    if (sign == 1)
 80014c0:	2e01      	cmp	r6, #1
        ret = intPart + decPart;
 80014c2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    if (sign == 1)
 80014c6:	d033      	beq.n	8001530 <SCD_CMD_SET+0x118>
        ret = -decPart - intPart;
 80014c8:	eeb1 7a47 	vneg.f32	s14, s14
 80014cc:	ee77 7a67 	vsub.f32	s15, s14, s15
        *xtemp = atof_tyj((const char *)paraPtr);
 80014d0:	edc5 7a00 	vstr	s15, [r5]
}
 80014d4:	b002      	add	sp, #8
 80014d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            else if (*chrIn == '+')
 80014da:	292b      	cmp	r1, #43	@ 0x2b
 80014dc:	d125      	bne.n	800152a <SCD_CMD_SET+0x112>
    while (!cz_isalnum((int)(unsigned char)(*chrIn)))
 80014de:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 80014e2:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 80014e6:	0758      	lsls	r0, r3, #29
 80014e8:	d1da      	bne.n	80014a0 <SCD_CMD_SET+0x88>
        if (cz_ispunct((int)(unsigned char)(*chrIn)))
 80014ea:	06df      	lsls	r7, r3, #27
 80014ec:	d5f7      	bpl.n	80014de <SCD_CMD_SET+0xc6>
            if (*chrIn == '-')
 80014ee:	292d      	cmp	r1, #45	@ 0x2d
 80014f0:	d1f3      	bne.n	80014da <SCD_CMD_SET+0xc2>
                sign = -sign;
 80014f2:	4276      	negs	r6, r6
 80014f4:	e7f3      	b.n	80014de <SCD_CMD_SET+0xc6>
        ePart = _cz_strtoxl(chrIn, &nextCharPtr, 10, 0);
 80014f6:	a901      	add	r1, sp, #4
 80014f8:	3001      	adds	r0, #1
 80014fa:	f7ff fecf 	bl	800129c <_cz_strtoxl.constprop.0>
    if (sign == 1)
 80014fe:	2e01      	cmp	r6, #1
 8001500:	d00e      	beq.n	8001520 <SCD_CMD_SET+0x108>
        ret = -decPart - intPart;
 8001502:	eeb1 7a47 	vneg.f32	s14, s14
 8001506:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800150a:	ee77 7a67 	vsub.f32	s15, s14, s15
    while (exp > 0)
 800150e:	2800      	cmp	r0, #0
 8001510:	dd2e      	ble.n	8001570 <SCD_CMD_SET+0x158>
        data *= 10.0f;
 8001512:	eeb2 7a04 	vmov.f32	s14, #36	@ 0x41200000  10.0
    while (exp > 0)
 8001516:	3801      	subs	r0, #1
        data *= 10.0f;
 8001518:	ee67 7a87 	vmul.f32	s15, s15, s14
    while (exp > 0)
 800151c:	d1fb      	bne.n	8001516 <SCD_CMD_SET+0xfe>
 800151e:	e7d7      	b.n	80014d0 <SCD_CMD_SET+0xb8>
        ret = intPart + decPart;
 8001520:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001524:	ee77 7a87 	vadd.f32	s15, s15, s14
 8001528:	e7f1      	b.n	800150e <SCD_CMD_SET+0xf6>
                return 0;
 800152a:	eddf 7a16 	vldr	s15, [pc, #88]	@ 8001584 <SCD_CMD_SET+0x16c>
 800152e:	e7cf      	b.n	80014d0 <SCD_CMD_SET+0xb8>
        ret = intPart + decPart;
 8001530:	ee77 7a27 	vadd.f32	s15, s14, s15
    while (exp < 0)
 8001534:	e7cc      	b.n	80014d0 <SCD_CMD_SET+0xb8>
        chrIn = nextCharPtr + 1;
 8001536:	1c44      	adds	r4, r0, #1
        int32_t decInt = _cz_strtoxl(chrIn, &nextCharPtr, 10, 0);
 8001538:	4620      	mov	r0, r4
 800153a:	f7ff feaf 	bl	800129c <_cz_strtoxl.constprop.0>
 800153e:	ee07 0a10 	vmov	s14, r0
        int lenth = nextCharPtr - chrIn;
 8001542:	9801      	ldr	r0, [sp, #4]
        decPart = _atof_pow10((float)decInt, -lenth);
 8001544:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8001548:	1a23      	subs	r3, r4, r0
    while (exp > 0)
 800154a:	2b00      	cmp	r3, #0
 800154c:	dd07      	ble.n	800155e <SCD_CMD_SET+0x146>
        data *= 10.0f;
 800154e:	eef2 6a04 	vmov.f32	s13, #36	@ 0x41200000  10.0
    while (exp > 0)
 8001552:	3b01      	subs	r3, #1
        data *= 10.0f;
 8001554:	ee27 7a26 	vmul.f32	s14, s14, s13
    while (exp > 0)
 8001558:	d1fb      	bne.n	8001552 <SCD_CMD_SET+0x13a>
    if (*nextCharPtr == 'e' || *nextCharPtr == 'E')
 800155a:	7802      	ldrb	r2, [r0, #0]
 800155c:	e7ac      	b.n	80014b8 <SCD_CMD_SET+0xa0>
 800155e:	7802      	ldrb	r2, [r0, #0]
    while (exp < 0)
 8001560:	d0aa      	beq.n	80014b8 <SCD_CMD_SET+0xa0>
        data *= 0.1f;
 8001562:	eddf 6a09 	vldr	s13, [pc, #36]	@ 8001588 <SCD_CMD_SET+0x170>
    while (exp < 0)
 8001566:	3301      	adds	r3, #1
        data *= 0.1f;
 8001568:	ee27 7a26 	vmul.f32	s14, s14, s13
    while (exp < 0)
 800156c:	d1fb      	bne.n	8001566 <SCD_CMD_SET+0x14e>
 800156e:	e7a3      	b.n	80014b8 <SCD_CMD_SET+0xa0>
 8001570:	d0ae      	beq.n	80014d0 <SCD_CMD_SET+0xb8>
        data *= 0.1f;
 8001572:	ed9f 7a05 	vldr	s14, [pc, #20]	@ 8001588 <SCD_CMD_SET+0x170>
    while (exp < 0)
 8001576:	3001      	adds	r0, #1
        data *= 0.1f;
 8001578:	ee67 7a87 	vmul.f32	s15, s15, s14
    while (exp < 0)
 800157c:	d1fb      	bne.n	8001576 <SCD_CMD_SET+0x15e>
 800157e:	e7a7      	b.n	80014d0 <SCD_CMD_SET+0xb8>
 8001580:	08008310 	.word	0x08008310
 8001584:	00000000 	.word	0x00000000
 8001588:	3dcccccd 	.word	0x3dcccccd

0800158c <SCD_Rev1Byte>:
    if (data == '!')
 800158c:	2921      	cmp	r1, #33	@ 0x21
{
 800158e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    volatile unsigned char(*recBuff)[SCD_REVBUFF_SIZE] = scd->_recBuff;
 8001592:	6a84      	ldr	r4, [r0, #40]	@ 0x28
{
 8001594:	b083      	sub	sp, #12
    if (data == '!')
 8001596:	d012      	beq.n	80015be <SCD_Rev1Byte+0x32>
        recBuff[scd->bufNum][scd->bytesRec++] = data;
 8001598:	f8b0 3046 	ldrh.w	r3, [r0, #70]	@ 0x46
 800159c:	b2c9      	uxtb	r1, r1
 800159e:	f8b0 2048 	ldrh.w	r2, [r0, #72]	@ 0x48
 80015a2:	b21b      	sxth	r3, r3
 80015a4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80015a8:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
 80015ac:	1c53      	adds	r3, r2, #1
 80015ae:	b212      	sxth	r2, r2
 80015b0:	b21b      	sxth	r3, r3
 80015b2:	f8a0 3048 	strh.w	r3, [r0, #72]	@ 0x48
 80015b6:	54a1      	strb	r1, [r4, r2]
}
 80015b8:	b003      	add	sp, #12
 80015ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (scd->bytesRec > 0)
 80015be:	f8b0 3048 	ldrh.w	r3, [r0, #72]	@ 0x48
 80015c2:	b21b      	sxth	r3, r3
 80015c4:	2b00      	cmp	r3, #0
 80015c6:	ddf7      	ble.n	80015b8 <SCD_Rev1Byte+0x2c>
            for (int16_t ii = 0; ii < scd->bytesRec; ii++)
 80015c8:	f8b0 3048 	ldrh.w	r3, [r0, #72]	@ 0x48
 80015cc:	b21b      	sxth	r3, r3
 80015ce:	2b00      	cmp	r3, #0
 80015d0:	dd1e      	ble.n	8001610 <SCD_Rev1Byte+0x84>
 80015d2:	2100      	movs	r1, #0
            uint16_t isSame = 1;
 80015d4:	2501      	movs	r5, #1
 80015d6:	460b      	mov	r3, r1
                if (recBuff[0][ii] != recBuff[1][ii])
 80015d8:	18e2      	adds	r2, r4, r3
 80015da:	5ce7      	ldrb	r7, [r4, r3]
            for (int16_t ii = 0; ii < scd->bytesRec; ii++)
 80015dc:	3101      	adds	r1, #1
                if (recBuff[0][ii] != recBuff[1][ii])
 80015de:	f892 6028 	ldrb.w	r6, [r2, #40]	@ 0x28
            for (int16_t ii = 0; ii < scd->bytesRec; ii++)
 80015e2:	f8b0 2048 	ldrh.w	r2, [r0, #72]	@ 0x48
 80015e6:	b20b      	sxth	r3, r1
                    isSame = 0;
 80015e8:	42b7      	cmp	r7, r6
 80015ea:	bf18      	it	ne
 80015ec:	2500      	movne	r5, #0
            for (int16_t ii = 0; ii < scd->bytesRec; ii++)
 80015ee:	b212      	sxth	r2, r2
 80015f0:	4293      	cmp	r3, r2
 80015f2:	dbf1      	blt.n	80015d8 <SCD_Rev1Byte+0x4c>
            if (isSame)
 80015f4:	b965      	cbnz	r5, 8001610 <SCD_Rev1Byte+0x84>
                if (scd->bufNum)
 80015f6:	f8b0 3046 	ldrh.w	r3, [r0, #70]	@ 0x46
 80015fa:	b21b      	sxth	r3, r3
 80015fc:	2b00      	cmp	r3, #0
 80015fe:	d058      	beq.n	80016b2 <SCD_Rev1Byte+0x126>
                    scd->bufNum = 0;
 8001600:	f8a0 5046 	strh.w	r5, [r0, #70]	@ 0x46
            scd->bytesRec = 0;
 8001604:	2300      	movs	r3, #0
 8001606:	f8a0 3048 	strh.w	r3, [r0, #72]	@ 0x48
}
 800160a:	b003      	add	sp, #12
 800160c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                recBuff[0][scd->bytesRec] = 0;
 8001610:	f8b0 3048 	ldrh.w	r3, [r0, #72]	@ 0x48
 8001614:	2100      	movs	r1, #0
 8001616:	4e4a      	ldr	r6, [pc, #296]	@ (8001740 <SCD_Rev1Byte+0x1b4>)
 8001618:	b21b      	sxth	r3, r3
    int16_t xstart = 0;
 800161a:	460a      	mov	r2, r1
                recBuff[0][scd->bytesRec] = 0;
 800161c:	54e1      	strb	r1, [r4, r3]
    volatile unsigned char(*recBuff)[SCD_REVBUFF_SIZE] = scd->_recBuff;
 800161e:	6a81      	ldr	r1, [r0, #40]	@ 0x28
    while (!cz_isalnum((int)(unsigned char)(recBuff[0][xstart])))
 8001620:	e003      	b.n	800162a <SCD_Rev1Byte+0x9e>
        xstart++;
 8001622:	b22a      	sxth	r2, r5
        if (recBuff[0][xstart] == 0)
 8001624:	5c8b      	ldrb	r3, [r1, r2]
 8001626:	2b00      	cmp	r3, #0
 8001628:	d07e      	beq.n	8001728 <SCD_Rev1Byte+0x19c>
    while (!cz_isalnum((int)(unsigned char)(recBuff[0][xstart])))
 800162a:	5c8b      	ldrb	r3, [r1, r2]
 800162c:	1c55      	adds	r5, r2, #1
 800162e:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 8001632:	075f      	lsls	r7, r3, #29
 8001634:	d0f5      	beq.n	8001622 <SCD_Rev1Byte+0x96>
    if (!cz_isalpha((int)(unsigned char)(recBuff[0][xstart])))
 8001636:	5c8b      	ldrb	r3, [r1, r2]
 8001638:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 800163c:	079b      	lsls	r3, r3, #30
 800163e:	d073      	beq.n	8001728 <SCD_Rev1Byte+0x19c>
    while (cz_isalpha((int)(unsigned char)(recBuff[0][cmdLen + xstart])))
 8001640:	5c8b      	ldrb	r3, [r1, r2]
 8001642:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 8001646:	f013 0303 	ands.w	r3, r3, #3
 800164a:	d073      	beq.n	8001734 <SCD_Rev1Byte+0x1a8>
 800164c:	2501      	movs	r5, #1
        cmdLen++;
 800164e:	fa0f fe85 	sxth.w	lr, r5
    while (cz_isalpha((int)(unsigned char)(recBuff[0][cmdLen + xstart])))
 8001652:	462b      	mov	r3, r5
 8001654:	eb0e 0502 	add.w	r5, lr, r2
 8001658:	5d4d      	ldrb	r5, [r1, r5]
 800165a:	f856 7025 	ldr.w	r7, [r6, r5, lsl #2]
 800165e:	1c5d      	adds	r5, r3, #1
 8001660:	f017 0703 	ands.w	r7, r7, #3
 8001664:	b2ad      	uxth	r5, r5
 8001666:	d1f2      	bne.n	800164e <SCD_Rev1Byte+0xc2>
        for (int16_t jj = 0; jj < cmdLen; jj++)
 8001668:	f1be 0f00 	cmp.w	lr, #0
 800166c:	dd62      	ble.n	8001734 <SCD_Rev1Byte+0x1a8>
 800166e:	46bb      	mov	fp, r7
 8001670:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 8001748 <SCD_Rev1Byte+0x1bc>
 8001674:	46b9      	mov	r9, r7
 8001676:	e9cd 3400 	strd	r3, r4, [sp]
            if (recBuff[0][jj + xstart] != SCD_CMD_TAB[ii][jj])
 800167a:	f85a 5b04 	ldr.w	r5, [sl], #4
        int16_t isSame = 1;
 800167e:	2401      	movs	r4, #1
            if (recBuff[0][jj + xstart] != SCD_CMD_TAB[ii][jj])
 8001680:	462b      	mov	r3, r5
 8001682:	eb05 0c0e 	add.w	ip, r5, lr
 8001686:	eba2 0805 	sub.w	r8, r2, r5
 800168a:	eb08 0503 	add.w	r5, r8, r3
 800168e:	f813 7b01 	ldrb.w	r7, [r3], #1
 8001692:	5d4d      	ldrb	r5, [r1, r5]
                isSame = 0;
 8001694:	42af      	cmp	r7, r5
 8001696:	bf18      	it	ne
 8001698:	2400      	movne	r4, #0
        for (int16_t jj = 0; jj < cmdLen; jj++)
 800169a:	459c      	cmp	ip, r3
 800169c:	d1f5      	bne.n	800168a <SCD_Rev1Byte+0xfe>
        if (isSame)
 800169e:	2c00      	cmp	r4, #0
 80016a0:	d14b      	bne.n	800173a <SCD_Rev1Byte+0x1ae>
    for (int16_t ii = 0; ii < SCD_CMD_NUM; ii++)
 80016a2:	f109 0901 	add.w	r9, r9, #1
 80016a6:	f1b9 0f05 	cmp.w	r9, #5
 80016aa:	d006      	beq.n	80016ba <SCD_Rev1Byte+0x12e>
 80016ac:	fa0f fb89 	sxth.w	fp, r9
        for (int16_t jj = 0; jj < cmdLen; jj++)
 80016b0:	e7e3      	b.n	800167a <SCD_Rev1Byte+0xee>
                    scd->bufNum = 1;
 80016b2:	2301      	movs	r3, #1
 80016b4:	f8a0 3046 	strh.w	r3, [r0, #70]	@ 0x46
 80016b8:	e7a4      	b.n	8001604 <SCD_Rev1Byte+0x78>
    int16_t cmd2exec = -1;
 80016ba:	e9dd 3400 	ldrd	r3, r4, [sp]
 80016be:	f04f 3bff 	mov.w	fp, #4294967295
    int16_t ptr = cmdLen + xstart;
 80016c2:	4413      	add	r3, r2
 80016c4:	b21b      	sxth	r3, r3
    if (!cz_isdigit((int)(unsigned char)(recBuff[0][ptr])))
 80016c6:	5cca      	ldrb	r2, [r1, r3]
 80016c8:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
 80016cc:	0757      	lsls	r7, r2, #29
 80016ce:	d52b      	bpl.n	8001728 <SCD_Rev1Byte+0x19c>
    while (cz_isdigit((int)(unsigned char)(recBuff[0][ptr])))
 80016d0:	5cca      	ldrb	r2, [r1, r3]
 80016d2:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
 80016d6:	f012 0204 	ands.w	r2, r2, #4
 80016da:	d00e      	beq.n	80016fa <SCD_Rev1Byte+0x16e>
    int16_t targetNum = 0;
 80016dc:	2200      	movs	r2, #0
        targetNum = targetNum * 10 + recBuff[0][ptr] - '0';
 80016de:	eb02 0582 	add.w	r5, r2, r2, lsl #2
 80016e2:	1c5f      	adds	r7, r3, #1
 80016e4:	5cca      	ldrb	r2, [r1, r3]
        ptr++;
 80016e6:	b23b      	sxth	r3, r7
        targetNum = targetNum * 10 + recBuff[0][ptr] - '0';
 80016e8:	3a30      	subs	r2, #48	@ 0x30
 80016ea:	eb02 0245 	add.w	r2, r2, r5, lsl #1
    while (cz_isdigit((int)(unsigned char)(recBuff[0][ptr])))
 80016ee:	5ccd      	ldrb	r5, [r1, r3]
 80016f0:	f856 5025 	ldr.w	r5, [r6, r5, lsl #2]
        targetNum = targetNum * 10 + recBuff[0][ptr] - '0';
 80016f4:	b212      	sxth	r2, r2
    while (cz_isdigit((int)(unsigned char)(recBuff[0][ptr])))
 80016f6:	076d      	lsls	r5, r5, #29
 80016f8:	d4f1      	bmi.n	80016de <SCD_Rev1Byte+0x152>
    if (recBuff[0][ptr] != '#')
 80016fa:	5ccd      	ldrb	r5, [r1, r3]
 80016fc:	2d23      	cmp	r5, #35	@ 0x23
 80016fe:	d113      	bne.n	8001728 <SCD_Rev1Byte+0x19c>
    if (cmd2exec >= 0 && cmd2exec < SCD_CMD_NUM && targetNum < scd->structNum && targetNum >= 0)
 8001700:	fa1f f58b 	uxth.w	r5, fp
 8001704:	2d04      	cmp	r5, #4
 8001706:	d80f      	bhi.n	8001728 <SCD_Rev1Byte+0x19c>
 8001708:	f8b0 5044 	ldrh.w	r5, [r0, #68]	@ 0x44
 800170c:	2a00      	cmp	r2, #0
 800170e:	b22d      	sxth	r5, r5
 8001710:	db0a      	blt.n	8001728 <SCD_Rev1Byte+0x19c>
 8001712:	4295      	cmp	r5, r2
 8001714:	dd08      	ble.n	8001728 <SCD_Rev1Byte+0x19c>
    ptr++;
 8001716:	3301      	adds	r3, #1
        (*SCD_CMD_FCNS[cmd2exec])(scd, &recBuff[0][ptr], targetNum);
 8001718:	9000      	str	r0, [sp, #0]
 800171a:	fa01 f183 	sxtah	r1, r1, r3
 800171e:	4b09      	ldr	r3, [pc, #36]	@ (8001744 <SCD_Rev1Byte+0x1b8>)
 8001720:	f853 302b 	ldr.w	r3, [r3, fp, lsl #2]
 8001724:	4798      	blx	r3
 8001726:	9800      	ldr	r0, [sp, #0]
                scd->bufNum = 0;
 8001728:	2300      	movs	r3, #0
 800172a:	f8a0 3046 	strh.w	r3, [r0, #70]	@ 0x46
                recBuff[1][0] = 0;
 800172e:	f884 3028 	strb.w	r3, [r4, #40]	@ 0x28
 8001732:	e767      	b.n	8001604 <SCD_Rev1Byte+0x78>
            cmd2exec = ii;
 8001734:	f04f 0b00 	mov.w	fp, #0
 8001738:	e7c3      	b.n	80016c2 <SCD_Rev1Byte+0x136>
 800173a:	e9dd 3400 	ldrd	r3, r4, [sp]
 800173e:	e7c0      	b.n	80016c2 <SCD_Rev1Byte+0x136>
 8001740:	08008310 	.word	0x08008310
 8001744:	08007e10 	.word	0x08007e10
 8001748:	080082fc 	.word	0x080082fc

0800174c <scd_send1Byte>:

#if SCD_IF_USE_RAM_FUNCS
#pragma CODE_SECTION(scd_send1Byte, MEM_MACRO);
#endif
uint16_t scd_send1Byte(struct SCD_CTRL_STRUCT *scd)
{
 800174c:	b538      	push	{r3, r4, r5, lr}
    uint16_t ret;
    ret = SCD_PROTOCOL_FCNS[scd->sco_protocol_num](scd);
 800174e:	f8b0 304e 	ldrh.w	r3, [r0, #78]	@ 0x4e
{
 8001752:	4604      	mov	r4, r0
    ret = SCD_PROTOCOL_FCNS[scd->sco_protocol_num](scd);
 8001754:	4d0d      	ldr	r5, [pc, #52]	@ (800178c <scd_send1Byte+0x40>)
 8001756:	b21b      	sxth	r3, r3
 8001758:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 800175c:	4798      	blx	r3
    if (ret & (((uint16_t)0xffu) << 8))
 800175e:	28ff      	cmp	r0, #255	@ 0xff
 8001760:	d90e      	bls.n	8001780 <scd_send1Byte+0x34>
    {
        // 到结尾了,换协议
        if (scd->isPrintBusyFlg)
 8001762:	f8b4 3062 	ldrh.w	r3, [r4, #98]	@ 0x62
 8001766:	b21b      	sxth	r3, r3
 8001768:	b963      	cbnz	r3, 8001784 <scd_send1Byte+0x38>
            // 确保print优先级最高，不会被chg命令覆盖
            scd->sco_protocol_num = 4;
        }
        else
        {
            scd->sco_protocol_num = scd->sco_protocol_num_next;
 800176a:	f8b4 3050 	ldrh.w	r3, [r4, #80]	@ 0x50
 800176e:	f8a4 304e 	strh.w	r3, [r4, #78]	@ 0x4e
        }
        ret = SCD_PROTOCOL_FCNS[scd->sco_protocol_num](scd);
 8001772:	f8b4 304e 	ldrh.w	r3, [r4, #78]	@ 0x4e
 8001776:	4620      	mov	r0, r4
 8001778:	b21b      	sxth	r3, r3
 800177a:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 800177e:	4798      	blx	r3
    }
    return ret & 0xffu;
}
 8001780:	b2c0      	uxtb	r0, r0
 8001782:	bd38      	pop	{r3, r4, r5, pc}
            scd->sco_protocol_num = 4;
 8001784:	2304      	movs	r3, #4
 8001786:	f8a4 304e 	strh.w	r3, [r4, #78]	@ 0x4e
 800178a:	e7f2      	b.n	8001772 <scd_send1Byte+0x26>
 800178c:	08007dfc 	.word	0x08007dfc

08001790 <scd_init_1>:
SCD_REG_ADD(test1, int16_t)
SCD_REG_ADD(test2, int32_t)
SCD_REG_ADD(test3, uint16_t)
SCD_REG_ADD(test4, uint32_t)
SCD_REG_ADD(test5, float)
SCD_REG_END(_1)
 8001790:	4b1e      	ldr	r3, [pc, #120]	@ (800180c <scd_init_1+0x7c>)
 8001792:	2200      	movs	r2, #0
 8001794:	f242 710f 	movw	r1, #9999	@ 0x270f
 8001798:	481d      	ldr	r0, [pc, #116]	@ (8001810 <scd_init_1+0x80>)
 800179a:	b410      	push	{r4}
 800179c:	801a      	strh	r2, [r3, #0]
 800179e:	4c1d      	ldr	r4, [pc, #116]	@ (8001814 <scd_init_1+0x84>)
 80017a0:	8059      	strh	r1, [r3, #2]
 80017a2:	491d      	ldr	r1, [pc, #116]	@ (8001818 <scd_init_1+0x88>)
 80017a4:	63d8      	str	r0, [r3, #60]	@ 0x3c
 80017a6:	481d      	ldr	r0, [pc, #116]	@ (800181c <scd_init_1+0x8c>)
 80017a8:	e9c3 410a 	strd	r4, r1, [r3, #40]	@ 0x28
 80017ac:	491c      	ldr	r1, [pc, #112]	@ (8001820 <scd_init_1+0x90>)
 80017ae:	4c1d      	ldr	r4, [pc, #116]	@ (8001824 <scd_init_1+0x94>)
 80017b0:	e9c3 010c 	strd	r0, r1, [r3, #48]	@ 0x30
 80017b4:	2005      	movs	r0, #5
 80017b6:	2100      	movs	r1, #0
 80017b8:	639c      	str	r4, [r3, #56]	@ 0x38
 80017ba:	f8a3 0044 	strh.w	r0, [r3, #68]	@ 0x44
 80017be:	f85d 4b04 	ldr.w	r4, [sp], #4
 80017c2:	f8a3 2046 	strh.w	r2, [r3, #70]	@ 0x46
 80017c6:	f8a3 2048 	strh.w	r2, [r3, #72]	@ 0x48
 80017ca:	f8a3 204c 	strh.w	r2, [r3, #76]	@ 0x4c
 80017ce:	f8a3 204a 	strh.w	r2, [r3, #74]	@ 0x4a
 80017d2:	6419      	str	r1, [r3, #64]	@ 0x40
 80017d4:	f8a3 204e 	strh.w	r2, [r3, #78]	@ 0x4e
 80017d8:	f8a3 2050 	strh.w	r2, [r3, #80]	@ 0x50
 80017dc:	f8a3 2054 	strh.w	r2, [r3, #84]	@ 0x54
 80017e0:	f8a3 2052 	strh.w	r2, [r3, #82]	@ 0x52
 80017e4:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56
 80017e8:	f8a3 2058 	strh.w	r2, [r3, #88]	@ 0x58
 80017ec:	f8a3 205a 	strh.w	r2, [r3, #90]	@ 0x5a
 80017f0:	f8a3 205c 	strh.w	r2, [r3, #92]	@ 0x5c
 80017f4:	f8a3 205e 	strh.w	r2, [r3, #94]	@ 0x5e
 80017f8:	f8a3 2060 	strh.w	r2, [r3, #96]	@ 0x60
 80017fc:	f8a3 2062 	strh.w	r2, [r3, #98]	@ 0x62
 8001800:	f8a3 2064 	strh.w	r2, [r3, #100]	@ 0x64
 8001804:	f8a3 2066 	strh.w	r2, [r3, #102]	@ 0x66
 8001808:	4770      	bx	lr
 800180a:	bf00      	nop
 800180c:	24000270 	.word	0x24000270
 8001810:	08008710 	.word	0x08008710
 8001814:	24000300 	.word	0x24000300
 8001818:	240002d8 	.word	0x240002d8
 800181c:	24000020 	.word	0x24000020
 8001820:	24000018 	.word	0x24000018
 8001824:	24000014 	.word	0x24000014

08001828 <MX_SDMMC1_SD_Init>:
  /* USER CODE BEGIN SDMMC1_Init 2 */

#endif
  /* USER CODE END SDMMC1_Init 2 */

}
 8001828:	4770      	bx	lr
 800182a:	bf00      	nop

0800182c <MX_SPI1_Init>:

/* USER CODE END 0 */

/* SPI1 init function */
void MX_SPI1_Init(void)
{
 800182c:	b570      	push	{r4, r5, r6, lr}
 800182e:	b092      	sub	sp, #72	@ 0x48

  /* USER CODE BEGIN SPI1_Init 0 */

  /* USER CODE END SPI1_Init 0 */

  LL_SPI_InitTypeDef SPI_InitStruct = {0};
 8001830:	2228      	movs	r2, #40	@ 0x28
 8001832:	2100      	movs	r1, #0

  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001834:	2400      	movs	r4, #0
  LL_SPI_InitTypeDef SPI_InitStruct = {0};
 8001836:	a808      	add	r0, sp, #32
  PB4 (NJTRST)   ------> SPI1_MISO
  PB5   ------> SPI1_MOSI
  */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_3|LL_GPIO_PIN_4|LL_GPIO_PIN_5;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 8001838:	2603      	movs	r6, #3
  LL_SPI_InitTypeDef SPI_InitStruct = {0};
 800183a:	f005 fd36 	bl	80072aa <memset>
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
 800183e:	4929      	ldr	r1, [pc, #164]	@ (80018e4 <MX_SPI1_Init+0xb8>)
  * @retval None
*/
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 8001840:	4b29      	ldr	r3, [pc, #164]	@ (80018e8 <MX_SPI1_Init+0xbc>)
  SPI_InitStruct.NSS = LL_SPI_NSS_SOFT;
  SPI_InitStruct.BaudRate = LL_SPI_BAUDRATEPRESCALER_DIV2;
  SPI_InitStruct.BitOrder = LL_SPI_MSB_FIRST;
  SPI_InitStruct.CRCCalculation = LL_SPI_CRCCALCULATION_DISABLE;
  SPI_InitStruct.CRCPoly = 0x0;
  LL_SPI_Init(SPI1, &SPI_InitStruct);
 8001842:	4d2a      	ldr	r5, [pc, #168]	@ (80018ec <MX_SPI1_Init+0xc0>)
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001844:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8001848:	e9cd 4402 	strd	r4, r4, [sp, #8]
 800184c:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8001850:	f8d1 2450 	ldr.w	r2, [r1, #1104]	@ 0x450
 8001854:	f422 42e0 	bic.w	r2, r2, #28672	@ 0x7000
 8001858:	f8c1 2450 	str.w	r2, [r1, #1104]	@ 0x450
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800185c:	a902      	add	r1, sp, #8
 800185e:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
 8001862:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 8001866:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 800186a:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
 800186e:	f402 5280 	and.w	r2, r2, #4096	@ 0x1000
 8001872:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 8001874:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB4ENR, Periphs);
 8001876:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800187a:	f042 0202 	orr.w	r2, r2, #2
 800187e:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  GPIO_InitStruct.Pin = LL_GPIO_PIN_3|LL_GPIO_PIN_4|LL_GPIO_PIN_5;
 8001882:	2238      	movs	r2, #56	@ 0x38
  tmpreg = READ_BIT(RCC->AHB4ENR, Periphs);
 8001884:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8001888:	9405      	str	r4, [sp, #20]
 800188a:	f003 0302 	and.w	r3, r3, #2
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 800188e:	9604      	str	r6, [sp, #16]
 8001890:	9300      	str	r3, [sp, #0]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8001892:	2302      	movs	r3, #2
  (void)tmpreg;
 8001894:	9800      	ldr	r0, [sp, #0]
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001896:	4816      	ldr	r0, [pc, #88]	@ (80018f0 <MX_SPI1_Init+0xc4>)
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8001898:	e9cd 2302 	strd	r2, r3, [sp, #8]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 800189c:	2200      	movs	r2, #0
 800189e:	2305      	movs	r3, #5
 80018a0:	e9cd 2306 	strd	r2, r3, [sp, #24]
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80018a4:	f002 fa70 	bl	8003d88 <LL_GPIO_Init>
  SPI_InitStruct.Mode = LL_SPI_MODE_MASTER;
 80018a8:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
  SPI_InitStruct.NSS = LL_SPI_NSS_SOFT;
 80018ac:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  LL_SPI_Init(SPI1, &SPI_InitStruct);
 80018b0:	a908      	add	r1, sp, #32
  SPI_InitStruct.Mode = LL_SPI_MODE_MASTER;
 80018b2:	9209      	str	r2, [sp, #36]	@ 0x24
  SPI_InitStruct.CRCCalculation = LL_SPI_CRCCALCULATION_DISABLE;
 80018b4:	2200      	movs	r2, #0
  SPI_InitStruct.NSS = LL_SPI_NSS_SOFT;
 80018b6:	930d      	str	r3, [sp, #52]	@ 0x34
  SPI_InitStruct.CRCCalculation = LL_SPI_CRCCALCULATION_DISABLE;
 80018b8:	2300      	movs	r3, #0
  LL_SPI_Init(SPI1, &SPI_InitStruct);
 80018ba:	4628      	mov	r0, r5
  SPI_InitStruct.TransferDirection = LL_SPI_FULL_DUPLEX;
 80018bc:	9408      	str	r4, [sp, #32]
  SPI_InitStruct.DataWidth = LL_SPI_DATAWIDTH_4BIT;
 80018be:	960a      	str	r6, [sp, #40]	@ 0x28
  SPI_InitStruct.CRCCalculation = LL_SPI_CRCCALCULATION_DISABLE;
 80018c0:	e9cd 2310 	strd	r2, r3, [sp, #64]	@ 0x40
  SPI_InitStruct.ClockPhase = LL_SPI_PHASE_1EDGE;
 80018c4:	e9cd 440b 	strd	r4, r4, [sp, #44]	@ 0x2c
  SPI_InitStruct.BitOrder = LL_SPI_MSB_FIRST;
 80018c8:	e9cd 440e 	strd	r4, r4, [sp, #56]	@ 0x38
  LL_SPI_Init(SPI1, &SPI_InitStruct);
 80018cc:	f002 fe08 	bl	80044e0 <LL_SPI_Init>
  *         @arg @ref LL_SPI_PROTOCOL_TI
  * @retval None
  */
__STATIC_INLINE void LL_SPI_SetStandard(SPI_TypeDef *SPIx, uint32_t Standard)
{
  MODIFY_REG(SPIx->CFG2, SPI_CFG2_SP, Standard);
 80018d0:	68eb      	ldr	r3, [r5, #12]
 80018d2:	f423 1360 	bic.w	r3, r3, #3670016	@ 0x380000
 80018d6:	60eb      	str	r3, [r5, #12]
  * @param  SPIx SPI Instance
  * @retval None
  */
__STATIC_INLINE void LL_SPI_EnableNSSPulseMgt(SPI_TypeDef *SPIx)
{
  SET_BIT(SPIx->CFG2, SPI_CFG2_SSOM);
 80018d8:	68eb      	ldr	r3, [r5, #12]
 80018da:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 80018de:	60eb      	str	r3, [r5, #12]
  LL_SPI_EnableNSSPulseMgt(SPI1);
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}
 80018e0:	b012      	add	sp, #72	@ 0x48
 80018e2:	bd70      	pop	{r4, r5, r6, pc}
 80018e4:	58024000 	.word	0x58024000
 80018e8:	58024400 	.word	0x58024400
 80018ec:	40013000 	.word	0x40013000
 80018f0:	58020400 	.word	0x58020400

080018f4 <MX_SPI4_Init>:
/* SPI4 init function */
void MX_SPI4_Init(void)
{
 80018f4:	b570      	push	{r4, r5, r6, lr}
 80018f6:	b092      	sub	sp, #72	@ 0x48

  /* USER CODE BEGIN SPI4_Init 0 */

  /* USER CODE END SPI4_Init 0 */

  LL_SPI_InitTypeDef SPI_InitStruct = {0};
 80018f8:	2228      	movs	r2, #40	@ 0x28
 80018fa:	2100      	movs	r1, #0

  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 80018fc:	2400      	movs	r4, #0
  LL_SPI_InitTypeDef SPI_InitStruct = {0};
 80018fe:	a808      	add	r0, sp, #32
  PE12   ------> SPI4_SCK
  PE14   ------> SPI4_MOSI
  */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_11|LL_GPIO_PIN_12|LL_GPIO_PIN_14;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 8001900:	2603      	movs	r6, #3
  LL_SPI_InitTypeDef SPI_InitStruct = {0};
 8001902:	f005 fcd2 	bl	80072aa <memset>
 8001906:	492b      	ldr	r1, [pc, #172]	@ (80019b4 <MX_SPI4_Init+0xc0>)
  SET_BIT(RCC->APB2ENR, Periphs);
 8001908:	4b2b      	ldr	r3, [pc, #172]	@ (80019b8 <MX_SPI4_Init+0xc4>)
  SPI_InitStruct.NSS = LL_SPI_NSS_HARD_OUTPUT;
  SPI_InitStruct.BaudRate = LL_SPI_BAUDRATEPRESCALER_DIV2;
  SPI_InitStruct.BitOrder = LL_SPI_MSB_FIRST;
  SPI_InitStruct.CRCCalculation = LL_SPI_CRCCALCULATION_DISABLE;
  SPI_InitStruct.CRCPoly = 0x0;
  LL_SPI_Init(SPI4, &SPI_InitStruct);
 800190a:	4d2c      	ldr	r5, [pc, #176]	@ (80019bc <MX_SPI4_Init+0xc8>)
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 800190c:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8001910:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8001914:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8001918:	f8d1 2450 	ldr.w	r2, [r1, #1104]	@ 0x450
 800191c:	f422 22e0 	bic.w	r2, r2, #458752	@ 0x70000
 8001920:	f8c1 2450 	str.w	r2, [r1, #1104]	@ 0x450
  LL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8001924:	a902      	add	r1, sp, #8
 8001926:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
 800192a:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 800192e:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 8001932:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
 8001936:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
 800193a:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 800193c:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB4ENR, Periphs);
 800193e:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8001942:	f042 0210 	orr.w	r2, r2, #16
 8001946:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  GPIO_InitStruct.Pin = LL_GPIO_PIN_11|LL_GPIO_PIN_12|LL_GPIO_PIN_14;
 800194a:	f44f 42b0 	mov.w	r2, #22528	@ 0x5800
  tmpreg = READ_BIT(RCC->AHB4ENR, Periphs);
 800194e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8001952:	9405      	str	r4, [sp, #20]
 8001954:	f003 0310 	and.w	r3, r3, #16
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 8001958:	9604      	str	r6, [sp, #16]
 800195a:	9300      	str	r3, [sp, #0]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 800195c:	2302      	movs	r3, #2
  (void)tmpreg;
 800195e:	9800      	ldr	r0, [sp, #0]
  LL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8001960:	4817      	ldr	r0, [pc, #92]	@ (80019c0 <MX_SPI4_Init+0xcc>)
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8001962:	e9cd 2302 	strd	r2, r3, [sp, #8]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8001966:	2200      	movs	r2, #0
 8001968:	2305      	movs	r3, #5
 800196a:	e9cd 2306 	strd	r2, r3, [sp, #24]
  LL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800196e:	f002 fa0b 	bl	8003d88 <LL_GPIO_Init>
  SPI_InitStruct.TransferDirection = LL_SPI_HALF_DUPLEX_TX;
 8001972:	f44f 22c1 	mov.w	r2, #395264	@ 0x60800
  SPI_InitStruct.NSS = LL_SPI_NSS_HARD_OUTPUT;
 8001976:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
  LL_SPI_Init(SPI4, &SPI_InitStruct);
 800197a:	a908      	add	r1, sp, #32
  SPI_InitStruct.TransferDirection = LL_SPI_HALF_DUPLEX_TX;
 800197c:	9208      	str	r2, [sp, #32]
  SPI_InitStruct.Mode = LL_SPI_MODE_MASTER;
 800197e:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
  SPI_InitStruct.NSS = LL_SPI_NSS_HARD_OUTPUT;
 8001982:	930d      	str	r3, [sp, #52]	@ 0x34
  SPI_InitStruct.CRCCalculation = LL_SPI_CRCCALCULATION_DISABLE;
 8001984:	2300      	movs	r3, #0
  SPI_InitStruct.Mode = LL_SPI_MODE_MASTER;
 8001986:	9209      	str	r2, [sp, #36]	@ 0x24
  SPI_InitStruct.CRCCalculation = LL_SPI_CRCCALCULATION_DISABLE;
 8001988:	2200      	movs	r2, #0
  LL_SPI_Init(SPI4, &SPI_InitStruct);
 800198a:	4628      	mov	r0, r5
  SPI_InitStruct.DataWidth = LL_SPI_DATAWIDTH_4BIT;
 800198c:	960a      	str	r6, [sp, #40]	@ 0x28
  SPI_InitStruct.CRCCalculation = LL_SPI_CRCCALCULATION_DISABLE;
 800198e:	e9cd 2310 	strd	r2, r3, [sp, #64]	@ 0x40
  SPI_InitStruct.ClockPhase = LL_SPI_PHASE_1EDGE;
 8001992:	e9cd 440b 	strd	r4, r4, [sp, #44]	@ 0x2c
  SPI_InitStruct.BitOrder = LL_SPI_MSB_FIRST;
 8001996:	e9cd 440e 	strd	r4, r4, [sp, #56]	@ 0x38
  LL_SPI_Init(SPI4, &SPI_InitStruct);
 800199a:	f002 fda1 	bl	80044e0 <LL_SPI_Init>
  MODIFY_REG(SPIx->CFG2, SPI_CFG2_SP, Standard);
 800199e:	68eb      	ldr	r3, [r5, #12]
 80019a0:	f423 1360 	bic.w	r3, r3, #3670016	@ 0x380000
 80019a4:	60eb      	str	r3, [r5, #12]
  SET_BIT(SPIx->CFG2, SPI_CFG2_SSOM);
 80019a6:	68eb      	ldr	r3, [r5, #12]
 80019a8:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 80019ac:	60eb      	str	r3, [r5, #12]
  LL_SPI_EnableNSSPulseMgt(SPI4);
  /* USER CODE BEGIN SPI4_Init 2 */

  /* USER CODE END SPI4_Init 2 */

}
 80019ae:	b012      	add	sp, #72	@ 0x48
 80019b0:	bd70      	pop	{r4, r5, r6, pc}
 80019b2:	bf00      	nop
 80019b4:	58024000 	.word	0x58024000
 80019b8:	58024400 	.word	0x58024400
 80019bc:	40013400 	.word	0x40013400
 80019c0:	58021000 	.word	0x58021000

080019c4 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80019c4:	4b0b      	ldr	r3, [pc, #44]	@ (80019f4 <HAL_MspInit+0x30>)

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 80019c6:	2200      	movs	r2, #0
 80019c8:	210f      	movs	r1, #15
 80019ca:	f06f 0001 	mvn.w	r0, #1
{
 80019ce:	b410      	push	{r4}
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80019d0:	f8d3 40f4 	ldr.w	r4, [r3, #244]	@ 0xf4
{
 80019d4:	b083      	sub	sp, #12
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80019d6:	f044 0402 	orr.w	r4, r4, #2
 80019da:	f8c3 40f4 	str.w	r4, [r3, #244]	@ 0xf4
 80019de:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 80019e2:	f003 0302 	and.w	r3, r3, #2
 80019e6:	9301      	str	r3, [sp, #4]
 80019e8:	9b01      	ldr	r3, [sp, #4]

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80019ea:	b003      	add	sp, #12
 80019ec:	f85d 4b04 	ldr.w	r4, [sp], #4
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 80019f0:	f000 bb74 	b.w	80020dc <HAL_NVIC_SetPriority>
 80019f4:	58024400 	.word	0x58024400

080019f8 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 80019f8:	e7fe      	b.n	80019f8 <NMI_Handler>
 80019fa:	bf00      	nop

080019fc <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80019fc:	e7fe      	b.n	80019fc <HardFault_Handler>
 80019fe:	bf00      	nop

08001a00 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8001a00:	e7fe      	b.n	8001a00 <MemManage_Handler>
 8001a02:	bf00      	nop

08001a04 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8001a04:	e7fe      	b.n	8001a04 <BusFault_Handler>
 8001a06:	bf00      	nop

08001a08 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8001a08:	e7fe      	b.n	8001a08 <UsageFault_Handler>
 8001a0a:	bf00      	nop

08001a0c <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8001a0c:	4770      	bx	lr
 8001a0e:	bf00      	nop

08001a10 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
 8001a10:	4770      	bx	lr
 8001a12:	bf00      	nop

08001a14 <PendSV_Handler>:
}

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
 8001a14:	4770      	bx	lr
 8001a16:	bf00      	nop

08001a18 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8001a18:	f000 bb2a 	b.w	8002070 <HAL_IncTick>

08001a1c <DMA1_Stream0_IRQHandler>:
  return ((READ_BIT(DMAx->LISR, DMA_LISR_TCIF0) == (DMA_LISR_TCIF0)) ? 1UL : 0UL);
 8001a1c:	4b10      	ldr	r3, [pc, #64]	@ (8001a60 <DMA1_Stream0_IRQHandler+0x44>)
 8001a1e:	681a      	ldr	r2, [r3, #0]
 8001a20:	0692      	lsls	r2, r2, #26
 8001a22:	d510      	bpl.n	8001a46 <DMA1_Stream0_IRQHandler+0x2a>
  WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CTCIF0);
 8001a24:	2220      	movs	r2, #32

/**
  * @brief This function handles DMA1 stream0 global interrupt.
  */
void DMA1_Stream0_IRQHandler(void)
{
 8001a26:	b570      	push	{r4, r5, r6, lr}
 8001a28:	609a      	str	r2, [r3, #8]
  return (READ_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_CT));
 8001a2a:	691b      	ldr	r3, [r3, #16]

  // usart1 rx
  if (LL_DMA_IsActiveFlag_TC0(DMA1))
  {
    LL_DMA_ClearFlag_TC0(DMA1);
    if (LL_DMA_GetCurrentTargetMem(DMA1, LL_DMA_STREAM_0) == LL_DMA_CURRENTTARGETMEM0)
 8001a2c:	031b      	lsls	r3, r3, #12
 8001a2e:	d40b      	bmi.n	8001a48 <DMA1_Stream0_IRQHandler+0x2c>
 8001a30:	4c0c      	ldr	r4, [pc, #48]	@ (8001a64 <DMA1_Stream0_IRQHandler+0x48>)
    {
      // at mem0, process mem1
      for (int i = 0; i < USART_REV_BUFF_SIZE; i++)
      {
        SCD_Rev1Byte(&scd_1, scd_rev_2buffer[1][i]);
 8001a32:	4e0d      	ldr	r6, [pc, #52]	@ (8001a68 <DMA1_Stream0_IRQHandler+0x4c>)
 8001a34:	1d25      	adds	r5, r4, #4
 8001a36:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8001a3a:	4630      	mov	r0, r6
 8001a3c:	f7ff fda6 	bl	800158c <SCD_Rev1Byte>
      for (int i = 0; i < USART_REV_BUFF_SIZE; i++)
 8001a40:	42ac      	cmp	r4, r5
 8001a42:	d1f8      	bne.n	8001a36 <DMA1_Stream0_IRQHandler+0x1a>
  /* USER CODE END DMA1_Stream0_IRQn 0 */

  /* USER CODE BEGIN DMA1_Stream0_IRQn 1 */

  /* USER CODE END DMA1_Stream0_IRQn 1 */
}
 8001a44:	bd70      	pop	{r4, r5, r6, pc}
    while (1)
 8001a46:	e7fe      	b.n	8001a46 <DMA1_Stream0_IRQHandler+0x2a>
 8001a48:	4c08      	ldr	r4, [pc, #32]	@ (8001a6c <DMA1_Stream0_IRQHandler+0x50>)
        SCD_Rev1Byte(&scd_1, scd_rev_2buffer[0][i]);
 8001a4a:	4e07      	ldr	r6, [pc, #28]	@ (8001a68 <DMA1_Stream0_IRQHandler+0x4c>)
 8001a4c:	1d25      	adds	r5, r4, #4
 8001a4e:	f814 1b01 	ldrb.w	r1, [r4], #1
 8001a52:	4630      	mov	r0, r6
 8001a54:	f7ff fd9a 	bl	800158c <SCD_Rev1Byte>
      for (int i = 0; i < USART_REV_BUFF_SIZE; i++)
 8001a58:	42ac      	cmp	r4, r5
 8001a5a:	d1f8      	bne.n	8001a4e <DMA1_Stream0_IRQHandler+0x32>
}
 8001a5c:	bd70      	pop	{r4, r5, r6, pc}
 8001a5e:	bf00      	nop
 8001a60:	40020000 	.word	0x40020000
 8001a64:	30000013 	.word	0x30000013
 8001a68:	24000270 	.word	0x24000270
 8001a6c:	30000010 	.word	0x30000010

08001a70 <DMA1_Stream1_IRQHandler>:
  return ((READ_BIT(DMAx->LISR, DMA_LISR_TCIF1) == (DMA_LISR_TCIF1)) ? 1UL : 0UL);
 8001a70:	4b11      	ldr	r3, [pc, #68]	@ (8001ab8 <DMA1_Stream1_IRQHandler+0x48>)
 8001a72:	681a      	ldr	r2, [r3, #0]
 8001a74:	0512      	lsls	r2, r2, #20
 8001a76:	d512      	bpl.n	8001a9e <DMA1_Stream1_IRQHandler+0x2e>
  WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CTCIF1);
 8001a78:	f44f 6200 	mov.w	r2, #2048	@ 0x800

/**
  * @brief This function handles DMA1 stream1 global interrupt.
  */
void DMA1_Stream1_IRQHandler(void)
{
 8001a7c:	b570      	push	{r4, r5, r6, lr}
 8001a7e:	609a      	str	r2, [r3, #8]
  return (READ_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_CT));
 8001a80:	6a9b      	ldr	r3, [r3, #40]	@ 0x28

  // usart1 tx
  if (LL_DMA_IsActiveFlag_TC1(DMA1))
  {
    LL_DMA_ClearFlag_TC1(DMA1);
    if (LL_DMA_GetCurrentTargetMem(DMA1, LL_DMA_STREAM_1) == LL_DMA_CURRENTTARGETMEM0)
 8001a82:	031b      	lsls	r3, r3, #12
 8001a84:	d40c      	bmi.n	8001aa0 <DMA1_Stream1_IRQHandler+0x30>
 8001a86:	4c0d      	ldr	r4, [pc, #52]	@ (8001abc <DMA1_Stream1_IRQHandler+0x4c>)
    {
      // at mem0, process mem1
      for (int i = 0; i < USART_SEND_BUFF_SIZE; i++)
      {
        scd_send_2buffer[1][i] = scd_send1Byte(&scd_1);
 8001a88:	4e0d      	ldr	r6, [pc, #52]	@ (8001ac0 <DMA1_Stream1_IRQHandler+0x50>)
 8001a8a:	f104 0508 	add.w	r5, r4, #8
 8001a8e:	4630      	mov	r0, r6
 8001a90:	f7ff fe5c 	bl	800174c <scd_send1Byte>
 8001a94:	f804 0f01 	strb.w	r0, [r4, #1]!
      for (int i = 0; i < USART_SEND_BUFF_SIZE; i++)
 8001a98:	42ac      	cmp	r4, r5
 8001a9a:	d1f8      	bne.n	8001a8e <DMA1_Stream1_IRQHandler+0x1e>
  /* USER CODE END DMA1_Stream1_IRQn 0 */

  /* USER CODE BEGIN DMA1_Stream1_IRQn 1 */

  /* USER CODE END DMA1_Stream1_IRQn 1 */
}
 8001a9c:	bd70      	pop	{r4, r5, r6, pc}
    while (1)
 8001a9e:	e7fe      	b.n	8001a9e <DMA1_Stream1_IRQHandler+0x2e>
 8001aa0:	4c08      	ldr	r4, [pc, #32]	@ (8001ac4 <DMA1_Stream1_IRQHandler+0x54>)
        scd_send_2buffer[0][i] = scd_send1Byte(&scd_1);
 8001aa2:	4e07      	ldr	r6, [pc, #28]	@ (8001ac0 <DMA1_Stream1_IRQHandler+0x50>)
 8001aa4:	f104 0508 	add.w	r5, r4, #8
 8001aa8:	4630      	mov	r0, r6
 8001aaa:	f7ff fe4f 	bl	800174c <scd_send1Byte>
 8001aae:	f804 0f01 	strb.w	r0, [r4, #1]!
      for (int i = 0; i < USART_SEND_BUFF_SIZE; i++)
 8001ab2:	42ac      	cmp	r4, r5
 8001ab4:	d1f8      	bne.n	8001aa8 <DMA1_Stream1_IRQHandler+0x38>
}
 8001ab6:	bd70      	pop	{r4, r5, r6, pc}
 8001ab8:	40020000 	.word	0x40020000
 8001abc:	30000007 	.word	0x30000007
 8001ac0:	24000270 	.word	0x24000270
 8001ac4:	2fffffff 	.word	0x2fffffff

08001ac8 <ETH_IRQHandler>:
void ETH_IRQHandler(void)
{
  /* USER CODE BEGIN ETH_IRQn 0 */

  /* USER CODE END ETH_IRQn 0 */
  HAL_ETH_IRQHandler(&heth);
 8001ac8:	4801      	ldr	r0, [pc, #4]	@ (8001ad0 <ETH_IRQHandler+0x8>)
 8001aca:	f000 bb65 	b.w	8002198 <HAL_ETH_IRQHandler>
 8001ace:	bf00      	nop
 8001ad0:	240000ac 	.word	0x240000ac

08001ad4 <OTG_HS_IRQHandler>:
void OTG_HS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_HS_IRQn 0 */

  /* USER CODE END OTG_HS_IRQn 0 */
  HAL_HCD_IRQHandler(&hhcd_USB_OTG_HS);
 8001ad4:	4801      	ldr	r0, [pc, #4]	@ (8001adc <OTG_HS_IRQHandler+0x8>)
 8001ad6:	f000 be23 	b.w	8002720 <HAL_HCD_IRQHandler>
 8001ada:	bf00      	nop
 8001adc:	24000c8c 	.word	0x24000c8c

08001ae0 <OTG_FS_IRQHandler>:
void OTG_FS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8001ae0:	4801      	ldr	r0, [pc, #4]	@ (8001ae8 <OTG_FS_IRQHandler+0x8>)
 8001ae2:	f001 bb23 	b.w	800312c <HAL_PCD_IRQHandler>
 8001ae6:	bf00      	nop
 8001ae8:	2400035c 	.word	0x2400035c

08001aec <_read>:
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8001aec:	b570      	push	{r4, r5, r6, lr}
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001aee:	1e16      	subs	r6, r2, #0
 8001af0:	dd07      	ble.n	8001b02 <_read+0x16>
 8001af2:	460c      	mov	r4, r1
 8001af4:	198d      	adds	r5, r1, r6
  {
    *ptr++ = __io_getchar();
 8001af6:	f3af 8000 	nop.w
 8001afa:	f804 0b01 	strb.w	r0, [r4], #1
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001afe:	42a5      	cmp	r5, r4
 8001b00:	d1f9      	bne.n	8001af6 <_read+0xa>
  }

  return len;
}
 8001b02:	4630      	mov	r0, r6
 8001b04:	bd70      	pop	{r4, r5, r6, pc}
 8001b06:	bf00      	nop

08001b08 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8001b08:	b570      	push	{r4, r5, r6, lr}
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001b0a:	1e16      	subs	r6, r2, #0
 8001b0c:	dd07      	ble.n	8001b1e <_write+0x16>
 8001b0e:	460c      	mov	r4, r1
 8001b10:	198d      	adds	r5, r1, r6
  {
    __io_putchar(*ptr++);
 8001b12:	f814 0b01 	ldrb.w	r0, [r4], #1
 8001b16:	f3af 8000 	nop.w
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001b1a:	42a5      	cmp	r5, r4
 8001b1c:	d1f9      	bne.n	8001b12 <_write+0xa>
  }
  return len;
}
 8001b1e:	4630      	mov	r0, r6
 8001b20:	bd70      	pop	{r4, r5, r6, pc}
 8001b22:	bf00      	nop

08001b24 <_close>:

int _close(int file)
{
  (void)file;
  return -1;
}
 8001b24:	f04f 30ff 	mov.w	r0, #4294967295
 8001b28:	4770      	bx	lr
 8001b2a:	bf00      	nop

08001b2c <_fstat>:


int _fstat(int file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
 8001b2c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
  return 0;
}
 8001b30:	2000      	movs	r0, #0
  st->st_mode = S_IFCHR;
 8001b32:	604b      	str	r3, [r1, #4]
}
 8001b34:	4770      	bx	lr
 8001b36:	bf00      	nop

08001b38 <_isatty>:

int _isatty(int file)
{
  (void)file;
  return 1;
}
 8001b38:	2001      	movs	r0, #1
 8001b3a:	4770      	bx	lr

08001b3c <_lseek>:
{
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
}
 8001b3c:	2000      	movs	r0, #0
 8001b3e:	4770      	bx	lr

08001b40 <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8001b40:	490d      	ldr	r1, [pc, #52]	@ (8001b78 <_sbrk+0x38>)
{
 8001b42:	4603      	mov	r3, r0
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8001b44:	4a0d      	ldr	r2, [pc, #52]	@ (8001b7c <_sbrk+0x3c>)
  if (NULL == __sbrk_heap_end)
 8001b46:	6808      	ldr	r0, [r1, #0]
{
 8001b48:	b510      	push	{r4, lr}
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8001b4a:	4c0d      	ldr	r4, [pc, #52]	@ (8001b80 <_sbrk+0x40>)
 8001b4c:	1b12      	subs	r2, r2, r4
  if (NULL == __sbrk_heap_end)
 8001b4e:	b120      	cbz	r0, 8001b5a <_sbrk+0x1a>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8001b50:	4403      	add	r3, r0
 8001b52:	4293      	cmp	r3, r2
 8001b54:	d807      	bhi.n	8001b66 <_sbrk+0x26>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 8001b56:	600b      	str	r3, [r1, #0]

  return (void *)prev_heap_end;
}
 8001b58:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 8001b5a:	4c0a      	ldr	r4, [pc, #40]	@ (8001b84 <_sbrk+0x44>)
 8001b5c:	4620      	mov	r0, r4
 8001b5e:	600c      	str	r4, [r1, #0]
  if (__sbrk_heap_end + incr > max_heap)
 8001b60:	4403      	add	r3, r0
 8001b62:	4293      	cmp	r3, r2
 8001b64:	d9f7      	bls.n	8001b56 <_sbrk+0x16>
    errno = ENOMEM;
 8001b66:	f005 fbff 	bl	8007368 <__errno>
 8001b6a:	220c      	movs	r2, #12
 8001b6c:	4603      	mov	r3, r0
    return (void *)-1;
 8001b6e:	f04f 30ff 	mov.w	r0, #4294967295
    errno = ENOMEM;
 8001b72:	601a      	str	r2, [r3, #0]
}
 8001b74:	bd10      	pop	{r4, pc}
 8001b76:	bf00      	nop
 8001b78:	24000350 	.word	0x24000350
 8001b7c:	20020000 	.word	0x20020000
 8001b80:	00001000 	.word	0x00001000
 8001b84:	240011b8 	.word	0x240011b8

08001b88 <SystemInit>:
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8001b88:	492e      	ldr	r1, [pc, #184]	@ (8001c44 <SystemInit+0xbc>)
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/

   /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 8001b8a:	4a2f      	ldr	r2, [pc, #188]	@ (8001c48 <SystemInit+0xc0>)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8001b8c:	f8d1 3088 	ldr.w	r3, [r1, #136]	@ 0x88
 8001b90:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
{
 8001b94:	b410      	push	{r4}
 8001b96:	b083      	sub	sp, #12
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8001b98:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 8001b9c:	6813      	ldr	r3, [r2, #0]
 8001b9e:	f003 030f 	and.w	r3, r3, #15
 8001ba2:	2b06      	cmp	r3, #6
 8001ba4:	d805      	bhi.n	8001bb2 <SystemInit+0x2a>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 8001ba6:	6813      	ldr	r3, [r2, #0]
 8001ba8:	f023 030f 	bic.w	r3, r3, #15
 8001bac:	f043 0307 	orr.w	r3, r3, #7
 8001bb0:	6013      	str	r3, [r2, #0]
  }

  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
 8001bb2:	4b26      	ldr	r3, [pc, #152]	@ (8001c4c <SystemInit+0xc4>)

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8001bb4:	2400      	movs	r4, #0

  /* Reset HSEON, HSECSSON, CSION, HSI48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
 8001bb6:	4a26      	ldr	r2, [pc, #152]	@ (8001c50 <SystemInit+0xc8>)
  RCC->CR |= RCC_CR_HSION;
 8001bb8:	6819      	ldr	r1, [r3, #0]

   /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 8001bba:	4823      	ldr	r0, [pc, #140]	@ (8001c48 <SystemInit+0xc0>)
  RCC->CR |= RCC_CR_HSION;
 8001bbc:	f041 0101 	orr.w	r1, r1, #1
 8001bc0:	6019      	str	r1, [r3, #0]
  RCC->CFGR = 0x00000000;
 8001bc2:	611c      	str	r4, [r3, #16]
  RCC->CR &= 0xEAF6ED7FU;
 8001bc4:	6819      	ldr	r1, [r3, #0]
 8001bc6:	400a      	ands	r2, r1
 8001bc8:	601a      	str	r2, [r3, #0]
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 8001bca:	6803      	ldr	r3, [r0, #0]
 8001bcc:	071b      	lsls	r3, r3, #28
 8001bce:	d505      	bpl.n	8001bdc <SystemInit+0x54>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 8001bd0:	6803      	ldr	r3, [r0, #0]
 8001bd2:	f023 030f 	bic.w	r3, r3, #15
 8001bd6:	f043 0307 	orr.w	r3, r3, #7
 8001bda:	6003      	str	r3, [r0, #0]
  }

#if defined(D3_SRAM_BASE)
  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
 8001bdc:	4b1b      	ldr	r3, [pc, #108]	@ (8001c4c <SystemInit+0xc4>)
 8001bde:	2200      	movs	r2, #0
  RCC->PLLCKSELR = 0x02020200;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x01FF0000;
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x01010280;
 8001be0:	491c      	ldr	r1, [pc, #112]	@ (8001c54 <SystemInit+0xcc>)
  RCC->PLLCFGR = 0x01FF0000;
 8001be2:	481d      	ldr	r0, [pc, #116]	@ (8001c58 <SystemInit+0xd0>)
  RCC->PLLCKSELR = 0x02020200;
 8001be4:	4c1d      	ldr	r4, [pc, #116]	@ (8001c5c <SystemInit+0xd4>)
  RCC->D1CFGR = 0x00000000;
 8001be6:	619a      	str	r2, [r3, #24]
  RCC->D2CFGR = 0x00000000;
 8001be8:	61da      	str	r2, [r3, #28]
  RCC->D3CFGR = 0x00000000;
 8001bea:	621a      	str	r2, [r3, #32]
  RCC->PLLCKSELR = 0x02020200;
 8001bec:	629c      	str	r4, [r3, #40]	@ 0x28
  RCC->PLLCFGR = 0x01FF0000;
 8001bee:	62d8      	str	r0, [r3, #44]	@ 0x2c
  RCC->PLL1DIVR = 0x01010280;
 8001bf0:	6319      	str	r1, [r3, #48]	@ 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
 8001bf2:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x01010280;
 8001bf4:	6399      	str	r1, [r3, #56]	@ 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
 8001bf6:	63da      	str	r2, [r3, #60]	@ 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x01010280;
 8001bf8:	6419      	str	r1, [r3, #64]	@ 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
 8001bfa:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8001bfc:	6819      	ldr	r1, [r3, #0]
  /* Disable all interrupts */
  RCC->CIER = 0x00000000;

#if (STM32H7_DEV_ID == 0x450UL)
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 8001bfe:	4818      	ldr	r0, [pc, #96]	@ (8001c60 <SystemInit+0xd8>)
  RCC->CR &= 0xFFFBFFFFU;
 8001c00:	f421 2180 	bic.w	r1, r1, #262144	@ 0x40000
 8001c04:	6019      	str	r1, [r3, #0]
  RCC->CIER = 0x00000000;
 8001c06:	661a      	str	r2, [r3, #96]	@ 0x60
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 8001c08:	6803      	ldr	r3, [r0, #0]
 8001c0a:	f36f 030f 	bfc	r3, #0, #16
 8001c0e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8001c12:	d203      	bcs.n	8001c1c <SystemInit+0x94>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
 8001c14:	4b13      	ldr	r3, [pc, #76]	@ (8001c64 <SystemInit+0xdc>)
 8001c16:	2201      	movs	r2, #1
 8001c18:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
#endif /* STM32H7_DEV_ID */

#if defined(DATA_IN_D2_SRAM)
  /* in case of initialized data in D2 SRAM (AHB SRAM), enable the D2 SRAM clock (AHB SRAM clock) */
#if defined(RCC_AHB2ENR_D2SRAM3EN)
  RCC->AHB2ENR |= (RCC_AHB2ENR_D2SRAM1EN | RCC_AHB2ENR_D2SRAM2EN | RCC_AHB2ENR_D2SRAM3EN);
 8001c1c:	4b0b      	ldr	r3, [pc, #44]	@ (8001c4c <SystemInit+0xc4>)
  /*
   * Disable the FMC bank1 (enabled after reset).
   * This, prevents CPU speculation access on this bank which blocks the use of FMC during
   * 24us. During this time the others FMC master (such as LTDC) cannot use it!
   */
  FMC_Bank1_R->BTCR[0] = 0x000030D2;
 8001c1e:	f243 00d2 	movw	r0, #12498	@ 0x30d2
 8001c22:	4911      	ldr	r1, [pc, #68]	@ (8001c68 <SystemInit+0xe0>)
  RCC->AHB2ENR |= (RCC_AHB2ENR_D2SRAM1EN | RCC_AHB2ENR_D2SRAM2EN | RCC_AHB2ENR_D2SRAM3EN);
 8001c24:	f8d3 20dc 	ldr.w	r2, [r3, #220]	@ 0xdc
 8001c28:	f042 4260 	orr.w	r2, r2, #3758096384	@ 0xe0000000
 8001c2c:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  tmpreg = RCC->AHB2ENR;
 8001c30:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 8001c34:	9301      	str	r3, [sp, #4]
  (void) tmpreg;
 8001c36:	9b01      	ldr	r3, [sp, #4]
  FMC_Bank1_R->BTCR[0] = 0x000030D2;
 8001c38:	6008      	str	r0, [r1, #0]
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#endif /*DUAL_CORE && CORE_CM4*/
}
 8001c3a:	b003      	add	sp, #12
 8001c3c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001c40:	4770      	bx	lr
 8001c42:	bf00      	nop
 8001c44:	e000ed00 	.word	0xe000ed00
 8001c48:	52002000 	.word	0x52002000
 8001c4c:	58024400 	.word	0x58024400
 8001c50:	eaf6ed7f 	.word	0xeaf6ed7f
 8001c54:	01010280 	.word	0x01010280
 8001c58:	01ff0000 	.word	0x01ff0000
 8001c5c:	02020200 	.word	0x02020200
 8001c60:	5c001000 	.word	0x5c001000
 8001c64:	51008000 	.word	0x51008000
 8001c68:	52004000 	.word	0x52004000

08001c6c <MX_USART1_UART_Init>:
/* USER CODE END 0 */

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
 8001c6c:	b570      	push	{r4, r5, r6, lr}

  /* USER CODE BEGIN USART1_Init 0 */

  /* USER CODE END USART1_Init 0 */

  LL_USART_InitTypeDef USART_InitStruct = {0};
 8001c6e:	2220      	movs	r2, #32
{
 8001c70:	b090      	sub	sp, #64	@ 0x40
  LL_USART_InitTypeDef USART_InitStruct = {0};
 8001c72:	2100      	movs	r1, #0

  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001c74:	2400      	movs	r4, #0
  LL_USART_InitTypeDef USART_InitStruct = {0};
 8001c76:	eb0d 0002 	add.w	r0, sp, r2

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  USART_InitStruct.PrescalerValue = LL_USART_PRESCALER_DIV1;
  USART_InitStruct.BaudRate = 460800;
 8001c7a:	f44f 26e1 	mov.w	r6, #460800	@ 0x70800
  LL_USART_InitTypeDef USART_InitStruct = {0};
 8001c7e:	f005 fb14 	bl	80072aa <memset>
 8001c82:	4968      	ldr	r1, [pc, #416]	@ (8001e24 <MX_USART1_UART_Init+0x1b8>)
  SET_BIT(RCC->APB2ENR, Periphs);
 8001c84:	4b68      	ldr	r3, [pc, #416]	@ (8001e28 <MX_USART1_UART_Init+0x1bc>)
  USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
  USART_InitStruct.Parity = LL_USART_PARITY_NONE;
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
 8001c86:	250c      	movs	r5, #12
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001c88:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8001c8c:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8001c90:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8001c94:	f8d1 2454 	ldr.w	r2, [r1, #1108]	@ 0x454
 8001c98:	f022 0238 	bic.w	r2, r2, #56	@ 0x38
 8001c9c:	f8c1 2454 	str.w	r2, [r1, #1108]	@ 0x454
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001ca0:	a902      	add	r1, sp, #8
 8001ca2:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
 8001ca6:	f042 0210 	orr.w	r2, r2, #16
 8001caa:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 8001cae:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
 8001cb2:	f002 0210 	and.w	r2, r2, #16
 8001cb6:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 8001cb8:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB4ENR, Periphs);
 8001cba:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8001cbe:	f042 0201 	orr.w	r2, r2, #1
 8001cc2:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  GPIO_InitStruct.Pin = LL_GPIO_PIN_9|LL_GPIO_PIN_10;
 8001cc6:	f44f 62c0 	mov.w	r2, #1536	@ 0x600
  tmpreg = READ_BIT(RCC->AHB4ENR, Periphs);
 8001cca:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8001cce:	9405      	str	r4, [sp, #20]
 8001cd0:	f003 0301 	and.w	r3, r3, #1
 8001cd4:	9300      	str	r3, [sp, #0]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8001cd6:	2302      	movs	r3, #2
  (void)tmpreg;
 8001cd8:	9800      	ldr	r0, [sp, #0]
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001cda:	4854      	ldr	r0, [pc, #336]	@ (8001e2c <MX_USART1_UART_Init+0x1c0>)
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8001cdc:	e9cd 2302 	strd	r2, r3, [sp, #8]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
 8001ce0:	2301      	movs	r3, #1
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8001ce2:	2200      	movs	r2, #0
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
 8001ce4:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8001ce6:	2307      	movs	r3, #7
 8001ce8:	e9cd 2306 	strd	r2, r3, [sp, #24]
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001cec:	f002 f84c 	bl	8003d88 <LL_GPIO_Init>
  MODIFY_REG(((DMAMUX_Channel_TypeDef *)(uint32_t)((uint32_t)DMAMUX1_Channel0 + (DMAMUX_CCR_SIZE * (Stream)) + (uint32_t)(DMAMUX_CCR_SIZE * LL_DMA_INSTANCE_TO_DMAMUX_CHANNEL(DMAx))))->CCR, DMAMUX_CxCR_DMAREQ_ID, Request);
 8001cf0:	4b4f      	ldr	r3, [pc, #316]	@ (8001e30 <MX_USART1_UART_Init+0x1c4>)
  USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;
  LL_USART_Init(USART1, &USART_InitStruct);
 8001cf2:	a908      	add	r1, sp, #32
 8001cf4:	484f      	ldr	r0, [pc, #316]	@ (8001e34 <MX_USART1_UART_Init+0x1c8>)
 8001cf6:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
 8001cfa:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 8001cfe:	f042 022a 	orr.w	r2, r2, #42	@ 0x2a
 8001d02:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_DIR, Direction);
 8001d06:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001d08:	f022 02c0 	bic.w	r2, r2, #192	@ 0xc0
 8001d0c:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8001d10:	629a      	str	r2, [r3, #40]	@ 0x28
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_PL, Priority);
 8001d12:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001d14:	f422 3240 	bic.w	r2, r2, #196608	@ 0x30000
 8001d18:	629a      	str	r2, [r3, #40]	@ 0x28
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_CIRC | DMA_SxCR_PFCTRL, Mode);
 8001d1a:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001d1c:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
 8001d20:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8001d24:	629a      	str	r2, [r3, #40]	@ 0x28
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_PINC, IncrementMode);
 8001d26:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001d28:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
 8001d2c:	629a      	str	r2, [r3, #40]	@ 0x28
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_MINC, IncrementMode);
 8001d2e:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001d30:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8001d34:	629a      	str	r2, [r3, #40]	@ 0x28
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_PSIZE, Size);
 8001d36:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001d38:	f422 52c0 	bic.w	r2, r2, #6144	@ 0x1800
 8001d3c:	629a      	str	r2, [r3, #40]	@ 0x28
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_MSIZE, Size);
 8001d3e:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8001d40:	f422 42c0 	bic.w	r2, r2, #24576	@ 0x6000
 8001d44:	629a      	str	r2, [r3, #40]	@ 0x28
  CLEAR_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->FCR, DMA_SxFCR_DMDIS);
 8001d46:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8001d48:	f022 0204 	bic.w	r2, r2, #4
 8001d4c:	63da      	str	r2, [r3, #60]	@ 0x3c
  MODIFY_REG(((DMAMUX_Channel_TypeDef *)(uint32_t)((uint32_t)DMAMUX1_Channel0 + (DMAMUX_CCR_SIZE * (Stream)) + (uint32_t)(DMAMUX_CCR_SIZE * LL_DMA_INSTANCE_TO_DMAMUX_CHANNEL(DMAx))))->CCR, DMAMUX_CxCR_DMAREQ_ID, Request);
 8001d4e:	f8d3 2800 	ldr.w	r2, [r3, #2048]	@ 0x800
 8001d52:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 8001d56:	f042 0229 	orr.w	r2, r2, #41	@ 0x29
 8001d5a:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_DIR, Direction);
 8001d5e:	691a      	ldr	r2, [r3, #16]
 8001d60:	f022 02c0 	bic.w	r2, r2, #192	@ 0xc0
 8001d64:	611a      	str	r2, [r3, #16]
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_PL, Priority);
 8001d66:	691a      	ldr	r2, [r3, #16]
 8001d68:	f422 3240 	bic.w	r2, r2, #196608	@ 0x30000
 8001d6c:	611a      	str	r2, [r3, #16]
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_CIRC | DMA_SxCR_PFCTRL, Mode);
 8001d6e:	691a      	ldr	r2, [r3, #16]
 8001d70:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
 8001d74:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8001d78:	611a      	str	r2, [r3, #16]
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_PINC, IncrementMode);
 8001d7a:	691a      	ldr	r2, [r3, #16]
 8001d7c:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
 8001d80:	611a      	str	r2, [r3, #16]
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_MINC, IncrementMode);
 8001d82:	691a      	ldr	r2, [r3, #16]
 8001d84:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8001d88:	611a      	str	r2, [r3, #16]
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_PSIZE, Size);
 8001d8a:	691a      	ldr	r2, [r3, #16]
 8001d8c:	f422 52c0 	bic.w	r2, r2, #6144	@ 0x1800
 8001d90:	611a      	str	r2, [r3, #16]
  MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_MSIZE, Size);
 8001d92:	691a      	ldr	r2, [r3, #16]
 8001d94:	f422 42c0 	bic.w	r2, r2, #24576	@ 0x6000
 8001d98:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->FCR, DMA_SxFCR_DMDIS);
 8001d9a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8001d9c:	f022 0204 	bic.w	r2, r2, #4
 8001da0:	625a      	str	r2, [r3, #36]	@ 0x24
  USART_InitStruct.BaudRate = 460800;
 8001da2:	e9cd 4608 	strd	r4, r6, [sp, #32]
  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
 8001da6:	e9cd 440a 	strd	r4, r4, [sp, #40]	@ 0x28
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
 8001daa:	e9cd 450c 	strd	r4, r5, [sp, #48]	@ 0x30
  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;
 8001dae:	e9cd 440e 	strd	r4, r4, [sp, #56]	@ 0x38
  LL_USART_Init(USART1, &USART_InitStruct);
 8001db2:	f002 fbed 	bl	8004590 <LL_USART_Init>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001db6:	4a1f      	ldr	r2, [pc, #124]	@ (8001e34 <MX_USART1_UART_Init+0x1c8>)
 8001db8:	f102 0308 	add.w	r3, r2, #8
 8001dbc:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_MODIFY_REG(USARTx->CR3, USART_CR3_TXFTCFG, Threshold << USART_CR3_TXFTCFG_Pos);
 8001dc0:	f023 4360 	bic.w	r3, r3, #3758096384	@ 0xe0000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001dc4:	f102 0008 	add.w	r0, r2, #8
 8001dc8:	e840 3100 	strex	r1, r3, [r0]
 8001dcc:	2900      	cmp	r1, #0
 8001dce:	d1f3      	bne.n	8001db8 <MX_USART1_UART_Init+0x14c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001dd0:	4a18      	ldr	r2, [pc, #96]	@ (8001e34 <MX_USART1_UART_Init+0x1c8>)
 8001dd2:	f102 0308 	add.w	r3, r2, #8
 8001dd6:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_MODIFY_REG(USARTx->CR3, USART_CR3_RXFTCFG, Threshold << USART_CR3_RXFTCFG_Pos);
 8001dda:	f023 6360 	bic.w	r3, r3, #234881024	@ 0xe000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001dde:	f102 0008 	add.w	r0, r2, #8
 8001de2:	e840 3100 	strex	r1, r3, [r0]
 8001de6:	2900      	cmp	r1, #0
 8001de8:	d1f3      	bne.n	8001dd2 <MX_USART1_UART_Init+0x166>
  CLEAR_BIT(USARTx->CR1, USART_CR1_FIFOEN);
 8001dea:	6813      	ldr	r3, [r2, #0]
  return ((READ_BIT(USARTx->ISR, USART_ISR_TEACK) == (USART_ISR_TEACK)) ? 1UL : 0UL);
 8001dec:	f101 4180 	add.w	r1, r1, #1073741824	@ 0x40000000
  CLEAR_BIT(USARTx->CR1, USART_CR1_FIFOEN);
 8001df0:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
  return ((READ_BIT(USARTx->ISR, USART_ISR_TEACK) == (USART_ISR_TEACK)) ? 1UL : 0UL);
 8001df4:	f501 3188 	add.w	r1, r1, #69632	@ 0x11000
  CLEAR_BIT(USARTx->CR1, USART_CR1_FIFOEN);
 8001df8:	6013      	str	r3, [r2, #0]
  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8001dfa:	6853      	ldr	r3, [r2, #4]
 8001dfc:	f423 4390 	bic.w	r3, r3, #18432	@ 0x4800
 8001e00:	6053      	str	r3, [r2, #4]
  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
 8001e02:	6893      	ldr	r3, [r2, #8]
 8001e04:	f023 032a 	bic.w	r3, r3, #42	@ 0x2a
 8001e08:	6093      	str	r3, [r2, #8]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 8001e0a:	6813      	ldr	r3, [r2, #0]
 8001e0c:	f043 0301 	orr.w	r3, r3, #1
 8001e10:	6013      	str	r3, [r2, #0]
  return ((READ_BIT(USARTx->ISR, USART_ISR_TEACK) == (USART_ISR_TEACK)) ? 1UL : 0UL);
 8001e12:	69cb      	ldr	r3, [r1, #28]
 8001e14:	029a      	lsls	r2, r3, #10
 8001e16:	d5fc      	bpl.n	8001e12 <MX_USART1_UART_Init+0x1a6>
  return ((READ_BIT(USARTx->ISR, USART_ISR_REACK) == (USART_ISR_REACK)) ? 1UL : 0UL);
 8001e18:	69cb      	ldr	r3, [r1, #28]
 8001e1a:	025b      	lsls	r3, r3, #9
 8001e1c:	d5f9      	bpl.n	8001e12 <MX_USART1_UART_Init+0x1a6>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 8001e1e:	b010      	add	sp, #64	@ 0x40
 8001e20:	bd70      	pop	{r4, r5, r6, pc}
 8001e22:	bf00      	nop
 8001e24:	58024000 	.word	0x58024000
 8001e28:	58024400 	.word	0x58024400
 8001e2c:	58020000 	.word	0x58020000
 8001e30:	40020000 	.word	0x40020000
 8001e34:	40011000 	.word	0x40011000

08001e38 <MX_USART2_UART_Init>:
/* USART2 init function */

void MX_USART2_UART_Init(void)
{
 8001e38:	b510      	push	{r4, lr}

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  LL_USART_InitTypeDef USART_InitStruct = {0};
 8001e3a:	2220      	movs	r2, #32
{
 8001e3c:	b090      	sub	sp, #64	@ 0x40
  LL_USART_InitTypeDef USART_InitStruct = {0};
 8001e3e:	2100      	movs	r1, #0

  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001e40:	2400      	movs	r4, #0
  LL_USART_InitTypeDef USART_InitStruct = {0};
 8001e42:	eb0d 0002 	add.w	r0, sp, r2
 8001e46:	f005 fa30 	bl	80072aa <memset>
 8001e4a:	493c      	ldr	r1, [pc, #240]	@ (8001f3c <MX_USART2_UART_Init+0x104>)
  SET_BIT(RCC->APB1LENR, Periphs);
 8001e4c:	4b3c      	ldr	r3, [pc, #240]	@ (8001f40 <MX_USART2_UART_Init+0x108>)
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001e4e:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8001e52:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8001e56:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8001e5a:	f8d1 2454 	ldr.w	r2, [r1, #1108]	@ 0x454
 8001e5e:	f022 0207 	bic.w	r2, r2, #7
 8001e62:	f8c1 2454 	str.w	r2, [r1, #1108]	@ 0x454
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  GPIO_InitStruct.Alternate = LL_GPIO_AF_7;
  LL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8001e66:	a902      	add	r1, sp, #8
 8001e68:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 8001e6c:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
 8001e70:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
  tmpreg = READ_BIT(RCC->APB1LENR, Periphs);
 8001e74:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 8001e78:	f402 3200 	and.w	r2, r2, #131072	@ 0x20000
 8001e7c:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 8001e7e:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB4ENR, Periphs);
 8001e80:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8001e84:	f042 0208 	orr.w	r2, r2, #8
 8001e88:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  GPIO_InitStruct.Pin = LL_GPIO_PIN_5|LL_GPIO_PIN_6;
 8001e8c:	2260      	movs	r2, #96	@ 0x60
  tmpreg = READ_BIT(RCC->AHB4ENR, Periphs);
 8001e8e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8001e92:	9405      	str	r4, [sp, #20]
 8001e94:	f003 0308 	and.w	r3, r3, #8
 8001e98:	9300      	str	r3, [sp, #0]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8001e9a:	2302      	movs	r3, #2
  (void)tmpreg;
 8001e9c:	9800      	ldr	r0, [sp, #0]
  LL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8001e9e:	4829      	ldr	r0, [pc, #164]	@ (8001f44 <MX_USART2_UART_Init+0x10c>)
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8001ea0:	e9cd 2302 	strd	r2, r3, [sp, #8]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
 8001ea4:	2301      	movs	r3, #1
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8001ea6:	2200      	movs	r2, #0
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
 8001ea8:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8001eaa:	2307      	movs	r3, #7
 8001eac:	e9cd 2306 	strd	r2, r3, [sp, #24]
  LL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8001eb0:	f001 ff6a 	bl	8003d88 <LL_GPIO_Init>

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  USART_InitStruct.PrescalerValue = LL_USART_PRESCALER_DIV1;
  USART_InitStruct.BaudRate = 460800;
 8001eb4:	f44f 22e1 	mov.w	r2, #460800	@ 0x70800
  USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
  USART_InitStruct.Parity = LL_USART_PARITY_NONE;
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
 8001eb8:	230c      	movs	r3, #12
  USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;
  LL_USART_Init(USART2, &USART_InitStruct);
 8001eba:	a908      	add	r1, sp, #32
 8001ebc:	4822      	ldr	r0, [pc, #136]	@ (8001f48 <MX_USART2_UART_Init+0x110>)
  USART_InitStruct.BaudRate = 460800;
 8001ebe:	e9cd 4208 	strd	r4, r2, [sp, #32]
  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
 8001ec2:	e9cd 440a 	strd	r4, r4, [sp, #40]	@ 0x28
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
 8001ec6:	e9cd 430c 	strd	r4, r3, [sp, #48]	@ 0x30
  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;
 8001eca:	e9cd 440e 	strd	r4, r4, [sp, #56]	@ 0x38
  LL_USART_Init(USART2, &USART_InitStruct);
 8001ece:	f002 fb5f 	bl	8004590 <LL_USART_Init>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001ed2:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8001ed6:	f502 6381 	add.w	r3, r2, #1032	@ 0x408
 8001eda:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_MODIFY_REG(USARTx->CR3, USART_CR3_TXFTCFG, Threshold << USART_CR3_TXFTCFG_Pos);
 8001ede:	f023 4360 	bic.w	r3, r3, #3758096384	@ 0xe0000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001ee2:	f502 6081 	add.w	r0, r2, #1032	@ 0x408
 8001ee6:	e840 3100 	strex	r1, r3, [r0]
 8001eea:	2900      	cmp	r1, #0
 8001eec:	d1f3      	bne.n	8001ed6 <MX_USART2_UART_Init+0x9e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001eee:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8001ef2:	f502 6381 	add.w	r3, r2, #1032	@ 0x408
 8001ef6:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_MODIFY_REG(USARTx->CR3, USART_CR3_RXFTCFG, Threshold << USART_CR3_RXFTCFG_Pos);
 8001efa:	f023 6360 	bic.w	r3, r3, #234881024	@ 0xe000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001efe:	f502 6081 	add.w	r0, r2, #1032	@ 0x408
 8001f02:	e840 3100 	strex	r1, r3, [r0]
 8001f06:	2900      	cmp	r1, #0
 8001f08:	d1f3      	bne.n	8001ef2 <MX_USART2_UART_Init+0xba>
  CLEAR_BIT(USARTx->CR1, USART_CR1_FIFOEN);
 8001f0a:	4b0f      	ldr	r3, [pc, #60]	@ (8001f48 <MX_USART2_UART_Init+0x110>)
 8001f0c:	681a      	ldr	r2, [r3, #0]
 8001f0e:	f022 5200 	bic.w	r2, r2, #536870912	@ 0x20000000
 8001f12:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8001f14:	685a      	ldr	r2, [r3, #4]
 8001f16:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 8001f1a:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
 8001f1c:	689a      	ldr	r2, [r3, #8]
 8001f1e:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 8001f22:	609a      	str	r2, [r3, #8]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 8001f24:	681a      	ldr	r2, [r3, #0]
 8001f26:	f042 0201 	orr.w	r2, r2, #1
 8001f2a:	601a      	str	r2, [r3, #0]
  return ((READ_BIT(USARTx->ISR, USART_ISR_TEACK) == (USART_ISR_TEACK)) ? 1UL : 0UL);
 8001f2c:	69da      	ldr	r2, [r3, #28]
 8001f2e:	0291      	lsls	r1, r2, #10
 8001f30:	d5fc      	bpl.n	8001f2c <MX_USART2_UART_Init+0xf4>
  return ((READ_BIT(USARTx->ISR, USART_ISR_REACK) == (USART_ISR_REACK)) ? 1UL : 0UL);
 8001f32:	69da      	ldr	r2, [r3, #28]
 8001f34:	0252      	lsls	r2, r2, #9
 8001f36:	d5f9      	bpl.n	8001f2c <MX_USART2_UART_Init+0xf4>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 8001f38:	b010      	add	sp, #64	@ 0x40
 8001f3a:	bd10      	pop	{r4, pc}
 8001f3c:	58024000 	.word	0x58024000
 8001f40:	58024400 	.word	0x58024400
 8001f44:	58020c00 	.word	0x58020c00
 8001f48:	40004400 	.word	0x40004400

08001f4c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
 8001f4c:	f8df d04c 	ldr.w	sp, [pc, #76]	@ 8001f9c <LoopFillZerobss+0x10>

/* Call the clock system initialization function.*/
  bl  SystemInit
 8001f50:	f7ff fe1a 	bl	8001b88 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8001f54:	4812      	ldr	r0, [pc, #72]	@ (8001fa0 <LoopFillZerobss+0x14>)
  ldr r1, =_edata
 8001f56:	4913      	ldr	r1, [pc, #76]	@ (8001fa4 <LoopFillZerobss+0x18>)
  ldr r2, =_sidata
 8001f58:	4a13      	ldr	r2, [pc, #76]	@ (8001fa8 <LoopFillZerobss+0x1c>)
  movs r3, #0
 8001f5a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001f5c:	e002      	b.n	8001f64 <LoopCopyDataInit>

08001f5e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001f5e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001f60:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001f62:	3304      	adds	r3, #4

08001f64 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001f64:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8001f66:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001f68:	d3f9      	bcc.n	8001f5e <CopyDataInit>

/* tyj ramFunc init */
  ldr r0, =_sRamFunc
 8001f6a:	4810      	ldr	r0, [pc, #64]	@ (8001fac <LoopFillZerobss+0x20>)
  ldr r1, =_eRamFunc
 8001f6c:	4910      	ldr	r1, [pc, #64]	@ (8001fb0 <LoopFillZerobss+0x24>)
  ldr r2, =_siFunc
 8001f6e:	4a11      	ldr	r2, [pc, #68]	@ (8001fb4 <LoopFillZerobss+0x28>)
  movs r3, #0
 8001f70:	2300      	movs	r3, #0
  b LoopCopyDataInit2
 8001f72:	e002      	b.n	8001f7a <LoopCopyDataInit2>

08001f74 <CopyDataInit2>:

CopyDataInit2:
  ldr r4, [r2, r3]
 8001f74:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001f76:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001f78:	3304      	adds	r3, #4

08001f7a <LoopCopyDataInit2>:

LoopCopyDataInit2:
  adds r4, r0, r3
 8001f7a:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8001f7c:	428c      	cmp	r4, r1
  bcc CopyDataInit2
 8001f7e:	d3f9      	bcc.n	8001f74 <CopyDataInit2>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001f80:	4a0d      	ldr	r2, [pc, #52]	@ (8001fb8 <LoopFillZerobss+0x2c>)
  ldr r4, =_ebss
 8001f82:	4c0e      	ldr	r4, [pc, #56]	@ (8001fbc <LoopFillZerobss+0x30>)
  movs r3, #0
 8001f84:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001f86:	e001      	b.n	8001f8c <LoopFillZerobss>

08001f88 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001f88:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001f8a:	3204      	adds	r2, #4

08001f8c <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8001f8c:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001f8e:	d3fb      	bcc.n	8001f88 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8001f90:	f005 f9f0 	bl	8007374 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001f94:	f7fe fc7e 	bl	8000894 <main>
  bx  lr
 8001f98:	4770      	bx	lr
 8001f9a:	0000      	.short	0x0000
  ldr   sp, =_estack      /* set stack pointer */
 8001f9c:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8001fa0:	24000000 	.word	0x24000000
  ldr r1, =_edata
 8001fa4:	24000090 	.word	0x24000090
  ldr r2, =_sidata
 8001fa8:	080087cc 	.word	0x080087cc
	...
  ldr r2, =_siFunc
 8001fb4:	0800885c 	.word	0x0800885c
  ldr r2, =_sbss
 8001fb8:	24000090 	.word	0x24000090
  ldr r4, =_ebss
 8001fbc:	240011b8 	.word	0x240011b8

08001fc0 <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001fc0:	e7fe      	b.n	8001fc0 <ADC3_IRQHandler>
	...

08001fc4 <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
 8001fc4:	4b0f      	ldr	r3, [pc, #60]	@ (8002004 <HAL_InitTick+0x40>)
 8001fc6:	781b      	ldrb	r3, [r3, #0]
 8001fc8:	b90b      	cbnz	r3, 8001fce <HAL_InitTick+0xa>
  {
    return HAL_ERROR;
 8001fca:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 8001fcc:	4770      	bx	lr
{
 8001fce:	b510      	push	{r4, lr}
 8001fd0:	4604      	mov	r4, r0
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
 8001fd2:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 8001fd6:	4a0c      	ldr	r2, [pc, #48]	@ (8002008 <HAL_InitTick+0x44>)
 8001fd8:	fbb0 f3f3 	udiv	r3, r0, r3
 8001fdc:	6810      	ldr	r0, [r2, #0]
 8001fde:	fbb0 f0f3 	udiv	r0, r0, r3
 8001fe2:	f000 f8b7 	bl	8002154 <HAL_SYSTICK_Config>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8001fe6:	2c0f      	cmp	r4, #15
 8001fe8:	d800      	bhi.n	8001fec <HAL_InitTick+0x28>
 8001fea:	b108      	cbz	r0, 8001ff0 <HAL_InitTick+0x2c>
    return HAL_ERROR;
 8001fec:	2001      	movs	r0, #1
}
 8001fee:	bd10      	pop	{r4, pc}
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8001ff0:	2200      	movs	r2, #0
 8001ff2:	4621      	mov	r1, r4
 8001ff4:	f04f 30ff 	mov.w	r0, #4294967295
 8001ff8:	f000 f870 	bl	80020dc <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8001ffc:	4b03      	ldr	r3, [pc, #12]	@ (800200c <HAL_InitTick+0x48>)
 8001ffe:	2000      	movs	r0, #0
 8002000:	601c      	str	r4, [r3, #0]
}
 8002002:	bd10      	pop	{r4, pc}
 8002004:	2400002c 	.word	0x2400002c
 8002008:	24000028 	.word	0x24000028
 800200c:	24000030 	.word	0x24000030

08002010 <HAL_Init>:
{
 8002010:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8002012:	2003      	movs	r0, #3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8002014:	4c12      	ldr	r4, [pc, #72]	@ (8002060 <HAL_Init+0x50>)
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8002016:	f000 f84f 	bl	80020b8 <HAL_NVIC_SetPriorityGrouping>
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800201a:	f001 fe53 	bl	8003cc4 <HAL_RCC_GetSysClockFreq>
 800201e:	4b11      	ldr	r3, [pc, #68]	@ (8002064 <HAL_Init+0x54>)
 8002020:	4911      	ldr	r1, [pc, #68]	@ (8002068 <HAL_Init+0x58>)
 8002022:	699a      	ldr	r2, [r3, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8002024:	699b      	ldr	r3, [r3, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8002026:	f3c2 2203 	ubfx	r2, r2, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800202a:	f003 030f 	and.w	r3, r3, #15
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800202e:	5c8a      	ldrb	r2, [r1, r2]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8002030:	5ccb      	ldrb	r3, [r1, r3]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8002032:	f002 021f 	and.w	r2, r2, #31
  SystemCoreClock = common_system_clock;
 8002036:	490d      	ldr	r1, [pc, #52]	@ (800206c <HAL_Init+0x5c>)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8002038:	f003 031f 	and.w	r3, r3, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800203c:	40d0      	lsrs	r0, r2
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800203e:	fa20 f303 	lsr.w	r3, r0, r3
  SystemCoreClock = common_system_clock;
 8002042:	6008      	str	r0, [r1, #0]
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8002044:	200f      	movs	r0, #15
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8002046:	6023      	str	r3, [r4, #0]
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8002048:	f7ff ffbc 	bl	8001fc4 <HAL_InitTick>
 800204c:	b110      	cbz	r0, 8002054 <HAL_Init+0x44>
    return HAL_ERROR;
 800204e:	2401      	movs	r4, #1
}
 8002050:	4620      	mov	r0, r4
 8002052:	bd10      	pop	{r4, pc}
 8002054:	4604      	mov	r4, r0
  HAL_MspInit();
 8002056:	f7ff fcb5 	bl	80019c4 <HAL_MspInit>
}
 800205a:	4620      	mov	r0, r4
 800205c:	bd10      	pop	{r4, pc}
 800205e:	bf00      	nop
 8002060:	24000024 	.word	0x24000024
 8002064:	58024400 	.word	0x58024400
 8002068:	08008738 	.word	0x08008738
 800206c:	24000028 	.word	0x24000028

08002070 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 8002070:	4a03      	ldr	r2, [pc, #12]	@ (8002080 <HAL_IncTick+0x10>)
 8002072:	4b04      	ldr	r3, [pc, #16]	@ (8002084 <HAL_IncTick+0x14>)
 8002074:	6811      	ldr	r1, [r2, #0]
 8002076:	781b      	ldrb	r3, [r3, #0]
 8002078:	440b      	add	r3, r1
 800207a:	6013      	str	r3, [r2, #0]
}
 800207c:	4770      	bx	lr
 800207e:	bf00      	nop
 8002080:	24000354 	.word	0x24000354
 8002084:	2400002c 	.word	0x2400002c

08002088 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8002088:	4b01      	ldr	r3, [pc, #4]	@ (8002090 <HAL_GetTick+0x8>)
 800208a:	6818      	ldr	r0, [r3, #0]
}
 800208c:	4770      	bx	lr
 800208e:	bf00      	nop
 8002090:	24000354 	.word	0x24000354

08002094 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8002094:	b538      	push	{r3, r4, r5, lr}
 8002096:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8002098:	f7ff fff6 	bl	8002088 <HAL_GetTick>
 800209c:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800209e:	1c63      	adds	r3, r4, #1
 80020a0:	d002      	beq.n	80020a8 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 80020a2:	4b04      	ldr	r3, [pc, #16]	@ (80020b4 <HAL_Delay+0x20>)
 80020a4:	781b      	ldrb	r3, [r3, #0]
 80020a6:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 80020a8:	f7ff ffee 	bl	8002088 <HAL_GetTick>
 80020ac:	1b40      	subs	r0, r0, r5
 80020ae:	42a0      	cmp	r0, r4
 80020b0:	d3fa      	bcc.n	80020a8 <HAL_Delay+0x14>
  {
  }
}
 80020b2:	bd38      	pop	{r3, r4, r5, pc}
 80020b4:	2400002c 	.word	0x2400002c

080020b8 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80020b8:	4906      	ldr	r1, [pc, #24]	@ (80020d4 <HAL_NVIC_SetPriorityGrouping+0x1c>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80020ba:	f64f 0cff 	movw	ip, #63743	@ 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80020be:	0200      	lsls	r0, r0, #8
  reg_value  =  (reg_value                                   |
 80020c0:	4b05      	ldr	r3, [pc, #20]	@ (80020d8 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80020c2:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80020c4:	f400 60e0 	and.w	r0, r0, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80020c8:	ea02 020c 	and.w	r2, r2, ip
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80020cc:	4310      	orrs	r0, r2
  reg_value  =  (reg_value                                   |
 80020ce:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 80020d0:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80020d2:	4770      	bx	lr
 80020d4:	e000ed00 	.word	0xe000ed00
 80020d8:	05fa0000 	.word	0x05fa0000

080020dc <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80020dc:	4b1a      	ldr	r3, [pc, #104]	@ (8002148 <HAL_NVIC_SetPriority+0x6c>)
 80020de:	68db      	ldr	r3, [r3, #12]
 80020e0:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80020e4:	b500      	push	{lr}
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80020e6:	f1c3 0e07 	rsb	lr, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80020ea:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80020ee:	f1be 0f04 	cmp.w	lr, #4
 80020f2:	bf28      	it	cs
 80020f4:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80020f8:	f1bc 0f06 	cmp.w	ip, #6
 80020fc:	d91a      	bls.n	8002134 <HAL_NVIC_SetPriority+0x58>
 80020fe:	f1a3 0c03 	sub.w	ip, r3, #3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8002102:	f04f 33ff 	mov.w	r3, #4294967295
 8002106:	fa03 f30c 	lsl.w	r3, r3, ip
 800210a:	ea22 0203 	bic.w	r2, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800210e:	f04f 33ff 	mov.w	r3, #4294967295
  if ((int32_t)(IRQn) >= 0)
 8002112:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002114:	fa03 f30e 	lsl.w	r3, r3, lr
 8002118:	ea21 0303 	bic.w	r3, r1, r3
 800211c:	fa03 f30c 	lsl.w	r3, r3, ip
 8002120:	ea43 0302 	orr.w	r3, r3, r2
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002124:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002128:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
 800212a:	db06      	blt.n	800213a <HAL_NVIC_SetPriority+0x5e>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800212c:	4a07      	ldr	r2, [pc, #28]	@ (800214c <HAL_NVIC_SetPriority+0x70>)
 800212e:	5413      	strb	r3, [r2, r0]
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8002130:	f85d fb04 	ldr.w	pc, [sp], #4
 8002134:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002136:	4694      	mov	ip, r2
 8002138:	e7e9      	b.n	800210e <HAL_NVIC_SetPriority+0x32>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800213a:	f000 000f 	and.w	r0, r0, #15
 800213e:	4a04      	ldr	r2, [pc, #16]	@ (8002150 <HAL_NVIC_SetPriority+0x74>)
 8002140:	5413      	strb	r3, [r2, r0]
 8002142:	f85d fb04 	ldr.w	pc, [sp], #4
 8002146:	bf00      	nop
 8002148:	e000ed00 	.word	0xe000ed00
 800214c:	e000e400 	.word	0xe000e400
 8002150:	e000ed14 	.word	0xe000ed14

08002154 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8002154:	1e43      	subs	r3, r0, #1
 8002156:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 800215a:	d301      	bcc.n	8002160 <HAL_SYSTICK_Config+0xc>
  {
    return (1UL);                                                   /* Reload value impossible */
 800215c:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 800215e:	4770      	bx	lr
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8002160:	f04f 22e0 	mov.w	r2, #3758153728	@ 0xe000e000
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8002164:	2000      	movs	r0, #0
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002166:	4905      	ldr	r1, [pc, #20]	@ (800217c <HAL_SYSTICK_Config+0x28>)
 8002168:	f04f 0cf0 	mov.w	ip, #240	@ 0xf0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800216c:	6153      	str	r3, [r2, #20]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800216e:	2307      	movs	r3, #7
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002170:	f881 c023 	strb.w	ip, [r1, #35]	@ 0x23
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8002174:	6190      	str	r0, [r2, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8002176:	6113      	str	r3, [r2, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8002178:	4770      	bx	lr
 800217a:	bf00      	nop
 800217c:	e000ed00 	.word	0xe000ed00

08002180 <HAL_ETH_TxCpltCallback>:
  * @brief  Tx Transfer completed callbacks.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
__weak void HAL_ETH_TxCpltCallback(ETH_HandleTypeDef *heth)
 8002180:	4770      	bx	lr
 8002182:	bf00      	nop

08002184 <HAL_ETH_RxCpltCallback>:
  * @brief  Rx Transfer completed callbacks.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
__weak void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
 8002184:	4770      	bx	lr
 8002186:	bf00      	nop

08002188 <HAL_ETH_ErrorCallback>:
  * @brief  Ethernet transfer error callbacks
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
__weak void HAL_ETH_ErrorCallback(ETH_HandleTypeDef *heth)
 8002188:	4770      	bx	lr
 800218a:	bf00      	nop

0800218c <HAL_ETH_PMTCallback>:
  * @brief  Ethernet Power Management module IT callback
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
__weak void HAL_ETH_PMTCallback(ETH_HandleTypeDef *heth)
 800218c:	4770      	bx	lr
 800218e:	bf00      	nop

08002190 <HAL_ETH_EEECallback>:
  * @brief  Energy Efficient Etherent IT callback
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
__weak void HAL_ETH_EEECallback(ETH_HandleTypeDef *heth)
 8002190:	4770      	bx	lr
 8002192:	bf00      	nop

08002194 <HAL_ETH_WakeUpCallback>:
  * @brief  ETH WAKEUP interrupt callback
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
__weak void HAL_ETH_WakeUpCallback(ETH_HandleTypeDef *heth)
 8002194:	4770      	bx	lr
 8002196:	bf00      	nop

08002198 <HAL_ETH_IRQHandler>:
  uint32_t mac_flag = READ_REG(heth->Instance->MACISR);
 8002198:	6802      	ldr	r2, [r0, #0]
  uint32_t dma_flag = READ_REG(heth->Instance->DMACSR);
 800219a:	f502 5380 	add.w	r3, r2, #4096	@ 0x1000
{
 800219e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t mac_flag = READ_REG(heth->Instance->MACISR);
 80021a2:	f8d2 60b0 	ldr.w	r6, [r2, #176]	@ 0xb0
  uint32_t exti_d1_flag = READ_REG(EXTI_D1->PR3);
 80021a6:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
  uint32_t dma_flag = READ_REG(heth->Instance->DMACSR);
 80021aa:	f8d3 5160 	ldr.w	r5, [r3, #352]	@ 0x160
{
 80021ae:	4604      	mov	r4, r0
  uint32_t dma_itsource = READ_REG(heth->Instance->DMACIER);
 80021b0:	f8d3 7134 	ldr.w	r7, [r3, #308]	@ 0x134
  if (((dma_flag & ETH_DMACSR_RI) != 0U) && ((dma_itsource & ETH_DMACIER_RIE) != 0U))
 80021b4:	0669      	lsls	r1, r5, #25
  uint32_t exti_d1_flag = READ_REG(EXTI_D1->PR3);
 80021b6:	f8d2 80a8 	ldr.w	r8, [r2, #168]	@ 0xa8
  if (((dma_flag & ETH_DMACSR_RI) != 0U) && ((dma_itsource & ETH_DMACIER_RIE) != 0U))
 80021ba:	d501      	bpl.n	80021c0 <HAL_ETH_IRQHandler+0x28>
 80021bc:	067a      	lsls	r2, r7, #25
 80021be:	d479      	bmi.n	80022b4 <HAL_ETH_IRQHandler+0x11c>
  if (((dma_flag & ETH_DMACSR_TI) != 0U) && ((dma_itsource & ETH_DMACIER_TIE) != 0U))
 80021c0:	07e9      	lsls	r1, r5, #31
 80021c2:	d501      	bpl.n	80021c8 <HAL_ETH_IRQHandler+0x30>
 80021c4:	07fa      	lsls	r2, r7, #31
 80021c6:	d46a      	bmi.n	800229e <HAL_ETH_IRQHandler+0x106>
  if (((dma_flag & ETH_DMACSR_AIS) != 0U) && ((dma_itsource & ETH_DMACIER_AIE) != 0U))
 80021c8:	046b      	lsls	r3, r5, #17
 80021ca:	d501      	bpl.n	80021d0 <HAL_ETH_IRQHandler+0x38>
 80021cc:	0478      	lsls	r0, r7, #17
 80021ce:	d40b      	bmi.n	80021e8 <HAL_ETH_IRQHandler+0x50>
  if (((mac_flag & ETH_MACIER_RXSTSIE) == ETH_MACIER_RXSTSIE) || \
 80021d0:	f416 4fc0 	tst.w	r6, #24576	@ 0x6000
 80021d4:	d123      	bne.n	800221e <HAL_ETH_IRQHandler+0x86>
  if ((mac_flag & ETH_MAC_PMT_IT) != 0U)
 80021d6:	06f2      	lsls	r2, r6, #27
 80021d8:	d437      	bmi.n	800224a <HAL_ETH_IRQHandler+0xb2>
  if ((mac_flag & ETH_MAC_LPI_IT) != 0U)
 80021da:	06b3      	lsls	r3, r6, #26
 80021dc:	d444      	bmi.n	8002268 <HAL_ETH_IRQHandler+0xd0>
  if ((exti_d1_flag & ETH_WAKEUP_EXTI_LINE) != 0U)
 80021de:	f418 0f80 	tst.w	r8, #4194304	@ 0x400000
 80021e2:	d151      	bne.n	8002288 <HAL_ETH_IRQHandler+0xf0>
}
 80021e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    heth->ErrorCode |= HAL_ETH_ERROR_DMA;
 80021e8:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
    if ((dma_flag & ETH_DMACSR_FBE) != 0U)
 80021ec:	04e9      	lsls	r1, r5, #19
    heth->ErrorCode |= HAL_ETH_ERROR_DMA;
 80021ee:	f043 0308 	orr.w	r3, r3, #8
 80021f2:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      heth->DMAErrorCode = READ_BIT(heth->Instance->DMACSR, (ETH_DMACSR_FBE | ETH_DMACSR_TPS | ETH_DMACSR_RPS));
 80021f6:	6823      	ldr	r3, [r4, #0]
 80021f8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80021fc:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
    if ((dma_flag & ETH_DMACSR_FBE) != 0U)
 8002200:	d45f      	bmi.n	80022c2 <HAL_ETH_IRQHandler+0x12a>
      heth->DMAErrorCode = READ_BIT(heth->Instance->DMACSR, (ETH_DMACSR_CDE | ETH_DMACSR_ETI | ETH_DMACSR_RWT |
 8002202:	f402 42cd 	and.w	r2, r2, #26240	@ 0x6680
 8002206:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
      __HAL_ETH_DMA_CLEAR_IT(heth, (ETH_DMACSR_CDE | ETH_DMACSR_ETI | ETH_DMACSR_RWT |
 800220a:	f44f 42cd 	mov.w	r2, #26240	@ 0x6680
 800220e:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160
    HAL_ETH_ErrorCallback(heth);
 8002212:	4620      	mov	r0, r4
 8002214:	f7ff ffb8 	bl	8002188 <HAL_ETH_ErrorCallback>
  if (((mac_flag & ETH_MACIER_RXSTSIE) == ETH_MACIER_RXSTSIE) || \
 8002218:	f416 4fc0 	tst.w	r6, #24576	@ 0x6000
 800221c:	d0db      	beq.n	80021d6 <HAL_ETH_IRQHandler+0x3e>
    heth->ErrorCode |= HAL_ETH_ERROR_MAC;
 800221e:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
    HAL_ETH_ErrorCallback(heth);
 8002222:	4620      	mov	r0, r4
    heth->MACErrorCode = READ_REG(heth->Instance->MACRXTXSR);
 8002224:	6822      	ldr	r2, [r4, #0]
    heth->ErrorCode |= HAL_ETH_ERROR_MAC;
 8002226:	f043 0310 	orr.w	r3, r3, #16
 800222a:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    heth->MACErrorCode = READ_REG(heth->Instance->MACRXTXSR);
 800222e:	f8d2 30b8 	ldr.w	r3, [r2, #184]	@ 0xb8
 8002232:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
    heth->gState = HAL_ETH_STATE_ERROR;
 8002236:	23e0      	movs	r3, #224	@ 0xe0
 8002238:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
    HAL_ETH_ErrorCallback(heth);
 800223c:	f7ff ffa4 	bl	8002188 <HAL_ETH_ErrorCallback>
    heth->MACErrorCode = (uint32_t)(0x0U);
 8002240:	2300      	movs	r3, #0
  if ((mac_flag & ETH_MAC_PMT_IT) != 0U)
 8002242:	06f2      	lsls	r2, r6, #27
    heth->MACErrorCode = (uint32_t)(0x0U);
 8002244:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
  if ((mac_flag & ETH_MAC_PMT_IT) != 0U)
 8002248:	d5c7      	bpl.n	80021da <HAL_ETH_IRQHandler+0x42>
    heth->MACWakeUpEvent = READ_BIT(heth->Instance->MACPCSR, (ETH_MACPCSR_RWKPRCVD | ETH_MACPCSR_MGKPRCVD));
 800224a:	6823      	ldr	r3, [r4, #0]
    HAL_ETH_PMTCallback(heth);
 800224c:	4620      	mov	r0, r4
    heth->MACWakeUpEvent = READ_BIT(heth->Instance->MACPCSR, (ETH_MACPCSR_RWKPRCVD | ETH_MACPCSR_MGKPRCVD));
 800224e:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
 8002252:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8002256:	f8c4 3094 	str.w	r3, [r4, #148]	@ 0x94
    HAL_ETH_PMTCallback(heth);
 800225a:	f7ff ff97 	bl	800218c <HAL_ETH_PMTCallback>
    heth->MACWakeUpEvent = (uint32_t)(0x0U);
 800225e:	2300      	movs	r3, #0
 8002260:	f8c4 3094 	str.w	r3, [r4, #148]	@ 0x94
  if ((mac_flag & ETH_MAC_LPI_IT) != 0U)
 8002264:	06b3      	lsls	r3, r6, #26
 8002266:	d5ba      	bpl.n	80021de <HAL_ETH_IRQHandler+0x46>
    heth->MACLPIEvent = READ_BIT(heth->Instance->MACLCSR, 0x0000000FU);
 8002268:	6823      	ldr	r3, [r4, #0]
    HAL_ETH_EEECallback(heth);
 800226a:	4620      	mov	r0, r4
    heth->MACLPIEvent = READ_BIT(heth->Instance->MACLCSR, 0x0000000FU);
 800226c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 8002270:	f003 030f 	and.w	r3, r3, #15
 8002274:	f8c4 3098 	str.w	r3, [r4, #152]	@ 0x98
    HAL_ETH_EEECallback(heth);
 8002278:	f7ff ff8a 	bl	8002190 <HAL_ETH_EEECallback>
    heth->MACLPIEvent = (uint32_t)(0x0U);
 800227c:	2300      	movs	r3, #0
  if ((exti_d1_flag & ETH_WAKEUP_EXTI_LINE) != 0U)
 800227e:	f418 0f80 	tst.w	r8, #4194304	@ 0x400000
    heth->MACLPIEvent = (uint32_t)(0x0U);
 8002282:	f8c4 3098 	str.w	r3, [r4, #152]	@ 0x98
  if ((exti_d1_flag & ETH_WAKEUP_EXTI_LINE) != 0U)
 8002286:	d0ad      	beq.n	80021e4 <HAL_ETH_IRQHandler+0x4c>
    __HAL_ETH_WAKEUP_EXTI_CLEAR_FLAG(ETH_WAKEUP_EXTI_LINE);
 8002288:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800228c:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
    HAL_ETH_WakeUpCallback(heth);
 8002290:	4620      	mov	r0, r4
    __HAL_ETH_WAKEUP_EXTI_CLEAR_FLAG(ETH_WAKEUP_EXTI_LINE);
 8002292:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
    HAL_ETH_WakeUpCallback(heth);
 8002296:	f7ff ff7d 	bl	8002194 <HAL_ETH_WakeUpCallback>
}
 800229a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMACSR_TI | ETH_DMACSR_NIS);
 800229e:	6823      	ldr	r3, [r4, #0]
 80022a0:	f248 0201 	movw	r2, #32769	@ 0x8001
    HAL_ETH_TxCpltCallback(heth);
 80022a4:	4620      	mov	r0, r4
    __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMACSR_TI | ETH_DMACSR_NIS);
 80022a6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80022aa:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160
    HAL_ETH_TxCpltCallback(heth);
 80022ae:	f7ff ff67 	bl	8002180 <HAL_ETH_TxCpltCallback>
 80022b2:	e789      	b.n	80021c8 <HAL_ETH_IRQHandler+0x30>
    __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMACSR_RI | ETH_DMACSR_NIS);
 80022b4:	f248 0240 	movw	r2, #32832	@ 0x8040
 80022b8:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160
    HAL_ETH_RxCpltCallback(heth);
 80022bc:	f7ff ff62 	bl	8002184 <HAL_ETH_RxCpltCallback>
 80022c0:	e77e      	b.n	80021c0 <HAL_ETH_IRQHandler+0x28>
      heth->DMAErrorCode = READ_BIT(heth->Instance->DMACSR, (ETH_DMACSR_FBE | ETH_DMACSR_TPS | ETH_DMACSR_RPS));
 80022c2:	f241 1102 	movw	r1, #4354	@ 0x1102
 80022c6:	400a      	ands	r2, r1
 80022c8:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
      __HAL_ETH_DMA_DISABLE_IT(heth, ETH_DMACIER_NIE | ETH_DMACIER_AIE);
 80022cc:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
 80022d0:	f422 4240 	bic.w	r2, r2, #49152	@ 0xc000
 80022d4:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134
      heth->gState = HAL_ETH_STATE_ERROR;
 80022d8:	23e0      	movs	r3, #224	@ 0xe0
 80022da:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
 80022de:	e798      	b.n	8002212 <HAL_ETH_IRQHandler+0x7a>

080022e0 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80022e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 80022e4:	680c      	ldr	r4, [r1, #0]
{
 80022e6:	b085      	sub	sp, #20
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 80022e8:	2c00      	cmp	r4, #0
 80022ea:	f000 80ac 	beq.w	8002446 <HAL_GPIO_Init+0x166>
  uint32_t position = 0x00U;
 80022ee:	2300      	movs	r3, #0
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 80022f0:	f04f 0b01 	mov.w	fp, #1
 80022f4:	fa0b fe03 	lsl.w	lr, fp, r3

    if (iocurrent != 0x00U)
 80022f8:	ea1e 0a04 	ands.w	sl, lr, r4
 80022fc:	f000 809e 	beq.w	800243c <HAL_GPIO_Init+0x15c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8002300:	684d      	ldr	r5, [r1, #4]
 8002302:	005a      	lsls	r2, r3, #1
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8002304:	2603      	movs	r6, #3
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8002306:	f005 0c03 	and.w	ip, r5, #3
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800230a:	fa06 f702 	lsl.w	r7, r6, r2
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800230e:	f10c 38ff 	add.w	r8, ip, #4294967295
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8002312:	43ff      	mvns	r7, r7
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8002314:	f1b8 0f01 	cmp.w	r8, #1
 8002318:	f240 8098 	bls.w	800244c <HAL_GPIO_Init+0x16c>
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
        GPIOx->OTYPER = temp;
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800231c:	f1bc 0f03 	cmp.w	ip, #3
 8002320:	f040 810b 	bne.w	800253a <HAL_GPIO_Init+0x25a>
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8002324:	fa0c f202 	lsl.w	r2, ip, r2
      temp = GPIOx->MODER;
 8002328:	f8d0 c000 	ldr.w	ip, [r0]
      GPIOx->MODER = temp;

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800232c:	f415 3f40 	tst.w	r5, #196608	@ 0x30000
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8002330:	ea0c 0707 	and.w	r7, ip, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8002334:	ea42 0207 	orr.w	r2, r2, r7
      GPIOx->MODER = temp;
 8002338:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800233a:	d07f      	beq.n	800243c <HAL_GPIO_Init+0x15c>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800233c:	4f85      	ldr	r7, [pc, #532]	@ (8002554 <HAL_GPIO_Init+0x274>)

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800233e:	f003 0c03 	and.w	ip, r3, #3
 8002342:	260f      	movs	r6, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002344:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8002348:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800234c:	f042 0202 	orr.w	r2, r2, #2
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8002350:	fa06 fe0c 	lsl.w	lr, r6, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8002354:	4e80      	ldr	r6, [pc, #512]	@ (8002558 <HAL_GPIO_Init+0x278>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002356:	f8c7 20f4 	str.w	r2, [r7, #244]	@ 0xf4
 800235a:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 800235e:	f023 0703 	bic.w	r7, r3, #3
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8002362:	42b0      	cmp	r0, r6
 8002364:	f107 47b0 	add.w	r7, r7, #1476395008	@ 0x58000000
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002368:	f002 0202 	and.w	r2, r2, #2
 800236c:	f507 6780 	add.w	r7, r7, #1024	@ 0x400
 8002370:	9203      	str	r2, [sp, #12]
 8002372:	9a03      	ldr	r2, [sp, #12]
        temp = SYSCFG->EXTICR[position >> 2U];
 8002374:	68ba      	ldr	r2, [r7, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8002376:	ea22 020e 	bic.w	r2, r2, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800237a:	d032      	beq.n	80023e2 <HAL_GPIO_Init+0x102>
 800237c:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 8002380:	42b0      	cmp	r0, r6
 8002382:	f000 80a9 	beq.w	80024d8 <HAL_GPIO_Init+0x1f8>
 8002386:	4e75      	ldr	r6, [pc, #468]	@ (800255c <HAL_GPIO_Init+0x27c>)
 8002388:	42b0      	cmp	r0, r6
 800238a:	f000 80ac 	beq.w	80024e6 <HAL_GPIO_Init+0x206>
 800238e:	f8df e1d0 	ldr.w	lr, [pc, #464]	@ 8002560 <HAL_GPIO_Init+0x280>
 8002392:	4570      	cmp	r0, lr
 8002394:	f000 8099 	beq.w	80024ca <HAL_GPIO_Init+0x1ea>
 8002398:	f8df e1c8 	ldr.w	lr, [pc, #456]	@ 8002564 <HAL_GPIO_Init+0x284>
 800239c:	4570      	cmp	r0, lr
 800239e:	f000 80b0 	beq.w	8002502 <HAL_GPIO_Init+0x222>
 80023a2:	f8df e1c4 	ldr.w	lr, [pc, #452]	@ 8002568 <HAL_GPIO_Init+0x288>
 80023a6:	4570      	cmp	r0, lr
 80023a8:	f000 80b2 	beq.w	8002510 <HAL_GPIO_Init+0x230>
 80023ac:	f8df e1bc 	ldr.w	lr, [pc, #444]	@ 800256c <HAL_GPIO_Init+0x28c>
 80023b0:	4570      	cmp	r0, lr
 80023b2:	f000 809f 	beq.w	80024f4 <HAL_GPIO_Init+0x214>
 80023b6:	f8df e1b8 	ldr.w	lr, [pc, #440]	@ 8002570 <HAL_GPIO_Init+0x290>
 80023ba:	4570      	cmp	r0, lr
 80023bc:	f000 80af 	beq.w	800251e <HAL_GPIO_Init+0x23e>
 80023c0:	f8df e1b0 	ldr.w	lr, [pc, #432]	@ 8002574 <HAL_GPIO_Init+0x294>
 80023c4:	4570      	cmp	r0, lr
 80023c6:	f000 80b1 	beq.w	800252c <HAL_GPIO_Init+0x24c>
 80023ca:	f8df e1ac 	ldr.w	lr, [pc, #428]	@ 8002578 <HAL_GPIO_Init+0x298>
 80023ce:	4570      	cmp	r0, lr
 80023d0:	bf0c      	ite	eq
 80023d2:	f04f 0e09 	moveq.w	lr, #9
 80023d6:	f04f 0e0a 	movne.w	lr, #10
 80023da:	fa0e fc0c 	lsl.w	ip, lr, ip
 80023de:	ea42 020c 	orr.w	r2, r2, ip
        SYSCFG->EXTICR[position >> 2U] = temp;
 80023e2:	60ba      	str	r2, [r7, #8]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 80023e4:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 80023e8:	02ee      	lsls	r6, r5, #11
        temp &= ~(iocurrent);
 80023ea:	ea6f 070a 	mvn.w	r7, sl
        temp = EXTI->RTSR1;
 80023ee:	6812      	ldr	r2, [r2, #0]
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
 80023f0:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
        temp &= ~(iocurrent);
 80023f4:	bf54      	ite	pl
 80023f6:	403a      	andpl	r2, r7
          temp |= iocurrent;
 80023f8:	ea4a 0202 	orrmi.w	r2, sl, r2
        EXTI->RTSR1 = temp;
 80023fc:	6032      	str	r2, [r6, #0]

        temp = EXTI->FTSR1;
 80023fe:	6872      	ldr	r2, [r6, #4]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8002400:	02ae      	lsls	r6, r5, #10
        {
          temp |= iocurrent;
        }
        EXTI->FTSR1 = temp;
 8002402:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
        temp &= ~(iocurrent);
 8002406:	bf54      	ite	pl
 8002408:	403a      	andpl	r2, r7
          temp |= iocurrent;
 800240a:	ea4a 0202 	orrmi.w	r2, sl, r2
        EXTI->FTSR1 = temp;
 800240e:	6072      	str	r2, [r6, #4]

        temp = EXTI_CurrentCPU->EMR1;
 8002410:	f8d6 2084 	ldr.w	r2, [r6, #132]	@ 0x84
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8002414:	03ae      	lsls	r6, r5, #14
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->EMR1 = temp;
 8002416:	f04f 46b0 	mov.w	r6, #1476395008	@ 0x58000000
        temp &= ~(iocurrent);
 800241a:	bf54      	ite	pl
 800241c:	403a      	andpl	r2, r7
          temp |= iocurrent;
 800241e:	ea4a 0202 	orrmi.w	r2, sl, r2

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8002422:	03ed      	lsls	r5, r5, #15
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->IMR1 = temp;
 8002424:	f04f 45b0 	mov.w	r5, #1476395008	@ 0x58000000
        EXTI_CurrentCPU->EMR1 = temp;
 8002428:	f8c6 2084 	str.w	r2, [r6, #132]	@ 0x84
        temp = EXTI_CurrentCPU->IMR1;
 800242c:	f8d6 2080 	ldr.w	r2, [r6, #128]	@ 0x80
        temp &= ~(iocurrent);
 8002430:	bf54      	ite	pl
 8002432:	403a      	andpl	r2, r7
          temp |= iocurrent;
 8002434:	ea4a 0202 	orrmi.w	r2, sl, r2
        EXTI_CurrentCPU->IMR1 = temp;
 8002438:	f8c5 2080 	str.w	r2, [r5, #128]	@ 0x80
      }
    }

    position++;
 800243c:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 800243e:	fa34 f203 	lsrs.w	r2, r4, r3
 8002442:	f47f af57 	bne.w	80022f4 <HAL_GPIO_Init+0x14>
  }
}
 8002446:	b005      	add	sp, #20
 8002448:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->OSPEEDR;
 800244c:	f8d0 9008 	ldr.w	r9, [r0, #8]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8002450:	f1bc 0f02 	cmp.w	ip, #2
        temp |= (GPIO_Init->Speed << (position * 2U));
 8002454:	68ce      	ldr	r6, [r1, #12]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8002456:	ea09 0907 	and.w	r9, r9, r7
        temp |= (GPIO_Init->Speed << (position * 2U));
 800245a:	fa06 f802 	lsl.w	r8, r6, r2
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800245e:	688e      	ldr	r6, [r1, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8002460:	ea48 0809 	orr.w	r8, r8, r9
        GPIOx->OSPEEDR = temp;
 8002464:	f8c0 8008 	str.w	r8, [r0, #8]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8002468:	f3c5 1800 	ubfx	r8, r5, #4, #1
        temp = GPIOx->OTYPER;
 800246c:	f8d0 9004 	ldr.w	r9, [r0, #4]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8002470:	fa08 f803 	lsl.w	r8, r8, r3
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8002474:	ea29 0e0e 	bic.w	lr, r9, lr
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8002478:	ea48 0e0e 	orr.w	lr, r8, lr
        GPIOx->OTYPER = temp;
 800247c:	f8c0 e004 	str.w	lr, [r0, #4]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8002480:	fa06 fe02 	lsl.w	lr, r6, r2
      temp = GPIOx->PUPDR;
 8002484:	f8d0 800c 	ldr.w	r8, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8002488:	ea08 0807 	and.w	r8, r8, r7
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800248c:	ea4e 0e08 	orr.w	lr, lr, r8
      GPIOx->PUPDR = temp;
 8002490:	f8c0 e00c 	str.w	lr, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8002494:	f47f af46 	bne.w	8002324 <HAL_GPIO_Init+0x44>
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8002498:	f003 0e07 	and.w	lr, r3, #7
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 800249c:	690e      	ldr	r6, [r1, #16]
        temp = GPIOx->AFR[position >> 3U];
 800249e:	ea4f 08d3 	mov.w	r8, r3, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80024a2:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 80024a6:	eb00 0888 	add.w	r8, r0, r8, lsl #2
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80024aa:	fa06 f60e 	lsl.w	r6, r6, lr
        temp = GPIOx->AFR[position >> 3U];
 80024ae:	f8d8 9020 	ldr.w	r9, [r8, #32]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80024b2:	9601      	str	r6, [sp, #4]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80024b4:	260f      	movs	r6, #15
 80024b6:	fa06 fe0e 	lsl.w	lr, r6, lr
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80024ba:	9e01      	ldr	r6, [sp, #4]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80024bc:	ea29 090e 	bic.w	r9, r9, lr
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80024c0:	ea46 0e09 	orr.w	lr, r6, r9
        GPIOx->AFR[position >> 3U] = temp;
 80024c4:	f8c8 e020 	str.w	lr, [r8, #32]
 80024c8:	e72c      	b.n	8002324 <HAL_GPIO_Init+0x44>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80024ca:	f04f 0e03 	mov.w	lr, #3
 80024ce:	fa0e fc0c 	lsl.w	ip, lr, ip
 80024d2:	ea42 020c 	orr.w	r2, r2, ip
 80024d6:	e784      	b.n	80023e2 <HAL_GPIO_Init+0x102>
 80024d8:	f04f 0e01 	mov.w	lr, #1
 80024dc:	fa0e fc0c 	lsl.w	ip, lr, ip
 80024e0:	ea42 020c 	orr.w	r2, r2, ip
 80024e4:	e77d      	b.n	80023e2 <HAL_GPIO_Init+0x102>
 80024e6:	f04f 0e02 	mov.w	lr, #2
 80024ea:	fa0e fc0c 	lsl.w	ip, lr, ip
 80024ee:	ea42 020c 	orr.w	r2, r2, ip
 80024f2:	e776      	b.n	80023e2 <HAL_GPIO_Init+0x102>
 80024f4:	f04f 0e06 	mov.w	lr, #6
 80024f8:	fa0e fc0c 	lsl.w	ip, lr, ip
 80024fc:	ea42 020c 	orr.w	r2, r2, ip
 8002500:	e76f      	b.n	80023e2 <HAL_GPIO_Init+0x102>
 8002502:	f04f 0e04 	mov.w	lr, #4
 8002506:	fa0e fc0c 	lsl.w	ip, lr, ip
 800250a:	ea42 020c 	orr.w	r2, r2, ip
 800250e:	e768      	b.n	80023e2 <HAL_GPIO_Init+0x102>
 8002510:	f04f 0e05 	mov.w	lr, #5
 8002514:	fa0e fc0c 	lsl.w	ip, lr, ip
 8002518:	ea42 020c 	orr.w	r2, r2, ip
 800251c:	e761      	b.n	80023e2 <HAL_GPIO_Init+0x102>
 800251e:	f04f 0e07 	mov.w	lr, #7
 8002522:	fa0e fc0c 	lsl.w	ip, lr, ip
 8002526:	ea42 020c 	orr.w	r2, r2, ip
 800252a:	e75a      	b.n	80023e2 <HAL_GPIO_Init+0x102>
 800252c:	f04f 0e08 	mov.w	lr, #8
 8002530:	fa0e fc0c 	lsl.w	ip, lr, ip
 8002534:	ea42 020c 	orr.w	r2, r2, ip
 8002538:	e753      	b.n	80023e2 <HAL_GPIO_Init+0x102>
      temp = GPIOx->PUPDR;
 800253a:	f8d0 800c 	ldr.w	r8, [r0, #12]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800253e:	688e      	ldr	r6, [r1, #8]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8002540:	ea08 0807 	and.w	r8, r8, r7
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8002544:	fa06 fe02 	lsl.w	lr, r6, r2
 8002548:	ea4e 0e08 	orr.w	lr, lr, r8
      GPIOx->PUPDR = temp;
 800254c:	f8c0 e00c 	str.w	lr, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8002550:	e6e8      	b.n	8002324 <HAL_GPIO_Init+0x44>
 8002552:	bf00      	nop
 8002554:	58024400 	.word	0x58024400
 8002558:	58020000 	.word	0x58020000
 800255c:	58020800 	.word	0x58020800
 8002560:	58020c00 	.word	0x58020c00
 8002564:	58021000 	.word	0x58021000
 8002568:	58021400 	.word	0x58021400
 800256c:	58021800 	.word	0x58021800
 8002570:	58021c00 	.word	0x58021c00
 8002574:	58022000 	.word	0x58022000
 8002578:	58022400 	.word	0x58022400

0800257c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800257c:	b902      	cbnz	r2, 8002580 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 800257e:	0409      	lsls	r1, r1, #16
 8002580:	6181      	str	r1, [r0, #24]
  }
}
 8002582:	4770      	bx	lr

08002584 <HAL_HCD_HC_Init>:
  *          This parameter can be a value from 0 to32K
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_HC_Init(HCD_HandleTypeDef *hhcd, uint8_t ch_num, uint8_t epnum,
                                  uint8_t dev_address, uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 8002584:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002588:	469b      	mov	fp, r3
  HAL_StatusTypeDef status;
  uint32_t HostCoreSpeed;
  uint32_t HCcharMps = mps;

  __HAL_LOCK(hhcd);
 800258a:	f890 33d4 	ldrb.w	r3, [r0, #980]	@ 0x3d4
{
 800258e:	b085      	sub	sp, #20
  __HAL_LOCK(hhcd);
 8002590:	2b01      	cmp	r3, #1
{
 8002592:	f89d 8038 	ldrb.w	r8, [sp, #56]	@ 0x38
 8002596:	f89d 703c 	ldrb.w	r7, [sp, #60]	@ 0x3c
 800259a:	f8bd 9040 	ldrh.w	r9, [sp, #64]	@ 0x40
  __HAL_LOCK(hhcd);
 800259e:	d04b      	beq.n	8002638 <HAL_HCD_HC_Init+0xb4>
  hhcd->hc[ch_num].do_ping = 0U;
 80025a0:	2600      	movs	r6, #0
 80025a2:	460d      	mov	r5, r1
 80025a4:	4604      	mov	r4, r0
  hhcd->hc[ch_num].dev_addr = dev_address;
  hhcd->hc[ch_num].ch_num = ch_num;
  hhcd->hc[ch_num].ep_type = ep_type;
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
 80025a6:	f002 007f 	and.w	r0, r2, #127	@ 0x7f
  hhcd->hc[ch_num].dev_addr = dev_address;
 80025aa:	4633      	mov	r3, r6
  hhcd->hc[ch_num].ep_type = ep_type;
 80025ac:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 80025b0:	4692      	mov	sl, r2

  (void)HAL_HCD_HC_ClearHubInfo(hhcd, ch_num);

  if ((epnum & 0x80U) == 0x80U)
 80025b2:	09d2      	lsrs	r2, r2, #7
  hhcd->hc[ch_num].dev_addr = dev_address;
 80025b4:	f36b 0307 	bfi	r3, fp, #0, #8
 80025b8:	f365 230f 	bfi	r3, r5, #8, #8
 80025bc:	f360 4317 	bfi	r3, r0, #16, #8
  hhcd->hc[ch_num].ep_type = ep_type;
 80025c0:	0088      	lsls	r0, r1, #2
 80025c2:	eb04 0181 	add.w	r1, r4, r1, lsl #2
  hhcd->hc[ch_num].dev_addr = dev_address;
 80025c6:	f362 631f 	bfi	r3, r2, #24, #8
  __HAL_LOCK(hhcd);
 80025ca:	2201      	movs	r2, #1
 80025cc:	f884 23d4 	strb.w	r2, [r4, #980]	@ 0x3d4
  hhcd->hc[ch_num].do_ping = 0U;
 80025d0:	f100 0210 	add.w	r2, r0, #16
HAL_StatusTypeDef HAL_HCD_HC_ClearHubInfo(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
{
  hhcd->hc[ch_num].do_ssplit = 0U;
  hhcd->hc[ch_num].do_csplit = 0U;
  hhcd->hc[ch_num].hub_addr = 0U;
  hhcd->hc[ch_num].hub_port_nbr = 0U;
 80025d4:	3020      	adds	r0, #32
  hhcd->hc[ch_num].ep_type = ep_type;
 80025d6:	f881 7026 	strb.w	r7, [r1, #38]	@ 0x26
  hhcd->hc[ch_num].do_ping = 0U;
 80025da:	4422      	add	r2, r4
  hhcd->hc[ch_num].hub_port_nbr = 0U;
 80025dc:	4420      	add	r0, r4
  hhcd->hc[ch_num].do_ping = 0U;
 80025de:	f8a2 6009 	strh.w	r6, [r2, #9]
  hhcd->hc[ch_num].do_csplit = 0U;
 80025e2:	76ce      	strb	r6, [r1, #27]
  hhcd->hc[ch_num].hub_port_nbr = 0U;
 80025e4:	8086      	strh	r6, [r0, #4]
  hhcd->hc[ch_num].ep_type = ep_type;
 80025e6:	012e      	lsls	r6, r5, #4
  hhcd->hc[ch_num].dev_addr = dev_address;
 80025e8:	6053      	str	r3, [r2, #4]
  HostCoreSpeed = USB_GetHostSpeed(hhcd->Instance);
 80025ea:	6820      	ldr	r0, [r4, #0]
 80025ec:	f002 fc6c 	bl	8004ec8 <USB_GetHostSpeed>
  if (ep_type == EP_TYPE_ISOC)
 80025f0:	2f01      	cmp	r7, #1
 80025f2:	d016      	beq.n	8002622 <HAL_HCD_HC_Init+0x9e>
  hhcd->hc[ch_num].speed = speed;
 80025f4:	1b70      	subs	r0, r6, r5
  status =  USB_HC_Init(hhcd->Instance, ch_num, epnum,
 80025f6:	465b      	mov	r3, fp
 80025f8:	4652      	mov	r2, sl
 80025fa:	4629      	mov	r1, r5
  hhcd->hc[ch_num].speed = speed;
 80025fc:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8002600:	f880 8018 	strb.w	r8, [r0, #24]
  hhcd->hc[ch_num].max_packet = (uint16_t)HCcharMps;
 8002604:	f8a0 9028 	strh.w	r9, [r0, #40]	@ 0x28
  status =  USB_HC_Init(hhcd->Instance, ch_num, epnum,
 8002608:	f8cd 8000 	str.w	r8, [sp]
 800260c:	e9cd 7901 	strd	r7, r9, [sp, #4]
 8002610:	6820      	ldr	r0, [r4, #0]
 8002612:	f002 fc65 	bl	8004ee0 <USB_HC_Init>
  __HAL_UNLOCK(hhcd);
 8002616:	2300      	movs	r3, #0
 8002618:	f884 33d4 	strb.w	r3, [r4, #980]	@ 0x3d4
}
 800261c:	b005      	add	sp, #20
 800261e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if ((speed == HCD_DEVICE_SPEED_FULL) && (HostCoreSpeed == HPRT0_PRTSPD_HIGH_SPEED))
 8002622:	f1b8 0f01 	cmp.w	r8, #1
 8002626:	d1e5      	bne.n	80025f4 <HAL_HCD_HC_Init+0x70>
 8002628:	2800      	cmp	r0, #0
 800262a:	d1e3      	bne.n	80025f4 <HAL_HCD_HC_Init+0x70>
  hhcd->hc[ch_num].max_packet = (uint16_t)HCcharMps;
 800262c:	f1b9 0fbc 	cmp.w	r9, #188	@ 0xbc
 8002630:	bf28      	it	cs
 8002632:	f04f 09bc 	movcs.w	r9, #188	@ 0xbc
 8002636:	e7dd      	b.n	80025f4 <HAL_HCD_HC_Init+0x70>
  __HAL_LOCK(hhcd);
 8002638:	2002      	movs	r0, #2
}
 800263a:	b005      	add	sp, #20
 800263c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08002640 <HAL_HCD_HC_SubmitRequest>:
{
 8002640:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002642:	468e      	mov	lr, r1
  hhcd->hc[ch_num].ep_is_in = direction;
 8002644:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
{
 8002648:	f89d 6014 	ldrb.w	r6, [sp, #20]
  hhcd->hc[ch_num].ep_is_in = direction;
 800264c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
{
 8002650:	9d06      	ldr	r5, [sp, #24]
 8002652:	f8bd 401c 	ldrh.w	r4, [sp, #28]
  hhcd->hc[ch_num].ep_is_in = direction;
 8002656:	ea4f 1c0e 	mov.w	ip, lr, lsl #4
{
 800265a:	f89d 7020 	ldrb.w	r7, [sp, #32]
  hhcd->hc[ch_num].ep_is_in = direction;
 800265e:	75ca      	strb	r2, [r1, #23]
  hhcd->hc[ch_num].ep_type  = ep_type;
 8002660:	f881 3026 	strb.w	r3, [r1, #38]	@ 0x26
  if (token == 0U)
 8002664:	b9fe      	cbnz	r6, 80026a6 <HAL_HCD_HC_SubmitRequest+0x66>
    hhcd->hc[ch_num].do_ping = do_ping;
 8002666:	2603      	movs	r6, #3
  switch (ep_type)
 8002668:	2b02      	cmp	r3, #2
    hhcd->hc[ch_num].do_ping = do_ping;
 800266a:	764f      	strb	r7, [r1, #25]
 800266c:	f881 602a 	strb.w	r6, [r1, #42]	@ 0x2a
  switch (ep_type)
 8002670:	d022      	beq.n	80026b8 <HAL_HCD_HC_SubmitRequest+0x78>
 8002672:	42b3      	cmp	r3, r6
 8002674:	d020      	beq.n	80026b8 <HAL_HCD_HC_SubmitRequest+0x78>
 8002676:	2b01      	cmp	r3, #1
 8002678:	d02a      	beq.n	80026d0 <HAL_HCD_HC_SubmitRequest+0x90>
  hhcd->hc[ch_num].xfer_buff = pbuff;
 800267a:	ebac 030e 	sub.w	r3, ip, lr
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 800267e:	213c      	movs	r1, #60	@ 0x3c
  hhcd->hc[ch_num].urb_state = URB_IDLE;
 8002680:	eb00 0283 	add.w	r2, r0, r3, lsl #2
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8002684:	fb01 010e 	mla	r1, r1, lr, r0
  hhcd->hc[ch_num].xfer_len  = length;
 8002688:	6354      	str	r4, [r2, #52]	@ 0x34
  hhcd->hc[ch_num].xfer_count = 0U;
 800268a:	2400      	movs	r4, #0
  hhcd->hc[ch_num].ch_num = ch_num;
 800268c:	f882 e015 	strb.w	lr, [r2, #21]
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8002690:	3114      	adds	r1, #20
  hhcd->hc[ch_num].urb_state = URB_IDLE;
 8002692:	f8a2 404c 	strh.w	r4, [r2, #76]	@ 0x4c
  hhcd->hc[ch_num].xfer_buff = pbuff;
 8002696:	62d5      	str	r5, [r2, #44]	@ 0x2c
  hhcd->hc[ch_num].xfer_count = 0U;
 8002698:	6394      	str	r4, [r2, #56]	@ 0x38
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 800269a:	7982      	ldrb	r2, [r0, #6]
 800269c:	6800      	ldr	r0, [r0, #0]
}
 800269e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 80026a2:	f002 bcb3 	b.w	800500c <USB_HC_StartXfer>
 80026a6:	2702      	movs	r7, #2
 80026a8:	f881 702a 	strb.w	r7, [r1, #42]	@ 0x2a
  switch (ep_type)
 80026ac:	2b03      	cmp	r3, #3
 80026ae:	d8e4      	bhi.n	800267a <HAL_HCD_HC_SubmitRequest+0x3a>
 80026b0:	e8df f003 	tbb	[pc, r3]
 80026b4:	02020e1e 	.word	0x02020e1e
        if (hhcd->hc[ch_num].toggle_out == 0U)
 80026b8:	ebac 030e 	sub.w	r3, ip, lr
 80026bc:	eb00 0383 	add.w	r3, r0, r3, lsl #2
      if (direction == 0U)
 80026c0:	b972      	cbnz	r2, 80026e0 <HAL_HCD_HC_SubmitRequest+0xa0>
        if (hhcd->hc[ch_num].toggle_out == 0U)
 80026c2:	f893 103d 	ldrb.w	r1, [r3, #61]	@ 0x3d
 80026c6:	b141      	cbz	r1, 80026da <HAL_HCD_HC_SubmitRequest+0x9a>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 80026c8:	2202      	movs	r2, #2
 80026ca:	f883 202a 	strb.w	r2, [r3, #42]	@ 0x2a
 80026ce:	e7d4      	b.n	800267a <HAL_HCD_HC_SubmitRequest+0x3a>
      hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 80026d0:	ebac 030e 	sub.w	r3, ip, lr
 80026d4:	2200      	movs	r2, #0
 80026d6:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80026da:	f883 202a 	strb.w	r2, [r3, #42]	@ 0x2a
      break;
 80026de:	e7cc      	b.n	800267a <HAL_HCD_HC_SubmitRequest+0x3a>
        if (hhcd->hc[ch_num].toggle_in == 0U)
 80026e0:	f893 203c 	ldrb.w	r2, [r3, #60]	@ 0x3c
 80026e4:	2a00      	cmp	r2, #0
 80026e6:	d0f8      	beq.n	80026da <HAL_HCD_HC_SubmitRequest+0x9a>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 80026e8:	2202      	movs	r2, #2
 80026ea:	f883 202a 	strb.w	r2, [r3, #42]	@ 0x2a
 80026ee:	e7c4      	b.n	800267a <HAL_HCD_HC_SubmitRequest+0x3a>
      if (token == 1U) /* send data */
 80026f0:	2e01      	cmp	r6, #1
 80026f2:	d1c2      	bne.n	800267a <HAL_HCD_HC_SubmitRequest+0x3a>
            hhcd->hc[ch_num].toggle_out = 1U;
 80026f4:	ebac 030e 	sub.w	r3, ip, lr
 80026f8:	eb00 0383 	add.w	r3, r0, r3, lsl #2
        if (direction == 0U)
 80026fc:	b91a      	cbnz	r2, 8002706 <HAL_HCD_HC_SubmitRequest+0xc6>
          if (length == 0U)
 80026fe:	b954      	cbnz	r4, 8002716 <HAL_HCD_HC_SubmitRequest+0xd6>
            hhcd->hc[ch_num].toggle_out = 1U;
 8002700:	f883 603d 	strb.w	r6, [r3, #61]	@ 0x3d
          if (hhcd->hc[ch_num].toggle_out == 0U)
 8002704:	e7b9      	b.n	800267a <HAL_HCD_HC_SubmitRequest+0x3a>
          if (hhcd->hc[ch_num].do_ssplit == 1U)
 8002706:	7e9a      	ldrb	r2, [r3, #26]
 8002708:	2a01      	cmp	r2, #1
 800270a:	d1b6      	bne.n	800267a <HAL_HCD_HC_SubmitRequest+0x3a>
            if (hhcd->hc[ch_num].toggle_in == 0U)
 800270c:	f893 203c 	ldrb.w	r2, [r3, #60]	@ 0x3c
 8002710:	2a00      	cmp	r2, #0
 8002712:	d1b2      	bne.n	800267a <HAL_HCD_HC_SubmitRequest+0x3a>
 8002714:	e7e1      	b.n	80026da <HAL_HCD_HC_SubmitRequest+0x9a>
          if (hhcd->hc[ch_num].toggle_out == 0U)
 8002716:	f893 103d 	ldrb.w	r1, [r3, #61]	@ 0x3d
 800271a:	2900      	cmp	r1, #0
 800271c:	d0dd      	beq.n	80026da <HAL_HCD_HC_SubmitRequest+0x9a>
 800271e:	e7ac      	b.n	800267a <HAL_HCD_HC_SubmitRequest+0x3a>

08002720 <HAL_HCD_IRQHandler>:
{
 8002720:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 8002724:	6805      	ldr	r5, [r0, #0]
{
 8002726:	b085      	sub	sp, #20
 8002728:	4604      	mov	r4, r0
  if (USB_GetMode(hhcd->Instance) == USB_OTG_MODE_HOST)
 800272a:	4628      	mov	r0, r5
 800272c:	f002 fb26 	bl	8004d7c <USB_GetMode>
 8002730:	2801      	cmp	r0, #1
 8002732:	d002      	beq.n	800273a <HAL_HCD_IRQHandler+0x1a>
}
 8002734:	b005      	add	sp, #20
 8002736:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (__HAL_HCD_IS_INVALID_INTERRUPT(hhcd))
 800273a:	6820      	ldr	r0, [r4, #0]
 800273c:	f002 fae8 	bl	8004d10 <USB_ReadInterrupts>
 8002740:	2800      	cmp	r0, #0
 8002742:	d0f7      	beq.n	8002734 <HAL_HCD_IRQHandler+0x14>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8002744:	6820      	ldr	r0, [r4, #0]
 8002746:	f002 fae3 	bl	8004d10 <USB_ReadInterrupts>
 800274a:	f410 1f00 	tst.w	r0, #2097152	@ 0x200000
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 800274e:	6820      	ldr	r0, [r4, #0]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8002750:	d002      	beq.n	8002758 <HAL_HCD_IRQHandler+0x38>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8002752:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8002756:	6143      	str	r3, [r0, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
 8002758:	f002 fada 	bl	8004d10 <USB_ReadInterrupts>
 800275c:	f410 1f80 	tst.w	r0, #1048576	@ 0x100000
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
 8002760:	6820      	ldr	r0, [r4, #0]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
 8002762:	d002      	beq.n	800276a <HAL_HCD_IRQHandler+0x4a>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
 8002764:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8002768:	6143      	str	r3, [r0, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
 800276a:	f002 fad1 	bl	8004d10 <USB_ReadInterrupts>
 800276e:	f010 6f80 	tst.w	r0, #67108864	@ 0x4000000
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
 8002772:	6820      	ldr	r0, [r4, #0]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
 8002774:	d002      	beq.n	800277c <HAL_HCD_IRQHandler+0x5c>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
 8002776:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
 800277a:	6143      	str	r3, [r0, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
 800277c:	f002 fac8 	bl	8004d10 <USB_ReadInterrupts>
 8002780:	f010 0f02 	tst.w	r0, #2
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
 8002784:	6820      	ldr	r0, [r4, #0]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
 8002786:	d001      	beq.n	800278c <HAL_HCD_IRQHandler+0x6c>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
 8002788:	2302      	movs	r3, #2
 800278a:	6143      	str	r3, [r0, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
 800278c:	f002 fac0 	bl	8004d10 <USB_ReadInterrupts>
 8002790:	f010 5f00 	tst.w	r0, #536870912	@ 0x20000000
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
 8002794:	6820      	ldr	r0, [r4, #0]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
 8002796:	d12a      	bne.n	80027ee <HAL_HCD_IRQHandler+0xce>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
 8002798:	f002 faba 	bl	8004d10 <USB_ReadInterrupts>
 800279c:	01c0      	lsls	r0, r0, #7
 800279e:	f100 8120 	bmi.w	80029e2 <HAL_HCD_IRQHandler+0x2c2>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_SOF))
 80027a2:	6820      	ldr	r0, [r4, #0]
 80027a4:	f002 fab4 	bl	8004d10 <USB_ReadInterrupts>
 80027a8:	0701      	lsls	r1, r0, #28
 80027aa:	f100 8113 	bmi.w	80029d4 <HAL_HCD_IRQHandler+0x2b4>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HCINT))
 80027ae:	6820      	ldr	r0, [r4, #0]
 80027b0:	f002 faae 	bl	8004d10 <USB_ReadInterrupts>
 80027b4:	f010 7f00 	tst.w	r0, #33554432	@ 0x2000000
      interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
 80027b8:	6820      	ldr	r0, [r4, #0]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HCINT))
 80027ba:	d12f      	bne.n	800281c <HAL_HCD_IRQHandler+0xfc>
    if ((__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_RXFLVL)) != 0U)
 80027bc:	f002 faa8 	bl	8004d10 <USB_ReadInterrupts>
 80027c0:	06c3      	lsls	r3, r0, #27
 80027c2:	d5b7      	bpl.n	8002734 <HAL_HCD_IRQHandler+0x14>
      USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80027c4:	6825      	ldr	r5, [r4, #0]
 80027c6:	69ab      	ldr	r3, [r5, #24]
 80027c8:	f023 0310 	bic.w	r3, r3, #16
 80027cc:	61ab      	str	r3, [r5, #24]
  uint32_t GrxstspReg;
  uint32_t xferSizePktCnt;
  uint32_t tmpreg;
  uint32_t chnum;

  GrxstspReg = hhcd->Instance->GRXSTSP;
 80027ce:	6a2e      	ldr	r6, [r5, #32]
  chnum = GrxstspReg & USB_OTG_GRXSTSP_EPNUM;
  pktsts = (GrxstspReg & USB_OTG_GRXSTSP_PKTSTS) >> 17;
  pktcnt = (GrxstspReg & USB_OTG_GRXSTSP_BCNT) >> 4;

  switch (pktsts)
 80027d0:	f406 11f0 	and.w	r1, r6, #1966080	@ 0x1e0000
  pktcnt = (GrxstspReg & USB_OTG_GRXSTSP_BCNT) >> 4;
 80027d4:	f3c6 170a 	ubfx	r7, r6, #4, #11
  {
    case GRXSTS_PKTSTS_IN:
      /* Read the data into the host buffer. */
      if ((pktcnt > 0U) && (hhcd->hc[chnum].xfer_buff != (void *)0))
 80027d8:	f5b1 2f80 	cmp.w	r1, #262144	@ 0x40000
 80027dc:	d102      	bne.n	80027e4 <HAL_HCD_IRQHandler+0xc4>
 80027de:	2f00      	cmp	r7, #0
 80027e0:	f040 81c8 	bne.w	8002b74 <HAL_HCD_IRQHandler+0x454>
      USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80027e4:	69ab      	ldr	r3, [r5, #24]
 80027e6:	f043 0310 	orr.w	r3, r3, #16
 80027ea:	61ab      	str	r3, [r5, #24]
 80027ec:	e7a2      	b.n	8002734 <HAL_HCD_IRQHandler+0x14>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
 80027ee:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
 80027f2:	6143      	str	r3, [r0, #20]
      if ((USBx_HPRT0 & USB_OTG_HPRT_PCSTS) == 0U)
 80027f4:	f8d5 3440 	ldr.w	r3, [r5, #1088]	@ 0x440
 80027f8:	07de      	lsls	r6, r3, #31
 80027fa:	d4cd      	bmi.n	8002798 <HAL_HCD_IRQHandler+0x78>
        (void)USB_FlushTxFifo(USBx, 0x10U);
 80027fc:	2110      	movs	r1, #16
 80027fe:	4628      	mov	r0, r5
 8002800:	f001 ffcc 	bl	800479c <USB_FlushTxFifo>
        (void)USB_FlushRxFifo(USBx);
 8002804:	4628      	mov	r0, r5
 8002806:	f001 fff1 	bl	80047ec <USB_FlushRxFifo>
        if (hhcd->Init.phy_itface == USB_OTG_EMBEDDED_PHY)
 800280a:	7a63      	ldrb	r3, [r4, #9]
 800280c:	2b02      	cmp	r3, #2
 800280e:	f000 82b5 	beq.w	8002d7c <HAL_HCD_IRQHandler+0x65c>
        HAL_HCD_Disconnect_Callback(hhcd);
 8002812:	4620      	mov	r0, r4
 8002814:	f004 faec 	bl	8006df0 <HAL_HCD_Disconnect_Callback>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
 8002818:	6820      	ldr	r0, [r4, #0]
 800281a:	e7bd      	b.n	8002798 <HAL_HCD_IRQHandler+0x78>
      interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
 800281c:	f002 fd6e 	bl	80052fc <USB_HC_ReadInterrupt>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002820:	7963      	ldrb	r3, [r4, #5]
      interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
 8002822:	4682      	mov	sl, r0
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002824:	2b00      	cmp	r3, #0
 8002826:	f000 8216 	beq.w	8002c56 <HAL_HCD_IRQHandler+0x536>
 800282a:	f505 65a0 	add.w	r5, r5, #1280	@ 0x500
 800282e:	f8d4 b000 	ldr.w	fp, [r4]
 8002832:	4627      	mov	r7, r4
 8002834:	2600      	movs	r6, #0
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
 8002836:	46a8      	mov	r8, r5
 8002838:	465d      	mov	r5, fp
 800283a:	e02b      	b.n	8002894 <HAL_HCD_IRQHandler+0x174>
  if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_AHBERR))
 800283c:	f002 fa6c 	bl	8004d18 <USB_ReadChInterrupts>
 8002840:	0742      	lsls	r2, r0, #29
 8002842:	f140 809b 	bpl.w	800297c <HAL_HCD_IRQHandler+0x25c>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
 8002846:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
 800284a:	2204      	movs	r2, #4
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 800284c:	4649      	mov	r1, r9
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
 800284e:	445b      	add	r3, fp
 8002850:	609a      	str	r2, [r3, #8]
    hhcd->hc[chnum].state = HC_XACTERR;
 8002852:	f04f 0307 	mov.w	r3, #7
 8002856:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 800285a:	6820      	ldr	r0, [r4, #0]
 800285c:	f002 fd52 	bl	8005304 <USB_HC_Halt>
  if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_FRMOR))
 8002860:	4649      	mov	r1, r9
 8002862:	6820      	ldr	r0, [r4, #0]
 8002864:	f002 fa58 	bl	8004d18 <USB_ReadChInterrupts>
 8002868:	f410 7300 	ands.w	r3, r0, #512	@ 0x200
 800286c:	d036      	beq.n	80028dc <HAL_HCD_IRQHandler+0x1bc>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
 800286e:	f505 65a0 	add.w	r5, r5, #1280	@ 0x500
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002872:	4649      	mov	r1, r9
 8002874:	6820      	ldr	r0, [r4, #0]
 8002876:	f002 fd45 	bl	8005304 <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
 800287a:	445d      	add	r5, fp
 800287c:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8002880:	60ab      	str	r3, [r5, #8]
 8002882:	6825      	ldr	r5, [r4, #0]
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002884:	3601      	adds	r6, #1
 8002886:	7963      	ldrb	r3, [r4, #5]
 8002888:	373c      	adds	r7, #60	@ 0x3c
 800288a:	f108 0820 	add.w	r8, r8, #32
 800288e:	42b3      	cmp	r3, r6
 8002890:	f240 80e1 	bls.w	8002a56 <HAL_HCD_IRQHandler+0x336>
        if ((interrupt & (1UL << (i & 0xFU))) != 0U)
 8002894:	f006 030f 	and.w	r3, r6, #15
 8002898:	fa2a f303 	lsr.w	r3, sl, r3
 800289c:	07da      	lsls	r2, r3, #31
 800289e:	d5f1      	bpl.n	8002884 <HAL_HCD_IRQHandler+0x164>
          if ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_EPDIR) == USB_OTG_HCCHAR_EPDIR)
 80028a0:	f8d8 3000 	ldr.w	r3, [r8]
 80028a4:	fa5f f986 	uxtb.w	r9, r6
 80028a8:	ea4f 1b46 	mov.w	fp, r6, lsl #5
  if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_AHBERR))
 80028ac:	4628      	mov	r0, r5
          if ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_EPDIR) == USB_OTG_HCCHAR_EPDIR)
 80028ae:	041b      	lsls	r3, r3, #16
  if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_AHBERR))
 80028b0:	4649      	mov	r1, r9
          if ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_EPDIR) == USB_OTG_HCCHAR_EPDIR)
 80028b2:	d4c3      	bmi.n	800283c <HAL_HCD_IRQHandler+0x11c>
  if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_AHBERR))
 80028b4:	f002 fa30 	bl	8004d18 <USB_ReadChInterrupts>
 80028b8:	f010 0304 	ands.w	r3, r0, #4
 80028bc:	d072      	beq.n	80029a4 <HAL_HCD_IRQHandler+0x284>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
 80028be:	f505 65a0 	add.w	r5, r5, #1280	@ 0x500
 80028c2:	2304      	movs	r3, #4
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 80028c4:	4649      	mov	r1, r9
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
 80028c6:	445d      	add	r5, fp
 80028c8:	60ab      	str	r3, [r5, #8]
    hhcd->hc[chnum].state = HC_XACTERR;
 80028ca:	f04f 0307 	mov.w	r3, #7
 80028ce:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 80028d2:	6820      	ldr	r0, [r4, #0]
 80028d4:	f002 fd16 	bl	8005304 <USB_HC_Halt>
 80028d8:	6825      	ldr	r5, [r4, #0]
 80028da:	e7d3      	b.n	8002884 <HAL_HCD_IRQHandler+0x164>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_XFRC))
 80028dc:	4649      	mov	r1, r9
 80028de:	6820      	ldr	r0, [r4, #0]
 80028e0:	9301      	str	r3, [sp, #4]
 80028e2:	f002 fa19 	bl	8004d18 <USB_ReadChInterrupts>
 80028e6:	07c3      	lsls	r3, r0, #31
 80028e8:	f140 80f7 	bpl.w	8002ada <HAL_HCD_IRQHandler+0x3ba>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
 80028ec:	f505 60a0 	add.w	r0, r5, #1280	@ 0x500
 80028f0:	2220      	movs	r2, #32
    if (hhcd->hc[chnum].do_csplit == 1U)
 80028f2:	9b01      	ldr	r3, [sp, #4]
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
 80028f4:	eb00 050b 	add.w	r5, r0, fp
 80028f8:	60aa      	str	r2, [r5, #8]
    if (hhcd->hc[chnum].do_csplit == 1U)
 80028fa:	7efa      	ldrb	r2, [r7, #27]
 80028fc:	2a01      	cmp	r2, #1
 80028fe:	d104      	bne.n	800290a <HAL_HCD_IRQHandler+0x1ea>
      hhcd->hc[chnum].do_csplit = 0U;
 8002900:	76fb      	strb	r3, [r7, #27]
      __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 8002902:	686b      	ldr	r3, [r5, #4]
 8002904:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8002908:	606b      	str	r3, [r5, #4]
    if (hhcd->Init.dma_enable != 0U)
 800290a:	79a3      	ldrb	r3, [r4, #6]
 800290c:	2b00      	cmp	r3, #0
 800290e:	f000 80bc 	beq.w	8002a8a <HAL_HCD_IRQHandler+0x36a>
      hhcd->hc[chnum].xfer_count = hhcd->hc[chnum].XferSize - (USBx_HC(chnum)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
 8002912:	6929      	ldr	r1, [r5, #16]
 8002914:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8002916:	f3c1 0112 	ubfx	r1, r1, #0, #19
 800291a:	1a52      	subs	r2, r2, r1
    hhcd->hc[chnum].ErrCnt = 0U;
 800291c:	2100      	movs	r1, #0
      hhcd->hc[chnum].xfer_count = hhcd->hc[chnum].XferSize - (USBx_HC(chnum)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
 800291e:	63ba      	str	r2, [r7, #56]	@ 0x38
    hhcd->hc[chnum].state = HC_XFRC;
 8002920:	2201      	movs	r2, #1
    hhcd->hc[chnum].ErrCnt = 0U;
 8002922:	6479      	str	r1, [r7, #68]	@ 0x44
    hhcd->hc[chnum].state = HC_XFRC;
 8002924:	f887 204d 	strb.w	r2, [r7, #77]	@ 0x4d
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
 8002928:	60aa      	str	r2, [r5, #8]
    if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 800292a:	f897 2026 	ldrb.w	r2, [r7, #38]	@ 0x26
 800292e:	2a03      	cmp	r2, #3
 8002930:	d811      	bhi.n	8002956 <HAL_HCD_IRQHandler+0x236>
 8002932:	e8df f002 	tbb	[pc, r2]
 8002936:	021b      	.short	0x021b
 8002938:	021b      	.short	0x021b
      USBx_HC(chnum)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 800293a:	f850 300b 	ldr.w	r3, [r0, fp]
      hhcd->hc[chnum].urb_state = URB_DONE;
 800293e:	2201      	movs	r2, #1
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
 8002940:	4649      	mov	r1, r9
      USBx_HC(chnum)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 8002942:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8002946:	f840 300b 	str.w	r3, [r0, fp]
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
 800294a:	4620      	mov	r0, r4
      hhcd->hc[chnum].urb_state = URB_DONE;
 800294c:	f887 204c 	strb.w	r2, [r7, #76]	@ 0x4c
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
 8002950:	f004 fa52 	bl	8006df8 <HAL_HCD_HC_NotifyURBChange_Callback>
    if (hhcd->Init.dma_enable == 1U)
 8002954:	79a3      	ldrb	r3, [r4, #6]
 8002956:	2b01      	cmp	r3, #1
 8002958:	f000 8102 	beq.w	8002b60 <HAL_HCD_IRQHandler+0x440>
      hhcd->hc[chnum].toggle_in ^= 1U;
 800295c:	f897 303c 	ldrb.w	r3, [r7, #60]	@ 0x3c
 8002960:	f083 0301 	eor.w	r3, r3, #1
 8002964:	f887 303c 	strb.w	r3, [r7, #60]	@ 0x3c
 8002968:	6825      	ldr	r5, [r4, #0]
 800296a:	e78b      	b.n	8002884 <HAL_HCD_IRQHandler+0x164>
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 800296c:	4649      	mov	r1, r9
 800296e:	6820      	ldr	r0, [r4, #0]
 8002970:	f002 fcc8 	bl	8005304 <USB_HC_Halt>
      __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
 8002974:	2310      	movs	r3, #16
 8002976:	60ab      	str	r3, [r5, #8]
    if (hhcd->Init.dma_enable == 1U)
 8002978:	79a3      	ldrb	r3, [r4, #6]
 800297a:	e7ec      	b.n	8002956 <HAL_HCD_IRQHandler+0x236>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_BBERR))
 800297c:	4649      	mov	r1, r9
 800297e:	6820      	ldr	r0, [r4, #0]
 8002980:	f002 f9ca 	bl	8004d18 <USB_ReadChInterrupts>
 8002984:	05c3      	lsls	r3, r0, #23
 8002986:	d56d      	bpl.n	8002a64 <HAL_HCD_IRQHandler+0x344>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_BBERR);
 8002988:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
 800298c:	f44f 7280 	mov.w	r2, #256	@ 0x100
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002990:	4649      	mov	r1, r9
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_BBERR);
 8002992:	445b      	add	r3, fp
 8002994:	609a      	str	r2, [r3, #8]
    hhcd->hc[chnum].state = HC_BBLERR;
 8002996:	2308      	movs	r3, #8
 8002998:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 800299c:	6820      	ldr	r0, [r4, #0]
 800299e:	f002 fcb1 	bl	8005304 <USB_HC_Halt>
 80029a2:	e75d      	b.n	8002860 <HAL_HCD_IRQHandler+0x140>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_ACK))
 80029a4:	4649      	mov	r1, r9
 80029a6:	6820      	ldr	r0, [r4, #0]
 80029a8:	9301      	str	r3, [sp, #4]
 80029aa:	f002 f9b5 	bl	8004d18 <USB_ReadChInterrupts>
 80029ae:	0682      	lsls	r2, r0, #26
 80029b0:	f140 8080 	bpl.w	8002ab4 <HAL_HCD_IRQHandler+0x394>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
 80029b4:	f505 65a0 	add.w	r5, r5, #1280	@ 0x500
 80029b8:	2220      	movs	r2, #32
    if (hhcd->hc[chnum].do_ping == 1U)
 80029ba:	9b01      	ldr	r3, [sp, #4]
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
 80029bc:	445d      	add	r5, fp
 80029be:	60aa      	str	r2, [r5, #8]
    if (hhcd->hc[chnum].do_ping == 1U)
 80029c0:	7e7a      	ldrb	r2, [r7, #25]
 80029c2:	2a01      	cmp	r2, #1
 80029c4:	f000 811e 	beq.w	8002c04 <HAL_HCD_IRQHandler+0x4e4>
    if ((hhcd->hc[chnum].do_ssplit == 1U) && (hhcd->hc[chnum].do_csplit == 0U))
 80029c8:	7ebb      	ldrb	r3, [r7, #26]
 80029ca:	2b01      	cmp	r3, #1
 80029cc:	f000 80b4 	beq.w	8002b38 <HAL_HCD_IRQHandler+0x418>
 80029d0:	6825      	ldr	r5, [r4, #0]
 80029d2:	e757      	b.n	8002884 <HAL_HCD_IRQHandler+0x164>
      HAL_HCD_SOF_Callback(hhcd);
 80029d4:	4620      	mov	r0, r4
 80029d6:	f004 fa03 	bl	8006de0 <HAL_HCD_SOF_Callback>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_SOF);
 80029da:	2308      	movs	r3, #8
 80029dc:	6820      	ldr	r0, [r4, #0]
 80029de:	6143      	str	r3, [r0, #20]
 80029e0:	e6e6      	b.n	80027b0 <HAL_HCD_IRQHandler+0x90>
  * @retval None
  */
static void HCD_Port_IRQHandler(HCD_HandleTypeDef *hhcd)
{
  const USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
  uint32_t USBx_BASE = (uint32_t)USBx;
 80029e2:	6826      	ldr	r6, [r4, #0]
  __IO uint32_t hprt0;
  __IO uint32_t hprt0_dup;

  /* Handle Host Port Interrupts */
  hprt0 = USBx_HPRT0;
 80029e4:	f8d6 3440 	ldr.w	r3, [r6, #1088]	@ 0x440
 80029e8:	9302      	str	r3, [sp, #8]
  hprt0_dup = USBx_HPRT0;
 80029ea:	f8d6 3440 	ldr.w	r3, [r6, #1088]	@ 0x440
 80029ee:	9303      	str	r3, [sp, #12]

  hprt0_dup &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET | \
 80029f0:	9b03      	ldr	r3, [sp, #12]
 80029f2:	f023 032e 	bic.w	r3, r3, #46	@ 0x2e
 80029f6:	9303      	str	r3, [sp, #12]
                 USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  /* Check whether Port Connect detected */
  if ((hprt0 & USB_OTG_HPRT_PCDET) == USB_OTG_HPRT_PCDET)
 80029f8:	9b02      	ldr	r3, [sp, #8]
 80029fa:	0799      	lsls	r1, r3, #30
 80029fc:	d507      	bpl.n	8002a0e <HAL_HCD_IRQHandler+0x2ee>
  {
    if ((hprt0 & USB_OTG_HPRT_PCSTS) == USB_OTG_HPRT_PCSTS)
 80029fe:	9b02      	ldr	r3, [sp, #8]
 8002a00:	07da      	lsls	r2, r3, #31
 8002a02:	f100 80ce 	bmi.w	8002ba2 <HAL_HCD_IRQHandler+0x482>
      hhcd->ConnectCallback(hhcd);
#else
      HAL_HCD_Connect_Callback(hhcd);
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
    hprt0_dup |= USB_OTG_HPRT_PCDET;
 8002a06:	9b03      	ldr	r3, [sp, #12]
 8002a08:	f043 0302 	orr.w	r3, r3, #2
 8002a0c:	9303      	str	r3, [sp, #12]
  }

  /* Check whether Port Enable Changed */
  if ((hprt0 & USB_OTG_HPRT_PENCHNG) == USB_OTG_HPRT_PENCHNG)
 8002a0e:	9b02      	ldr	r3, [sp, #8]
 8002a10:	071b      	lsls	r3, r3, #28
 8002a12:	d515      	bpl.n	8002a40 <HAL_HCD_IRQHandler+0x320>
  {
    hprt0_dup |= USB_OTG_HPRT_PENCHNG;
 8002a14:	9b03      	ldr	r3, [sp, #12]
 8002a16:	f043 0308 	orr.w	r3, r3, #8
 8002a1a:	9303      	str	r3, [sp, #12]

    if ((hprt0 & USB_OTG_HPRT_PENA) == USB_OTG_HPRT_PENA)
 8002a1c:	9b02      	ldr	r3, [sp, #8]
 8002a1e:	075f      	lsls	r7, r3, #29
 8002a20:	f140 80c3 	bpl.w	8002baa <HAL_HCD_IRQHandler+0x48a>
    {
      if (hhcd->Init.phy_itface == USB_OTG_EMBEDDED_PHY)
 8002a24:	7a61      	ldrb	r1, [r4, #9]
 8002a26:	2902      	cmp	r1, #2
 8002a28:	f000 810a 	beq.w	8002c40 <HAL_HCD_IRQHandler+0x520>
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
        }
      }
      else
      {
        if (hhcd->Init.speed == HCD_SPEED_FULL)
 8002a2c:	79e3      	ldrb	r3, [r4, #7]
 8002a2e:	2b01      	cmp	r3, #1
 8002a30:	d103      	bne.n	8002a3a <HAL_HCD_IRQHandler+0x31a>
        {
          USBx_HOST->HFIR = HFIR_60_MHZ;
 8002a32:	f64e 2260 	movw	r2, #60000	@ 0xea60
 8002a36:	f8c6 2404 	str.w	r2, [r6, #1028]	@ 0x404
        }
      }
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->PortEnabledCallback(hhcd);
#else
      HAL_HCD_PortEnabled_Callback(hhcd);
 8002a3a:	4620      	mov	r0, r4
 8002a3c:	f004 f9de 	bl	8006dfc <HAL_HCD_PortEnabled_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
  }

  /* Check for an overcurrent */
  if ((hprt0 & USB_OTG_HPRT_POCCHNG) == USB_OTG_HPRT_POCCHNG)
 8002a40:	9b02      	ldr	r3, [sp, #8]
 8002a42:	0698      	lsls	r0, r3, #26
 8002a44:	d503      	bpl.n	8002a4e <HAL_HCD_IRQHandler+0x32e>
  {
    hprt0_dup |= USB_OTG_HPRT_POCCHNG;
 8002a46:	9b03      	ldr	r3, [sp, #12]
 8002a48:	f043 0320 	orr.w	r3, r3, #32
 8002a4c:	9303      	str	r3, [sp, #12]
  }

  /* Clear Port Interrupts */
  USBx_HPRT0 = hprt0_dup;
 8002a4e:	9b03      	ldr	r3, [sp, #12]
 8002a50:	f8c6 3440 	str.w	r3, [r6, #1088]	@ 0x440
}
 8002a54:	e6a5      	b.n	80027a2 <HAL_HCD_IRQHandler+0x82>
 8002a56:	46ab      	mov	fp, r5
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_HCINT);
 8002a58:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8002a5c:	4658      	mov	r0, fp
 8002a5e:	f8cb 3014 	str.w	r3, [fp, #20]
 8002a62:	e6ab      	b.n	80027bc <HAL_HCD_IRQHandler+0x9c>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_STALL))
 8002a64:	4649      	mov	r1, r9
 8002a66:	6820      	ldr	r0, [r4, #0]
 8002a68:	f002 f956 	bl	8004d18 <USB_ReadChInterrupts>
 8002a6c:	0700      	lsls	r0, r0, #28
 8002a6e:	d54f      	bpl.n	8002b10 <HAL_HCD_IRQHandler+0x3f0>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);
 8002a70:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
 8002a74:	2208      	movs	r2, #8
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002a76:	4649      	mov	r1, r9
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);
 8002a78:	445b      	add	r3, fp
 8002a7a:	609a      	str	r2, [r3, #8]
    hhcd->hc[chnum].state = HC_STALL;
 8002a7c:	2306      	movs	r3, #6
 8002a7e:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002a82:	6820      	ldr	r0, [r4, #0]
 8002a84:	f002 fc3e 	bl	8005304 <USB_HC_Halt>
 8002a88:	e6ea      	b.n	8002860 <HAL_HCD_IRQHandler+0x140>
    hhcd->hc[chnum].ErrCnt = 0U;
 8002a8a:	647b      	str	r3, [r7, #68]	@ 0x44
    hhcd->hc[chnum].state = HC_XFRC;
 8002a8c:	2301      	movs	r3, #1
 8002a8e:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
 8002a92:	60ab      	str	r3, [r5, #8]
    if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8002a94:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8002a98:	2b03      	cmp	r3, #3
 8002a9a:	f63f af5f 	bhi.w	800295c <HAL_HCD_IRQHandler+0x23c>
 8002a9e:	a201      	add	r2, pc, #4	@ (adr r2, 8002aa4 <HAL_HCD_IRQHandler+0x384>)
 8002aa0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002aa4:	0800296d 	.word	0x0800296d
 8002aa8:	0800293b 	.word	0x0800293b
 8002aac:	0800296d 	.word	0x0800296d
 8002ab0:	0800293b 	.word	0x0800293b
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_FRMOR))
 8002ab4:	4649      	mov	r1, r9
 8002ab6:	6820      	ldr	r0, [r4, #0]
 8002ab8:	f002 f92e 	bl	8004d18 <USB_ReadChInterrupts>
 8002abc:	f410 7300 	ands.w	r3, r0, #512	@ 0x200
 8002ac0:	d077      	beq.n	8002bb2 <HAL_HCD_IRQHandler+0x492>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
 8002ac2:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
 8002ac6:	f44f 7200 	mov.w	r2, #512	@ 0x200
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002aca:	4649      	mov	r1, r9
 8002acc:	6820      	ldr	r0, [r4, #0]
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
 8002ace:	445b      	add	r3, fp
 8002ad0:	609a      	str	r2, [r3, #8]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002ad2:	f002 fc17 	bl	8005304 <USB_HC_Halt>
 8002ad6:	6825      	ldr	r5, [r4, #0]
 8002ad8:	e6d4      	b.n	8002884 <HAL_HCD_IRQHandler+0x164>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_ACK))
 8002ada:	4649      	mov	r1, r9
 8002adc:	6820      	ldr	r0, [r4, #0]
 8002ade:	f002 f91b 	bl	8004d18 <USB_ReadChInterrupts>
 8002ae2:	0680      	lsls	r0, r0, #26
 8002ae4:	f140 80ba 	bpl.w	8002c5c <HAL_HCD_IRQHandler+0x53c>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
 8002ae8:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
 8002aec:	2220      	movs	r2, #32
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002aee:	6825      	ldr	r5, [r4, #0]
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
 8002af0:	445b      	add	r3, fp
 8002af2:	609a      	str	r2, [r3, #8]
    if (hhcd->hc[chnum].do_ssplit == 1U)
 8002af4:	7ebb      	ldrb	r3, [r7, #26]
 8002af6:	2b01      	cmp	r3, #1
 8002af8:	f47f aec4 	bne.w	8002884 <HAL_HCD_IRQHandler+0x164>
      hhcd->hc[chnum].do_csplit = 1U;
 8002afc:	76fb      	strb	r3, [r7, #27]
      hhcd->hc[chnum].state = HC_ACK;
 8002afe:	2303      	movs	r3, #3
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002b00:	4628      	mov	r0, r5
 8002b02:	4649      	mov	r1, r9
      hhcd->hc[chnum].state = HC_ACK;
 8002b04:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002b08:	f002 fbfc 	bl	8005304 <USB_HC_Halt>
 8002b0c:	6825      	ldr	r5, [r4, #0]
 8002b0e:	e6b9      	b.n	8002884 <HAL_HCD_IRQHandler+0x164>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_DTERR))
 8002b10:	4649      	mov	r1, r9
 8002b12:	6820      	ldr	r0, [r4, #0]
 8002b14:	f002 f900 	bl	8004d18 <USB_ReadChInterrupts>
 8002b18:	0541      	lsls	r1, r0, #21
 8002b1a:	d57d      	bpl.n	8002c18 <HAL_HCD_IRQHandler+0x4f8>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);
 8002b1c:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
 8002b20:	f44f 6280 	mov.w	r2, #1024	@ 0x400
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002b24:	4649      	mov	r1, r9
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);
 8002b26:	445b      	add	r3, fp
 8002b28:	609a      	str	r2, [r3, #8]
    hhcd->hc[chnum].state = HC_DATATGLERR;
 8002b2a:	2309      	movs	r3, #9
 8002b2c:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002b30:	6820      	ldr	r0, [r4, #0]
 8002b32:	f002 fbe7 	bl	8005304 <USB_HC_Halt>
 8002b36:	e693      	b.n	8002860 <HAL_HCD_IRQHandler+0x140>
    if ((hhcd->hc[chnum].do_ssplit == 1U) && (hhcd->hc[chnum].do_csplit == 0U))
 8002b38:	7efa      	ldrb	r2, [r7, #27]
 8002b3a:	2a00      	cmp	r2, #0
 8002b3c:	f47f af48 	bne.w	80029d0 <HAL_HCD_IRQHandler+0x2b0>
      if (hhcd->hc[chnum].ep_type != EP_TYPE_ISOC)
 8002b40:	f897 2026 	ldrb.w	r2, [r7, #38]	@ 0x26
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002b44:	4649      	mov	r1, r9
      if (hhcd->hc[chnum].ep_type != EP_TYPE_ISOC)
 8002b46:	2a01      	cmp	r2, #1
        hhcd->hc[chnum].do_csplit = 1U;
 8002b48:	bf18      	it	ne
 8002b4a:	76fb      	strbne	r3, [r7, #27]
      hhcd->hc[chnum].state = HC_ACK;
 8002b4c:	2303      	movs	r3, #3
 8002b4e:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002b52:	6820      	ldr	r0, [r4, #0]
 8002b54:	f002 fbd6 	bl	8005304 <USB_HC_Halt>
      hhcd->hc[chnum].ErrCnt = 0U;
 8002b58:	2300      	movs	r3, #0
 8002b5a:	6825      	ldr	r5, [r4, #0]
 8002b5c:	647b      	str	r3, [r7, #68]	@ 0x44
 8002b5e:	e691      	b.n	8002884 <HAL_HCD_IRQHandler+0x164>
      if ((((hhcd->hc[chnum].xfer_count + hhcd->hc[chnum].max_packet - 1U) / hhcd->hc[chnum].max_packet) & 1U) != 0U)
 8002b60:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8002b62:	8d3a      	ldrh	r2, [r7, #40]	@ 0x28
 8002b64:	3b01      	subs	r3, #1
 8002b66:	4413      	add	r3, r2
 8002b68:	fbb3 f3f2 	udiv	r3, r3, r2
 8002b6c:	07dd      	lsls	r5, r3, #31
 8002b6e:	f53f aef5 	bmi.w	800295c <HAL_HCD_IRQHandler+0x23c>
 8002b72:	e72d      	b.n	80029d0 <HAL_HCD_IRQHandler+0x2b0>
  chnum = GrxstspReg & USB_OTG_GRXSTSP_EPNUM;
 8002b74:	f006 060f 	and.w	r6, r6, #15
      if ((pktcnt > 0U) && (hhcd->hc[chnum].xfer_buff != (void *)0))
 8002b78:	ebc6 1106 	rsb	r1, r6, r6, lsl #4
 8002b7c:	eb04 0881 	add.w	r8, r4, r1, lsl #2
 8002b80:	f8d8 102c 	ldr.w	r1, [r8, #44]	@ 0x2c
 8002b84:	2900      	cmp	r1, #0
 8002b86:	f43f ae2d 	beq.w	80027e4 <HAL_HCD_IRQHandler+0xc4>
        if ((hhcd->hc[chnum].xfer_count + pktcnt) <= hhcd->hc[chnum].xfer_len)
 8002b8a:	f8d8 0038 	ldr.w	r0, [r8, #56]	@ 0x38
 8002b8e:	f8d8 3034 	ldr.w	r3, [r8, #52]	@ 0x34
 8002b92:	4438      	add	r0, r7
 8002b94:	4298      	cmp	r0, r3
 8002b96:	f240 8110 	bls.w	8002dba <HAL_HCD_IRQHandler+0x69a>
          hhcd->hc[chnum].urb_state = URB_ERROR;
 8002b9a:	2304      	movs	r3, #4
 8002b9c:	f888 304c 	strb.w	r3, [r8, #76]	@ 0x4c
 8002ba0:	e620      	b.n	80027e4 <HAL_HCD_IRQHandler+0xc4>
      HAL_HCD_Connect_Callback(hhcd);
 8002ba2:	4620      	mov	r0, r4
 8002ba4:	f004 f920 	bl	8006de8 <HAL_HCD_Connect_Callback>
 8002ba8:	e72d      	b.n	8002a06 <HAL_HCD_IRQHandler+0x2e6>
      HAL_HCD_PortDisabled_Callback(hhcd);
 8002baa:	4620      	mov	r0, r4
 8002bac:	f004 f92a 	bl	8006e04 <HAL_HCD_PortDisabled_Callback>
 8002bb0:	e746      	b.n	8002a40 <HAL_HCD_IRQHandler+0x320>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_XFRC))
 8002bb2:	4649      	mov	r1, r9
 8002bb4:	6820      	ldr	r0, [r4, #0]
 8002bb6:	9301      	str	r3, [sp, #4]
 8002bb8:	f002 f8ae 	bl	8004d18 <USB_ReadChInterrupts>
 8002bbc:	07c3      	lsls	r3, r0, #31
 8002bbe:	f140 80e2 	bpl.w	8002d86 <HAL_HCD_IRQHandler+0x666>
    hhcd->hc[chnum].ErrCnt = 0U;
 8002bc2:	9b01      	ldr	r3, [sp, #4]
    if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NYET))
 8002bc4:	4649      	mov	r1, r9
 8002bc6:	6820      	ldr	r0, [r4, #0]
    hhcd->hc[chnum].ErrCnt = 0U;
 8002bc8:	647b      	str	r3, [r7, #68]	@ 0x44
    if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NYET))
 8002bca:	f002 f8a5 	bl	8004d18 <USB_ReadChInterrupts>
      __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
 8002bce:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
    if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NYET))
 8002bd2:	0640      	lsls	r0, r0, #25
      __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
 8002bd4:	445b      	add	r3, fp
    if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NYET))
 8002bd6:	d503      	bpl.n	8002be0 <HAL_HCD_IRQHandler+0x4c0>
      hhcd->hc[chnum].do_ping = 1U;
 8002bd8:	2201      	movs	r2, #1
 8002bda:	767a      	strb	r2, [r7, #25]
      __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
 8002bdc:	2240      	movs	r2, #64	@ 0x40
 8002bde:	609a      	str	r2, [r3, #8]
    if (hhcd->hc[chnum].do_csplit != 0U)
 8002be0:	7efa      	ldrb	r2, [r7, #27]
 8002be2:	b12a      	cbz	r2, 8002bf0 <HAL_HCD_IRQHandler+0x4d0>
      hhcd->hc[chnum].do_csplit = 0U;
 8002be4:	2200      	movs	r2, #0
 8002be6:	76fa      	strb	r2, [r7, #27]
      __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 8002be8:	685a      	ldr	r2, [r3, #4]
 8002bea:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8002bee:	605a      	str	r2, [r3, #4]
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
 8002bf0:	2201      	movs	r2, #1
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002bf2:	4649      	mov	r1, r9
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
 8002bf4:	609a      	str	r2, [r3, #8]
    hhcd->hc[chnum].state = HC_XFRC;
 8002bf6:	f887 204d 	strb.w	r2, [r7, #77]	@ 0x4d
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002bfa:	6820      	ldr	r0, [r4, #0]
 8002bfc:	f002 fb82 	bl	8005304 <USB_HC_Halt>
 8002c00:	6825      	ldr	r5, [r4, #0]
 8002c02:	e63f      	b.n	8002884 <HAL_HCD_IRQHandler+0x164>
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002c04:	6820      	ldr	r0, [r4, #0]
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002c06:	4649      	mov	r1, r9
      hhcd->hc[chnum].do_ping = 0U;
 8002c08:	767b      	strb	r3, [r7, #25]
      hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8002c0a:	f240 3302 	movw	r3, #770	@ 0x302
 8002c0e:	f8a7 304c 	strh.w	r3, [r7, #76]	@ 0x4c
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002c12:	f002 fb77 	bl	8005304 <USB_HC_Halt>
 8002c16:	e6d7      	b.n	80029c8 <HAL_HCD_IRQHandler+0x2a8>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_TXERR))
 8002c18:	4649      	mov	r1, r9
 8002c1a:	6820      	ldr	r0, [r4, #0]
 8002c1c:	f002 f87c 	bl	8004d18 <USB_ReadChInterrupts>
 8002c20:	0602      	lsls	r2, r0, #24
 8002c22:	f57f ae1d 	bpl.w	8002860 <HAL_HCD_IRQHandler+0x140>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
 8002c26:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
 8002c2a:	2280      	movs	r2, #128	@ 0x80
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002c2c:	4649      	mov	r1, r9
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
 8002c2e:	445b      	add	r3, fp
 8002c30:	609a      	str	r2, [r3, #8]
    hhcd->hc[chnum].state = HC_XACTERR;
 8002c32:	2307      	movs	r3, #7
 8002c34:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002c38:	6820      	ldr	r0, [r4, #0]
 8002c3a:	f002 fb63 	bl	8005304 <USB_HC_Halt>
 8002c3e:	e60f      	b.n	8002860 <HAL_HCD_IRQHandler+0x140>
        if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17))
 8002c40:	9b02      	ldr	r3, [sp, #8]
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_6_MHZ);
 8002c42:	6820      	ldr	r0, [r4, #0]
        if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17))
 8002c44:	f403 23c0 	and.w	r3, r3, #393216	@ 0x60000
 8002c48:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 8002c4c:	bf18      	it	ne
 8002c4e:	2101      	movne	r1, #1
 8002c50:	f002 f8d0 	bl	8004df4 <USB_InitFSLSPClkSel>
 8002c54:	e6f1      	b.n	8002a3a <HAL_HCD_IRQHandler+0x31a>
 8002c56:	f8d4 b000 	ldr.w	fp, [r4]
 8002c5a:	e6fd      	b.n	8002a58 <HAL_HCD_IRQHandler+0x338>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_CHH))
 8002c5c:	4649      	mov	r1, r9
 8002c5e:	6820      	ldr	r0, [r4, #0]
 8002c60:	f002 f85a 	bl	8004d18 <USB_ReadChInterrupts>
 8002c64:	0781      	lsls	r1, r0, #30
 8002c66:	f140 80c2 	bpl.w	8002dee <HAL_HCD_IRQHandler+0x6ce>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_CHH);
 8002c6a:	f505 65a0 	add.w	r5, r5, #1280	@ 0x500
 8002c6e:	2302      	movs	r3, #2
 8002c70:	eb05 020b 	add.w	r2, r5, fp
 8002c74:	6093      	str	r3, [r2, #8]
    if (hhcd->hc[chnum].state == HC_XFRC)
 8002c76:	f897 304d 	ldrb.w	r3, [r7, #77]	@ 0x4d
 8002c7a:	3b01      	subs	r3, #1
 8002c7c:	2b08      	cmp	r3, #8
 8002c7e:	d827      	bhi.n	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
 8002c80:	a101      	add	r1, pc, #4	@ (adr r1, 8002c88 <HAL_HCD_IRQHandler+0x568>)
 8002c82:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8002c86:	bf00      	nop
 8002c88:	08002d23 	.word	0x08002d23
 8002c8c:	080029d1 	.word	0x080029d1
 8002c90:	08002cdf 	.word	0x08002cdf
 8002c94:	08002d4f 	.word	0x08002d4f
 8002c98:	08002d2d 	.word	0x08002d2d
 8002c9c:	08002d63 	.word	0x08002d63
 8002ca0:	08002cad 	.word	0x08002cad
 8002ca4:	08002d6d 	.word	0x08002d6d
 8002ca8:	08002cad 	.word	0x08002cad
      hhcd->hc[chnum].ErrCnt++;
 8002cac:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
      hhcd->hc[chnum].state = HC_HALTED;
 8002cae:	2102      	movs	r1, #2
      hhcd->hc[chnum].ErrCnt++;
 8002cb0:	3301      	adds	r3, #1
      hhcd->hc[chnum].state = HC_HALTED;
 8002cb2:	f887 104d 	strb.w	r1, [r7, #77]	@ 0x4d
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8002cb6:	428b      	cmp	r3, r1
      hhcd->hc[chnum].ErrCnt++;
 8002cb8:	647b      	str	r3, [r7, #68]	@ 0x44
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8002cba:	f240 8129 	bls.w	8002f10 <HAL_HCD_IRQHandler+0x7f0>
        if (hhcd->hc[chnum].do_ssplit == 1U)
 8002cbe:	7eb9      	ldrb	r1, [r7, #26]
        hhcd->hc[chnum].ErrCnt = 0U;
 8002cc0:	2300      	movs	r3, #0
        if (hhcd->hc[chnum].do_ssplit == 1U)
 8002cc2:	2901      	cmp	r1, #1
        hhcd->hc[chnum].ErrCnt = 0U;
 8002cc4:	647b      	str	r3, [r7, #68]	@ 0x44
        if (hhcd->hc[chnum].do_ssplit == 1U)
 8002cc6:	f000 8157 	beq.w	8002f78 <HAL_HCD_IRQHandler+0x858>
        hhcd->hc[chnum].urb_state = URB_ERROR;
 8002cca:	2304      	movs	r3, #4
 8002ccc:	f887 304c 	strb.w	r3, [r7, #76]	@ 0x4c
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
 8002cd0:	4649      	mov	r1, r9
 8002cd2:	f897 204c 	ldrb.w	r2, [r7, #76]	@ 0x4c
 8002cd6:	4620      	mov	r0, r4
 8002cd8:	f004 f88e 	bl	8006df8 <HAL_HCD_HC_NotifyURBChange_Callback>
 8002cdc:	e678      	b.n	80029d0 <HAL_HCD_IRQHandler+0x2b0>
      if (hhcd->hc[chnum].do_csplit == 1U)
 8002cde:	7ef9      	ldrb	r1, [r7, #27]
      hhcd->hc[chnum].state = HC_HALTED;
 8002ce0:	2302      	movs	r3, #2
      if (hhcd->hc[chnum].do_csplit == 1U)
 8002ce2:	2901      	cmp	r1, #1
      hhcd->hc[chnum].state = HC_HALTED;
 8002ce4:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
      if (hhcd->hc[chnum].do_csplit == 1U)
 8002ce8:	d1f2      	bne.n	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
        hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8002cea:	f887 304c 	strb.w	r3, [r7, #76]	@ 0x4c
        USBx_HC(chnum)->HCSPLT |= USB_OTG_HCSPLT_COMPLSPLT;
 8002cee:	6853      	ldr	r3, [r2, #4]
 8002cf0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8002cf4:	6053      	str	r3, [r2, #4]
        USBx_HC(chnum)->HCINTMSK |= USB_OTG_HCINTMSK_NYET;
 8002cf6:	68d3      	ldr	r3, [r2, #12]
 8002cf8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8002cfc:	60d3      	str	r3, [r2, #12]
        USBx_HC(chnum)->HCINTMSK &= ~USB_OTG_HCINT_ACK;
 8002cfe:	68d3      	ldr	r3, [r2, #12]
 8002d00:	f023 0320 	bic.w	r3, r3, #32
 8002d04:	60d3      	str	r3, [r2, #12]
        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8002d06:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8002d0a:	f013 0ffd 	tst.w	r3, #253	@ 0xfd
 8002d0e:	d1df      	bne.n	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
        tmpreg = USBx_HC(chnum)->HCCHAR;
 8002d10:	f855 300b 	ldr.w	r3, [r5, fp]
        tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8002d14:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
        tmpreg |= USB_OTG_HCCHAR_CHENA;
 8002d18:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
        USBx_HC(chnum)->HCCHAR = tmpreg;
 8002d1c:	f845 300b 	str.w	r3, [r5, fp]
 8002d20:	e7d6      	b.n	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
      hhcd->hc[chnum].urb_state = URB_DONE;
 8002d22:	f240 2301 	movw	r3, #513	@ 0x201
 8002d26:	f8a7 304c 	strh.w	r3, [r7, #76]	@ 0x4c
 8002d2a:	e7d1      	b.n	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
      if (hhcd->hc[chnum].do_csplit == 1U)
 8002d2c:	7ef8      	ldrb	r0, [r7, #27]
      hhcd->hc[chnum].state = HC_HALTED;
 8002d2e:	2102      	movs	r1, #2
      if (hhcd->hc[chnum].do_csplit == 1U)
 8002d30:	2801      	cmp	r0, #1
      hhcd->hc[chnum].state = HC_HALTED;
 8002d32:	f887 104d 	strb.w	r1, [r7, #77]	@ 0x4d
      if (hhcd->hc[chnum].do_csplit == 1U)
 8002d36:	d1cb      	bne.n	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
        if (hhcd->hc[chnum].ep_type == EP_TYPE_INTR)
 8002d38:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8002d3c:	2b03      	cmp	r3, #3
 8002d3e:	f000 8107 	beq.w	8002f50 <HAL_HCD_IRQHandler+0x830>
        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8002d42:	f013 0ffd 	tst.w	r3, #253	@ 0xfd
          hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8002d46:	f887 104c 	strb.w	r1, [r7, #76]	@ 0x4c
        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8002d4a:	d0e1      	beq.n	8002d10 <HAL_HCD_IRQHandler+0x5f0>
 8002d4c:	e7c0      	b.n	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
      hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8002d4e:	f240 2302 	movw	r3, #514	@ 0x202
 8002d52:	f8a7 304c 	strh.w	r3, [r7, #76]	@ 0x4c
      if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8002d56:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8002d5a:	f013 0ffd 	tst.w	r3, #253	@ 0xfd
 8002d5e:	d1b7      	bne.n	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
 8002d60:	e7d6      	b.n	8002d10 <HAL_HCD_IRQHandler+0x5f0>
      hhcd->hc[chnum].urb_state  = URB_STALL;
 8002d62:	f240 2305 	movw	r3, #517	@ 0x205
 8002d66:	f8a7 304c 	strh.w	r3, [r7, #76]	@ 0x4c
 8002d6a:	e7b1      	b.n	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
      hhcd->hc[chnum].ErrCnt++;
 8002d6c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8002d6e:	3301      	adds	r3, #1
 8002d70:	647b      	str	r3, [r7, #68]	@ 0x44
      hhcd->hc[chnum].urb_state = URB_ERROR;
 8002d72:	f44f 7301 	mov.w	r3, #516	@ 0x204
 8002d76:	f8a7 304c 	strh.w	r3, [r7, #76]	@ 0x4c
 8002d7a:	e7a9      	b.n	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 8002d7c:	2101      	movs	r1, #1
 8002d7e:	6820      	ldr	r0, [r4, #0]
 8002d80:	f002 f838 	bl	8004df4 <USB_InitFSLSPClkSel>
 8002d84:	e545      	b.n	8002812 <HAL_HCD_IRQHandler+0xf2>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NYET))
 8002d86:	4649      	mov	r1, r9
 8002d88:	6820      	ldr	r0, [r4, #0]
 8002d8a:	f001 ffc5 	bl	8004d18 <USB_ReadChInterrupts>
 8002d8e:	0641      	lsls	r1, r0, #25
 8002d90:	d545      	bpl.n	8002e1e <HAL_HCD_IRQHandler+0x6fe>
    hhcd->hc[chnum].state = HC_NYET;
 8002d92:	2305      	movs	r3, #5
 8002d94:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
    if (hhcd->hc[chnum].do_ssplit == 0U)
 8002d98:	7ebb      	ldrb	r3, [r7, #26]
 8002d9a:	b90b      	cbnz	r3, 8002da0 <HAL_HCD_IRQHandler+0x680>
      hhcd->hc[chnum].do_ping = 1U;
 8002d9c:	2301      	movs	r3, #1
 8002d9e:	767b      	strb	r3, [r7, #25]
    hhcd->hc[chnum].ErrCnt = 0U;
 8002da0:	2300      	movs	r3, #0
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002da2:	4649      	mov	r1, r9
 8002da4:	6820      	ldr	r0, [r4, #0]
    hhcd->hc[chnum].ErrCnt = 0U;
 8002da6:	647b      	str	r3, [r7, #68]	@ 0x44
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002da8:	f002 faac 	bl	8005304 <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
 8002dac:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
 8002db0:	2240      	movs	r2, #64	@ 0x40
 8002db2:	6825      	ldr	r5, [r4, #0]
 8002db4:	445b      	add	r3, fp
 8002db6:	609a      	str	r2, [r3, #8]
 8002db8:	e564      	b.n	8002884 <HAL_HCD_IRQHandler+0x164>
          (void)USB_ReadPacket(hhcd->Instance,
 8002dba:	463a      	mov	r2, r7
 8002dbc:	4628      	mov	r0, r5
 8002dbe:	f001 ff0d 	bl	8004bdc <USB_ReadPacket>
          hhcd->hc[chnum].xfer_buff += pktcnt;
 8002dc2:	f8d8 302c 	ldr.w	r3, [r8, #44]	@ 0x2c
          xferSizePktCnt = (USBx_HC(chnum)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) >> 19;
 8002dc6:	f505 65a0 	add.w	r5, r5, #1280	@ 0x500
          hhcd->hc[chnum].xfer_buff += pktcnt;
 8002dca:	443b      	add	r3, r7
          xferSizePktCnt = (USBx_HC(chnum)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) >> 19;
 8002dcc:	eb05 1246 	add.w	r2, r5, r6, lsl #5
          hhcd->hc[chnum].xfer_buff += pktcnt;
 8002dd0:	f8c8 302c 	str.w	r3, [r8, #44]	@ 0x2c
          hhcd->hc[chnum].xfer_count += pktcnt;
 8002dd4:	f8d8 3038 	ldr.w	r3, [r8, #56]	@ 0x38
          xferSizePktCnt = (USBx_HC(chnum)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) >> 19;
 8002dd8:	6911      	ldr	r1, [r2, #16]
 8002dda:	0172      	lsls	r2, r6, #5
          hhcd->hc[chnum].xfer_count += pktcnt;
 8002ddc:	443b      	add	r3, r7
 8002dde:	f8c8 3038 	str.w	r3, [r8, #56]	@ 0x38
          if ((hhcd->hc[chnum].max_packet == pktcnt) && (xferSizePktCnt > 0U))
 8002de2:	f8b8 3028 	ldrh.w	r3, [r8, #40]	@ 0x28
 8002de6:	429f      	cmp	r7, r3
 8002de8:	d064      	beq.n	8002eb4 <HAL_HCD_IRQHandler+0x794>
      USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8002dea:	6825      	ldr	r5, [r4, #0]
 8002dec:	e4fa      	b.n	80027e4 <HAL_HCD_IRQHandler+0xc4>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NYET))
 8002dee:	4649      	mov	r1, r9
 8002df0:	6820      	ldr	r0, [r4, #0]
 8002df2:	f001 ff91 	bl	8004d18 <USB_ReadChInterrupts>
 8002df6:	f010 0240 	ands.w	r2, r0, #64	@ 0x40
 8002dfa:	d025      	beq.n	8002e48 <HAL_HCD_IRQHandler+0x728>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
 8002dfc:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
 8002e00:	2240      	movs	r2, #64	@ 0x40
 8002e02:	445b      	add	r3, fp
 8002e04:	609a      	str	r2, [r3, #8]
    hhcd->hc[chnum].state = HC_NYET;
 8002e06:	2305      	movs	r3, #5
 8002e08:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
    if (hhcd->hc[chnum].do_ssplit == 0U)
 8002e0c:	7ebb      	ldrb	r3, [r7, #26]
 8002e0e:	b903      	cbnz	r3, 8002e12 <HAL_HCD_IRQHandler+0x6f2>
      hhcd->hc[chnum].ErrCnt = 0U;
 8002e10:	647b      	str	r3, [r7, #68]	@ 0x44
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002e12:	4649      	mov	r1, r9
 8002e14:	6820      	ldr	r0, [r4, #0]
 8002e16:	f002 fa75 	bl	8005304 <USB_HC_Halt>
 8002e1a:	6825      	ldr	r5, [r4, #0]
 8002e1c:	e532      	b.n	8002884 <HAL_HCD_IRQHandler+0x164>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_STALL))
 8002e1e:	4649      	mov	r1, r9
 8002e20:	6820      	ldr	r0, [r4, #0]
 8002e22:	f001 ff79 	bl	8004d18 <USB_ReadChInterrupts>
 8002e26:	f010 0308 	ands.w	r3, r0, #8
 8002e2a:	d02c      	beq.n	8002e86 <HAL_HCD_IRQHandler+0x766>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);
 8002e2c:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
 8002e30:	2208      	movs	r2, #8
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002e32:	4649      	mov	r1, r9
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);
 8002e34:	445b      	add	r3, fp
 8002e36:	609a      	str	r2, [r3, #8]
    hhcd->hc[chnum].state = HC_STALL;
 8002e38:	2306      	movs	r3, #6
 8002e3a:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002e3e:	6820      	ldr	r0, [r4, #0]
 8002e40:	f002 fa60 	bl	8005304 <USB_HC_Halt>
 8002e44:	6825      	ldr	r5, [r4, #0]
 8002e46:	e51d      	b.n	8002884 <HAL_HCD_IRQHandler+0x164>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NAK))
 8002e48:	4649      	mov	r1, r9
 8002e4a:	6820      	ldr	r0, [r4, #0]
 8002e4c:	9201      	str	r2, [sp, #4]
 8002e4e:	f001 ff63 	bl	8004d18 <USB_ReadChInterrupts>
 8002e52:	f010 0f10 	tst.w	r0, #16
 8002e56:	9a01      	ldr	r2, [sp, #4]
 8002e58:	f43f adba 	beq.w	80029d0 <HAL_HCD_IRQHandler+0x2b0>
    if (hhcd->hc[chnum].ep_type == EP_TYPE_INTR)
 8002e5c:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8002e60:	2b03      	cmp	r3, #3
 8002e62:	d03b      	beq.n	8002edc <HAL_HCD_IRQHandler+0x7bc>
    else if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8002e64:	f013 03fd 	ands.w	r3, r3, #253	@ 0xfd
 8002e68:	d140      	bne.n	8002eec <HAL_HCD_IRQHandler+0x7cc>
      hhcd->hc[chnum].ErrCnt = 0U;
 8002e6a:	647b      	str	r3, [r7, #68]	@ 0x44
      if ((hhcd->Init.dma_enable == 0U) || (hhcd->hc[chnum].do_csplit == 1U))
 8002e6c:	79a3      	ldrb	r3, [r4, #6]
 8002e6e:	2b00      	cmp	r3, #0
 8002e70:	d035      	beq.n	8002ede <HAL_HCD_IRQHandler+0x7be>
 8002e72:	7efb      	ldrb	r3, [r7, #27]
 8002e74:	2b01      	cmp	r3, #1
 8002e76:	d032      	beq.n	8002ede <HAL_HCD_IRQHandler+0x7be>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
 8002e78:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
 8002e7c:	445b      	add	r3, fp
 8002e7e:	2210      	movs	r2, #16
 8002e80:	6825      	ldr	r5, [r4, #0]
 8002e82:	609a      	str	r2, [r3, #8]
 8002e84:	e4fe      	b.n	8002884 <HAL_HCD_IRQHandler+0x164>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_NAK))
 8002e86:	4649      	mov	r1, r9
 8002e88:	6820      	ldr	r0, [r4, #0]
 8002e8a:	9301      	str	r3, [sp, #4]
 8002e8c:	f001 ff44 	bl	8004d18 <USB_ReadChInterrupts>
 8002e90:	06c2      	lsls	r2, r0, #27
 8002e92:	d546      	bpl.n	8002f22 <HAL_HCD_IRQHandler+0x802>
    hhcd->hc[chnum].ErrCnt = 0U;
 8002e94:	9b01      	ldr	r3, [sp, #4]
 8002e96:	647b      	str	r3, [r7, #68]	@ 0x44
    hhcd->hc[chnum].state = HC_NAK;
 8002e98:	2304      	movs	r3, #4
 8002e9a:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
    if (hhcd->hc[chnum].do_ping == 0U)
 8002e9e:	7e7b      	ldrb	r3, [r7, #25]
 8002ea0:	b91b      	cbnz	r3, 8002eaa <HAL_HCD_IRQHandler+0x78a>
      if (hhcd->hc[chnum].speed == HCD_DEVICE_SPEED_HIGH)
 8002ea2:	7e3b      	ldrb	r3, [r7, #24]
 8002ea4:	b90b      	cbnz	r3, 8002eaa <HAL_HCD_IRQHandler+0x78a>
        hhcd->hc[chnum].do_ping = 1U;
 8002ea6:	2301      	movs	r3, #1
 8002ea8:	767b      	strb	r3, [r7, #25]
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002eaa:	4649      	mov	r1, r9
 8002eac:	6820      	ldr	r0, [r4, #0]
 8002eae:	f002 fa29 	bl	8005304 <USB_HC_Halt>
 8002eb2:	e7e1      	b.n	8002e78 <HAL_HCD_IRQHandler+0x758>
          if ((hhcd->hc[chnum].max_packet == pktcnt) && (xferSizePktCnt > 0U))
 8002eb4:	4b7f      	ldr	r3, [pc, #508]	@ (80030b4 <HAL_HCD_IRQHandler+0x994>)
 8002eb6:	400b      	ands	r3, r1
 8002eb8:	2b00      	cmp	r3, #0
 8002eba:	d096      	beq.n	8002dea <HAL_HCD_IRQHandler+0x6ca>
            tmpreg = USBx_HC(chnum)->HCCHAR;
 8002ebc:	58ab      	ldr	r3, [r5, r2]
            tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8002ebe:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
            tmpreg |= USB_OTG_HCCHAR_CHENA;
 8002ec2:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
            USBx_HC(chnum)->HCCHAR = tmpreg;
 8002ec6:	50ab      	str	r3, [r5, r2]
            hhcd->hc[chnum].toggle_in ^= 1U;
 8002ec8:	233c      	movs	r3, #60	@ 0x3c
 8002eca:	fb03 4306 	mla	r3, r3, r6, r4
 8002ece:	f893 203c 	ldrb.w	r2, [r3, #60]	@ 0x3c
 8002ed2:	f082 0201 	eor.w	r2, r2, #1
 8002ed6:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
 8002eda:	e786      	b.n	8002dea <HAL_HCD_IRQHandler+0x6ca>
      hhcd->hc[chnum].ErrCnt = 0U;
 8002edc:	647a      	str	r2, [r7, #68]	@ 0x44
        hhcd->hc[chnum].state = HC_NAK;
 8002ede:	2304      	movs	r3, #4
        (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002ee0:	4649      	mov	r1, r9
        hhcd->hc[chnum].state = HC_NAK;
 8002ee2:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
        (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002ee6:	6820      	ldr	r0, [r4, #0]
 8002ee8:	f002 fa0c 	bl	8005304 <USB_HC_Halt>
    if (hhcd->hc[chnum].do_csplit == 1U)
 8002eec:	7efb      	ldrb	r3, [r7, #27]
 8002eee:	2b01      	cmp	r3, #1
      __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 8002ef0:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
    if (hhcd->hc[chnum].do_csplit == 1U)
 8002ef4:	d1c2      	bne.n	8002e7c <HAL_HCD_IRQHandler+0x75c>
      hhcd->hc[chnum].do_csplit = 0U;
 8002ef6:	2200      	movs	r2, #0
 8002ef8:	76fa      	strb	r2, [r7, #27]
      __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 8002efa:	eb03 020b 	add.w	r2, r3, fp
 8002efe:	6851      	ldr	r1, [r2, #4]
 8002f00:	f421 3180 	bic.w	r1, r1, #65536	@ 0x10000
 8002f04:	6051      	str	r1, [r2, #4]
      __HAL_HCD_UNMASK_ACK_HC_INT(chnum);
 8002f06:	68d1      	ldr	r1, [r2, #12]
 8002f08:	f041 0120 	orr.w	r1, r1, #32
 8002f0c:	60d1      	str	r1, [r2, #12]
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
 8002f0e:	e7b5      	b.n	8002e7c <HAL_HCD_IRQHandler+0x75c>
        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8002f10:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
        hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8002f14:	f887 104c 	strb.w	r1, [r7, #76]	@ 0x4c
        if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL) ||
 8002f18:	f013 0ffd 	tst.w	r3, #253	@ 0xfd
 8002f1c:	f47f aed8 	bne.w	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
 8002f20:	e6f6      	b.n	8002d10 <HAL_HCD_IRQHandler+0x5f0>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_TXERR))
 8002f22:	4649      	mov	r1, r9
 8002f24:	6820      	ldr	r0, [r4, #0]
 8002f26:	f001 fef7 	bl	8004d18 <USB_ReadChInterrupts>
 8002f2a:	0603      	lsls	r3, r0, #24
 8002f2c:	d539      	bpl.n	8002fa2 <HAL_HCD_IRQHandler+0x882>
    if (hhcd->Init.dma_enable == 0U)
 8002f2e:	79a3      	ldrb	r3, [r4, #6]
 8002f30:	b37b      	cbz	r3, 8002f92 <HAL_HCD_IRQHandler+0x872>
      hhcd->hc[chnum].ErrCnt++;
 8002f32:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8002f34:	3301      	adds	r3, #1
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8002f36:	2b02      	cmp	r3, #2
      hhcd->hc[chnum].ErrCnt++;
 8002f38:	647b      	str	r3, [r7, #68]	@ 0x44
      if (hhcd->hc[chnum].ErrCnt > 2U)
 8002f3a:	d820      	bhi.n	8002f7e <HAL_HCD_IRQHandler+0x85e>
        hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8002f3c:	2302      	movs	r3, #2
 8002f3e:	f887 304c 	strb.w	r3, [r7, #76]	@ 0x4c
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
 8002f42:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
 8002f46:	2280      	movs	r2, #128	@ 0x80
 8002f48:	6825      	ldr	r5, [r4, #0]
 8002f4a:	445b      	add	r3, fp
 8002f4c:	609a      	str	r2, [r3, #8]
 8002f4e:	e499      	b.n	8002884 <HAL_HCD_IRQHandler+0x164>
          hhcd->hc[chnum].NyetErrCnt++;
 8002f50:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8002f52:	3301      	adds	r3, #1
          if (hhcd->hc[chnum].NyetErrCnt > 2U)
 8002f54:	428b      	cmp	r3, r1
          hhcd->hc[chnum].NyetErrCnt++;
 8002f56:	64bb      	str	r3, [r7, #72]	@ 0x48
          if (hhcd->hc[chnum].NyetErrCnt > 2U)
 8002f58:	d90b      	bls.n	8002f72 <HAL_HCD_IRQHandler+0x852>
            hhcd->hc[chnum].NyetErrCnt = 0U;
 8002f5a:	2300      	movs	r3, #0
 8002f5c:	64bb      	str	r3, [r7, #72]	@ 0x48
            hhcd->hc[chnum].do_csplit = 0U;
 8002f5e:	76fb      	strb	r3, [r7, #27]
            if (hhcd->hc[chnum].ErrCnt < 3U)
 8002f60:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8002f62:	428b      	cmp	r3, r1
 8002f64:	d800      	bhi.n	8002f68 <HAL_HCD_IRQHandler+0x848>
              hhcd->hc[chnum].ep_ss_schedule = 1U;
 8002f66:	7738      	strb	r0, [r7, #28]
          __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 8002f68:	6853      	ldr	r3, [r2, #4]
 8002f6a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8002f6e:	6053      	str	r3, [r2, #4]
        hhcd->hc[chnum].urb_state = URB_ERROR;
 8002f70:	e6ab      	b.n	8002cca <HAL_HCD_IRQHandler+0x5aa>
            hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8002f72:	f887 104c 	strb.w	r1, [r7, #76]	@ 0x4c
 8002f76:	e6ab      	b.n	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
          hhcd->hc[chnum].do_csplit = 0U;
 8002f78:	f8a7 301b 	strh.w	r3, [r7, #27]
 8002f7c:	e7f4      	b.n	8002f68 <HAL_HCD_IRQHandler+0x848>
        hhcd->hc[chnum].urb_state = URB_ERROR;
 8002f7e:	2204      	movs	r2, #4
        hhcd->hc[chnum].ErrCnt = 0U;
 8002f80:	2300      	movs	r3, #0
        HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
 8002f82:	4649      	mov	r1, r9
 8002f84:	4620      	mov	r0, r4
        hhcd->hc[chnum].urb_state = URB_ERROR;
 8002f86:	f887 204c 	strb.w	r2, [r7, #76]	@ 0x4c
        hhcd->hc[chnum].ErrCnt = 0U;
 8002f8a:	647b      	str	r3, [r7, #68]	@ 0x44
        HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
 8002f8c:	f003 ff34 	bl	8006df8 <HAL_HCD_HC_NotifyURBChange_Callback>
 8002f90:	e7d7      	b.n	8002f42 <HAL_HCD_IRQHandler+0x822>
      hhcd->hc[chnum].state = HC_XACTERR;
 8002f92:	2307      	movs	r3, #7
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002f94:	4649      	mov	r1, r9
      hhcd->hc[chnum].state = HC_XACTERR;
 8002f96:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
      (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002f9a:	6820      	ldr	r0, [r4, #0]
 8002f9c:	f002 f9b2 	bl	8005304 <USB_HC_Halt>
 8002fa0:	e7cf      	b.n	8002f42 <HAL_HCD_IRQHandler+0x822>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_DTERR))
 8002fa2:	4649      	mov	r1, r9
 8002fa4:	6820      	ldr	r0, [r4, #0]
 8002fa6:	f001 feb7 	bl	8004d18 <USB_ReadChInterrupts>
 8002faa:	0540      	lsls	r0, r0, #21
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002fac:	4649      	mov	r1, r9
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_DTERR))
 8002fae:	d50d      	bpl.n	8002fcc <HAL_HCD_IRQHandler+0x8ac>
    hhcd->hc[chnum].state = HC_DATATGLERR;
 8002fb0:	2309      	movs	r3, #9
 8002fb2:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
    (void)USB_HC_Halt(hhcd->Instance, chnum);
 8002fb6:	6820      	ldr	r0, [r4, #0]
 8002fb8:	f002 f9a4 	bl	8005304 <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);
 8002fbc:	f505 63a0 	add.w	r3, r5, #1280	@ 0x500
 8002fc0:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8002fc4:	6825      	ldr	r5, [r4, #0]
 8002fc6:	445b      	add	r3, fp
 8002fc8:	609a      	str	r2, [r3, #8]
 8002fca:	e45b      	b.n	8002884 <HAL_HCD_IRQHandler+0x164>
  else if (__HAL_HCD_GET_CH_FLAG(hhcd, chnum, USB_OTG_HCINT_CHH))
 8002fcc:	6820      	ldr	r0, [r4, #0]
 8002fce:	f001 fea3 	bl	8004d18 <USB_ReadChInterrupts>
 8002fd2:	0781      	lsls	r1, r0, #30
 8002fd4:	f57f acfc 	bpl.w	80029d0 <HAL_HCD_IRQHandler+0x2b0>
    __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_CHH);
 8002fd8:	f505 65a0 	add.w	r5, r5, #1280	@ 0x500
 8002fdc:	2302      	movs	r3, #2
 8002fde:	eb05 020b 	add.w	r2, r5, fp
 8002fe2:	6093      	str	r3, [r2, #8]
    if (hhcd->hc[chnum].state == HC_XFRC)
 8002fe4:	f897 304d 	ldrb.w	r3, [r7, #77]	@ 0x4d
 8002fe8:	3b01      	subs	r3, #1
 8002fea:	2b08      	cmp	r3, #8
 8002fec:	f63f acf0 	bhi.w	80029d0 <HAL_HCD_IRQHandler+0x2b0>
 8002ff0:	a101      	add	r1, pc, #4	@ (adr r1, 8002ff8 <HAL_HCD_IRQHandler+0x8d8>)
 8002ff2:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8002ff6:	bf00      	nop
 8002ff8:	0800301d 	.word	0x0800301d
 8002ffc:	080029d1 	.word	0x080029d1
 8003000:	080030a5 	.word	0x080030a5
 8003004:	08003087 	.word	0x08003087
 8003008:	08003077 	.word	0x08003077
 800300c:	08002d63 	.word	0x08002d63
 8003010:	08003061 	.word	0x08003061
 8003014:	080029d1 	.word	0x080029d1
 8003018:	08003061 	.word	0x08003061
      if ((hhcd->hc[chnum].ep_type == EP_TYPE_BULK) ||
 800301c:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
      hhcd->hc[chnum].urb_state = URB_DONE;
 8003020:	f240 2201 	movw	r2, #513	@ 0x201
      if ((hhcd->hc[chnum].ep_type == EP_TYPE_BULK) ||
 8003024:	3b02      	subs	r3, #2
      hhcd->hc[chnum].urb_state = URB_DONE;
 8003026:	f8a7 204c 	strh.w	r2, [r7, #76]	@ 0x4c
      if ((hhcd->hc[chnum].ep_type == EP_TYPE_BULK) ||
 800302a:	2b01      	cmp	r3, #1
 800302c:	f63f ae50 	bhi.w	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
        if (hhcd->Init.dma_enable == 0U)
 8003030:	79a3      	ldrb	r3, [r4, #6]
 8003032:	b173      	cbz	r3, 8003052 <HAL_HCD_IRQHandler+0x932>
        if ((hhcd->Init.dma_enable == 1U) && (hhcd->hc[chnum].xfer_len > 0U))
 8003034:	2b01      	cmp	r3, #1
 8003036:	f47f ae4b 	bne.w	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
 800303a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800303c:	2b00      	cmp	r3, #0
 800303e:	f43f ae47 	beq.w	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
          num_packets = (hhcd->hc[chnum].xfer_len + hhcd->hc[chnum].max_packet - 1U) / hhcd->hc[chnum].max_packet;
 8003042:	8d3a      	ldrh	r2, [r7, #40]	@ 0x28
 8003044:	3b01      	subs	r3, #1
 8003046:	4413      	add	r3, r2
 8003048:	fbb3 f3f2 	udiv	r3, r3, r2
          if ((num_packets & 1U) != 0U)
 800304c:	07da      	lsls	r2, r3, #31
 800304e:	f57f ae3f 	bpl.w	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
            hhcd->hc[chnum].toggle_out ^= 1U;
 8003052:	f897 303d 	ldrb.w	r3, [r7, #61]	@ 0x3d
 8003056:	f083 0301 	eor.w	r3, r3, #1
 800305a:	f887 303d 	strb.w	r3, [r7, #61]	@ 0x3d
 800305e:	e637      	b.n	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
      hhcd->hc[chnum].ErrCnt++;
 8003060:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
      hhcd->hc[chnum].state = HC_HALTED;
 8003062:	2202      	movs	r2, #2
      hhcd->hc[chnum].ErrCnt++;
 8003064:	3301      	adds	r3, #1
      hhcd->hc[chnum].state = HC_HALTED;
 8003066:	f887 204d 	strb.w	r2, [r7, #77]	@ 0x4d
      if (hhcd->hc[chnum].ErrCnt > 2U)
 800306a:	4293      	cmp	r3, r2
      hhcd->hc[chnum].ErrCnt++;
 800306c:	647b      	str	r3, [r7, #68]	@ 0x44
      if (hhcd->hc[chnum].ErrCnt > 2U)
 800306e:	d907      	bls.n	8003080 <HAL_HCD_IRQHandler+0x960>
        hhcd->hc[chnum].ErrCnt = 0U;
 8003070:	2300      	movs	r3, #0
 8003072:	647b      	str	r3, [r7, #68]	@ 0x44
 8003074:	e629      	b.n	8002cca <HAL_HCD_IRQHandler+0x5aa>
      hhcd->hc[chnum].urb_state  = URB_NOTREADY;
 8003076:	f240 2302 	movw	r3, #514	@ 0x202
 800307a:	f8a7 304c 	strh.w	r3, [r7, #76]	@ 0x4c
 800307e:	e627      	b.n	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
        hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8003080:	f887 204c 	strb.w	r2, [r7, #76]	@ 0x4c
 8003084:	e644      	b.n	8002d10 <HAL_HCD_IRQHandler+0x5f0>
      hhcd->hc[chnum].urb_state = URB_NOTREADY;
 8003086:	f240 2302 	movw	r3, #514	@ 0x202
 800308a:	f8a7 304c 	strh.w	r3, [r7, #76]	@ 0x4c
      if (hhcd->hc[chnum].do_csplit == 1U)
 800308e:	7efb      	ldrb	r3, [r7, #27]
 8003090:	2b01      	cmp	r3, #1
 8003092:	f47f ae1d 	bne.w	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
        hhcd->hc[chnum].do_csplit = 0U;
 8003096:	2300      	movs	r3, #0
 8003098:	76fb      	strb	r3, [r7, #27]
        __HAL_HCD_CLEAR_HC_CSPLT(chnum);
 800309a:	6853      	ldr	r3, [r2, #4]
 800309c:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 80030a0:	6053      	str	r3, [r2, #4]
 80030a2:	e615      	b.n	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
      if (hhcd->hc[chnum].do_csplit == 1U)
 80030a4:	7efa      	ldrb	r2, [r7, #27]
      hhcd->hc[chnum].state = HC_HALTED;
 80030a6:	2302      	movs	r3, #2
      if (hhcd->hc[chnum].do_csplit == 1U)
 80030a8:	2a01      	cmp	r2, #1
      hhcd->hc[chnum].state = HC_HALTED;
 80030aa:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
      if (hhcd->hc[chnum].do_csplit == 1U)
 80030ae:	f47f ae0f 	bne.w	8002cd0 <HAL_HCD_IRQHandler+0x5b0>
 80030b2:	e60b      	b.n	8002ccc <HAL_HCD_IRQHandler+0x5ac>
 80030b4:	1ff80000 	.word	0x1ff80000

080030b8 <HAL_HCD_Start>:
  __HAL_LOCK(hhcd);
 80030b8:	f890 33d4 	ldrb.w	r3, [r0, #980]	@ 0x3d4
 80030bc:	2b01      	cmp	r3, #1
 80030be:	d00f      	beq.n	80030e0 <HAL_HCD_Start+0x28>
 80030c0:	2101      	movs	r1, #1
{
 80030c2:	b510      	push	{r4, lr}
 80030c4:	4604      	mov	r4, r0
  (void)USB_DriveVbus(hhcd->Instance, 1U);
 80030c6:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
 80030c8:	f884 13d4 	strb.w	r1, [r4, #980]	@ 0x3d4
  (void)USB_DriveVbus(hhcd->Instance, 1U);
 80030cc:	f001 fed4 	bl	8004e78 <USB_DriveVbus>
  __HAL_HCD_ENABLE(hhcd);
 80030d0:	6820      	ldr	r0, [r4, #0]
 80030d2:	f001 fb5b 	bl	800478c <USB_EnableGlobalInt>
  __HAL_UNLOCK(hhcd);
 80030d6:	2300      	movs	r3, #0
  return HAL_OK;
 80030d8:	4618      	mov	r0, r3
  __HAL_UNLOCK(hhcd);
 80030da:	f884 33d4 	strb.w	r3, [r4, #980]	@ 0x3d4
}
 80030de:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
 80030e0:	2002      	movs	r0, #2
}
 80030e2:	4770      	bx	lr

080030e4 <HAL_HCD_Stop>:
  __HAL_LOCK(hhcd);
 80030e4:	f890 33d4 	ldrb.w	r3, [r0, #980]	@ 0x3d4
 80030e8:	2b01      	cmp	r3, #1
 80030ea:	d00c      	beq.n	8003106 <HAL_HCD_Stop+0x22>
 80030ec:	2301      	movs	r3, #1
{
 80030ee:	b510      	push	{r4, lr}
 80030f0:	4604      	mov	r4, r0
  (void)USB_StopHost(hhcd->Instance);
 80030f2:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
 80030f4:	f884 33d4 	strb.w	r3, [r4, #980]	@ 0x3d4
  (void)USB_StopHost(hhcd->Instance);
 80030f8:	f002 f97e 	bl	80053f8 <USB_StopHost>
  __HAL_UNLOCK(hhcd);
 80030fc:	2300      	movs	r3, #0
  return HAL_OK;
 80030fe:	4618      	mov	r0, r3
  __HAL_UNLOCK(hhcd);
 8003100:	f884 33d4 	strb.w	r3, [r4, #980]	@ 0x3d4
}
 8003104:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
 8003106:	2002      	movs	r0, #2
}
 8003108:	4770      	bx	lr
 800310a:	bf00      	nop

0800310c <HAL_HCD_ResetPort>:
  return (USB_ResetPort(hhcd->Instance));
 800310c:	6800      	ldr	r0, [r0, #0]
 800310e:	f001 be93 	b.w	8004e38 <USB_ResetPort>
 8003112:	bf00      	nop

08003114 <HAL_HCD_HC_GetURBState>:
  return hhcd->hc[chnum].urb_state;
 8003114:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 8003118:	eb00 0081 	add.w	r0, r0, r1, lsl #2
}
 800311c:	f890 004c 	ldrb.w	r0, [r0, #76]	@ 0x4c
 8003120:	4770      	bx	lr
 8003122:	bf00      	nop

08003124 <HAL_HCD_GetCurrentSpeed>:
  return (USB_GetHostSpeed(hhcd->Instance));
 8003124:	6800      	ldr	r0, [r0, #0]
 8003126:	f001 becf 	b.w	8004ec8 <USB_GetHostSpeed>
 800312a:	bf00      	nop

0800312c <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 800312c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8003130:	6807      	ldr	r7, [r0, #0]
{
 8003132:	b089      	sub	sp, #36	@ 0x24
 8003134:	4604      	mov	r4, r0
  uint32_t epnum;
  uint32_t fifoemptymsk;
  uint32_t RegVal;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8003136:	4638      	mov	r0, r7
 8003138:	f001 fe20 	bl	8004d7c <USB_GetMode>
 800313c:	b110      	cbz	r0, 8003144 <HAL_PCD_IRQHandler+0x18>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= RegVal;
    }
  }
}
 800313e:	b009      	add	sp, #36	@ 0x24
 8003140:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 8003144:	4605      	mov	r5, r0
 8003146:	6820      	ldr	r0, [r4, #0]
 8003148:	f001 fde2 	bl	8004d10 <USB_ReadInterrupts>
 800314c:	2800      	cmp	r0, #0
 800314e:	d0f6      	beq.n	800313e <HAL_PCD_IRQHandler+0x12>
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 8003150:	f8d7 3808 	ldr.w	r3, [r7, #2056]	@ 0x808
 8003154:	f507 6200 	add.w	r2, r7, #2048	@ 0x800
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8003158:	6820      	ldr	r0, [r4, #0]
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 800315a:	f3c3 230d 	ubfx	r3, r3, #8, #14
 800315e:	9203      	str	r2, [sp, #12]
 8003160:	f8c4 34d4 	str.w	r3, [r4, #1236]	@ 0x4d4
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8003164:	f001 fdd4 	bl	8004d10 <USB_ReadInterrupts>
 8003168:	f010 0f02 	tst.w	r0, #2
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 800316c:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 800316e:	d003      	beq.n	8003178 <HAL_PCD_IRQHandler+0x4c>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8003170:	6943      	ldr	r3, [r0, #20]
 8003172:	f003 0302 	and.w	r3, r3, #2
 8003176:	6143      	str	r3, [r0, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8003178:	f001 fdca 	bl	8004d10 <USB_ReadInterrupts>
 800317c:	f010 0f10 	tst.w	r0, #16
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8003180:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8003182:	d014      	beq.n	80031ae <HAL_PCD_IRQHandler+0x82>
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8003184:	6983      	ldr	r3, [r0, #24]
 8003186:	f023 0310 	bic.w	r3, r3, #16
 800318a:	6183      	str	r3, [r0, #24]
      RegVal = USBx->GRXSTSP;
 800318c:	6a3e      	ldr	r6, [r7, #32]
      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 800318e:	f406 13f0 	and.w	r3, r6, #1966080	@ 0x1e0000
      ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
 8003192:	f006 080f 	and.w	r8, r6, #15
      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 8003196:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800319a:	f000 82da 	beq.w	8003752 <HAL_PCD_IRQHandler+0x626>
      else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
 800319e:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 80031a2:	f000 827e 	beq.w	80036a2 <HAL_PCD_IRQHandler+0x576>
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80031a6:	6983      	ldr	r3, [r0, #24]
 80031a8:	f043 0310 	orr.w	r3, r3, #16
 80031ac:	6183      	str	r3, [r0, #24]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 80031ae:	f001 fdaf 	bl	8004d10 <USB_ReadInterrupts>
 80031b2:	f410 2f00 	tst.w	r0, #524288	@ 0x80000
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 80031b6:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 80031b8:	f040 8210 	bne.w	80035dc <HAL_PCD_IRQHandler+0x4b0>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 80031bc:	f001 fda8 	bl	8004d10 <USB_ReadInterrupts>
 80031c0:	0346      	lsls	r6, r0, #13
 80031c2:	f100 8167 	bmi.w	8003494 <HAL_PCD_IRQHandler+0x368>
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 80031c6:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 80031c8:	f001 fda2 	bl	8004d10 <USB_ReadInterrupts>
 80031cc:	2800      	cmp	r0, #0
 80031ce:	f2c0 80d9 	blt.w	8003384 <HAL_PCD_IRQHandler+0x258>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 80031d2:	6820      	ldr	r0, [r4, #0]
 80031d4:	f001 fd9c 	bl	8004d10 <USB_ReadInterrupts>
 80031d8:	0502      	lsls	r2, r0, #20
 80031da:	f100 8097 	bmi.w	800330c <HAL_PCD_IRQHandler+0x1e0>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 80031de:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
 80031e0:	f001 fd96 	bl	8004d10 <USB_ReadInterrupts>
 80031e4:	0106      	lsls	r6, r0, #4
 80031e6:	d514      	bpl.n	8003212 <HAL_PCD_IRQHandler+0xe6>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
 80031e8:	6822      	ldr	r2, [r4, #0]
 80031ea:	6953      	ldr	r3, [r2, #20]
 80031ec:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 80031f0:	6153      	str	r3, [r2, #20]
      if (hpcd->LPM_State == LPM_L0)
 80031f2:	f894 34cc 	ldrb.w	r3, [r4, #1228]	@ 0x4cc
 80031f6:	2b00      	cmp	r3, #0
 80031f8:	f040 823c 	bne.w	8003674 <HAL_PCD_IRQHandler+0x548>
        hpcd->LPM_State = LPM_L1;
 80031fc:	2101      	movs	r1, #1
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 80031fe:	4620      	mov	r0, r4
        hpcd->LPM_State = LPM_L1;
 8003200:	f884 14cc 	strb.w	r1, [r4, #1228]	@ 0x4cc
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 8003204:	6d53      	ldr	r3, [r2, #84]	@ 0x54
 8003206:	f3c3 0383 	ubfx	r3, r3, #2, #4
 800320a:	f8c4 34d0 	str.w	r3, [r4, #1232]	@ 0x4d0
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 800320e:	f000 fc63 	bl	8003ad8 <HAL_PCDEx_LPM_Callback>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8003212:	6820      	ldr	r0, [r4, #0]
 8003214:	f001 fd7c 	bl	8004d10 <USB_ReadInterrupts>
 8003218:	04c0      	lsls	r0, r0, #19
 800321a:	f100 80dd 	bmi.w	80033d8 <HAL_PCD_IRQHandler+0x2ac>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 800321e:	6820      	ldr	r0, [r4, #0]
 8003220:	f001 fd76 	bl	8004d10 <USB_ReadInterrupts>
 8003224:	f410 5f00 	tst.w	r0, #8192	@ 0x2000
      (void)USB_ActivateSetup(hpcd->Instance);
 8003228:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 800322a:	f040 80be 	bne.w	80033aa <HAL_PCD_IRQHandler+0x27e>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 800322e:	f001 fd6f 	bl	8004d10 <USB_ReadInterrupts>
 8003232:	0701      	lsls	r1, r0, #28
 8003234:	f100 8125 	bmi.w	8003482 <HAL_PCD_IRQHandler+0x356>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
 8003238:	6820      	ldr	r0, [r4, #0]
 800323a:	f001 fd69 	bl	8004d10 <USB_ReadInterrupts>
 800323e:	0602      	lsls	r2, r0, #24
 8003240:	d51c      	bpl.n	800327c <HAL_PCD_IRQHandler+0x150>
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 8003242:	69bb      	ldr	r3, [r7, #24]
 8003244:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8003248:	61bb      	str	r3, [r7, #24]
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800324a:	7923      	ldrb	r3, [r4, #4]
 800324c:	2b01      	cmp	r3, #1
 800324e:	d915      	bls.n	800327c <HAL_PCD_IRQHandler+0x150>
 8003250:	4626      	mov	r6, r4
 8003252:	2501      	movs	r5, #1
 8003254:	e003      	b.n	800325e <HAL_PCD_IRQHandler+0x132>
 8003256:	3501      	adds	r5, #1
 8003258:	3624      	adds	r6, #36	@ 0x24
 800325a:	42ab      	cmp	r3, r5
 800325c:	d90e      	bls.n	800327c <HAL_PCD_IRQHandler+0x150>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800325e:	f896 227b 	ldrb.w	r2, [r6, #635]	@ 0x27b
 8003262:	2a01      	cmp	r2, #1
 8003264:	d1f7      	bne.n	8003256 <HAL_PCD_IRQHandler+0x12a>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003266:	eb05 01c5 	add.w	r1, r5, r5, lsl #3
  }

  /* Stop Xfer */
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800326a:	6820      	ldr	r0, [r4, #0]
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800326c:	eb04 0181 	add.w	r1, r4, r1, lsl #2
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8003270:	f501 7115 	add.w	r1, r1, #596	@ 0x254
 8003274:	f001 fc52 	bl	8004b1c <USB_EPStopXfer>

  return ret;
 8003278:	7923      	ldrb	r3, [r4, #4]
 800327a:	e7ec      	b.n	8003256 <HAL_PCD_IRQHandler+0x12a>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 800327c:	6820      	ldr	r0, [r4, #0]
 800327e:	f001 fd47 	bl	8004d10 <USB_ReadInterrupts>
 8003282:	02c3      	lsls	r3, r0, #11
 8003284:	d540      	bpl.n	8003308 <HAL_PCD_IRQHandler+0x1dc>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003286:	7923      	ldrb	r3, [r4, #4]
 8003288:	2b01      	cmp	r3, #1
 800328a:	d91f      	bls.n	80032cc <HAL_PCD_IRQHandler+0x1a0>
 800328c:	f507 6812 	add.w	r8, r7, #2336	@ 0x920
 8003290:	4626      	mov	r6, r4
 8003292:	2501      	movs	r5, #1
 8003294:	e005      	b.n	80032a2 <HAL_PCD_IRQHandler+0x176>
 8003296:	3501      	adds	r5, #1
 8003298:	f108 0820 	add.w	r8, r8, #32
 800329c:	3624      	adds	r6, #36	@ 0x24
 800329e:	42ab      	cmp	r3, r5
 80032a0:	d914      	bls.n	80032cc <HAL_PCD_IRQHandler+0x1a0>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80032a2:	f896 203c 	ldrb.w	r2, [r6, #60]	@ 0x3c
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 80032a6:	f8d8 1000 	ldr.w	r1, [r8]
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80032aa:	2a01      	cmp	r2, #1
 80032ac:	d1f3      	bne.n	8003296 <HAL_PCD_IRQHandler+0x16a>
 80032ae:	2900      	cmp	r1, #0
 80032b0:	daf1      	bge.n	8003296 <HAL_PCD_IRQHandler+0x16a>
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80032b2:	2324      	movs	r3, #36	@ 0x24
 80032b4:	f005 010f 	and.w	r1, r5, #15
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80032b8:	6820      	ldr	r0, [r4, #0]
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80032ba:	fb03 4101 	mla	r1, r3, r1, r4
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 80032be:	f886 203b 	strb.w	r2, [r6, #59]	@ 0x3b
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80032c2:	3114      	adds	r1, #20
 80032c4:	f001 fc2a 	bl	8004b1c <USB_EPStopXfer>
  return ret;
 80032c8:	7923      	ldrb	r3, [r4, #4]
 80032ca:	e7e4      	b.n	8003296 <HAL_PCD_IRQHandler+0x16a>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 80032cc:	6820      	ldr	r0, [r4, #0]
 80032ce:	6943      	ldr	r3, [r0, #20]
 80032d0:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 80032d4:	6143      	str	r3, [r0, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 80032d6:	f001 fd1b 	bl	8004d10 <USB_ReadInterrupts>
 80032da:	0286      	lsls	r6, r0, #10
 80032dc:	d421      	bmi.n	8003322 <HAL_PCD_IRQHandler+0x1f6>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 80032de:	6820      	ldr	r0, [r4, #0]
 80032e0:	f001 fd16 	bl	8004d10 <USB_ReadInterrupts>
 80032e4:	0040      	lsls	r0, r0, #1
 80032e6:	f100 80c3 	bmi.w	8003470 <HAL_PCD_IRQHandler+0x344>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 80032ea:	6820      	ldr	r0, [r4, #0]
 80032ec:	f001 fd10 	bl	8004d10 <USB_ReadInterrupts>
 80032f0:	0741      	lsls	r1, r0, #29
 80032f2:	f57f af24 	bpl.w	800313e <HAL_PCD_IRQHandler+0x12>
      RegVal = hpcd->Instance->GOTGINT;
 80032f6:	6823      	ldr	r3, [r4, #0]
 80032f8:	685d      	ldr	r5, [r3, #4]
      if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 80032fa:	076a      	lsls	r2, r5, #29
 80032fc:	f100 8246 	bmi.w	800378c <HAL_PCD_IRQHandler+0x660>
      hpcd->Instance->GOTGINT |= RegVal;
 8003300:	685a      	ldr	r2, [r3, #4]
 8003302:	432a      	orrs	r2, r5
 8003304:	605a      	str	r2, [r3, #4]
 8003306:	e71a      	b.n	800313e <HAL_PCD_IRQHandler+0x12>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8003308:	6820      	ldr	r0, [r4, #0]
 800330a:	e7e4      	b.n	80032d6 <HAL_PCD_IRQHandler+0x1aa>
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 800330c:	9b03      	ldr	r3, [sp, #12]
 800330e:	689b      	ldr	r3, [r3, #8]
 8003310:	07db      	lsls	r3, r3, #31
 8003312:	f100 8240 	bmi.w	8003796 <HAL_PCD_IRQHandler+0x66a>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 8003316:	6820      	ldr	r0, [r4, #0]
 8003318:	6943      	ldr	r3, [r0, #20]
 800331a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800331e:	6143      	str	r3, [r0, #20]
 8003320:	e75e      	b.n	80031e0 <HAL_PCD_IRQHandler+0xb4>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003322:	7926      	ldrb	r6, [r4, #4]
 8003324:	2e01      	cmp	r6, #1
 8003326:	d927      	bls.n	8003378 <HAL_PCD_IRQHandler+0x24c>
 8003328:	f507 6232 	add.w	r2, r7, #2848	@ 0xb20
 800332c:	4623      	mov	r3, r4
 800332e:	2101      	movs	r1, #1
 8003330:	e003      	b.n	800333a <HAL_PCD_IRQHandler+0x20e>
 8003332:	42b1      	cmp	r1, r6
 8003334:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 8003338:	d01e      	beq.n	8003378 <HAL_PCD_IRQHandler+0x24c>
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 800333a:	f893 027c 	ldrb.w	r0, [r3, #636]	@ 0x27c
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800333e:	3101      	adds	r1, #1
        RegVal = USBx_OUTEP(epnum)->DOEPCTL;
 8003340:	6815      	ldr	r5, [r2, #0]
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003342:	3220      	adds	r2, #32
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8003344:	2801      	cmp	r0, #1
 8003346:	d1f4      	bne.n	8003332 <HAL_PCD_IRQHandler+0x206>
 8003348:	2d00      	cmp	r5, #0
            ((RegVal & (0x1U << 16)) == (hpcd->FrameNumber & 0x1U)))
 800334a:	f405 3c80 	and.w	ip, r5, #65536	@ 0x10000
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 800334e:	daf0      	bge.n	8003332 <HAL_PCD_IRQHandler+0x206>
            ((RegVal & (0x1U << 16)) == (hpcd->FrameNumber & 0x1U)))
 8003350:	f8d4 54d4 	ldr.w	r5, [r4, #1236]	@ 0x4d4
 8003354:	f005 0501 	and.w	r5, r5, #1
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 8003358:	45ac      	cmp	ip, r5
 800335a:	d1ea      	bne.n	8003332 <HAL_PCD_IRQHandler+0x206>
          hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
 800335c:	f883 027b 	strb.w	r0, [r3, #635]	@ 0x27b
          USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
 8003360:	69b8      	ldr	r0, [r7, #24]
 8003362:	f040 0080 	orr.w	r0, r0, #128	@ 0x80
 8003366:	61b8      	str	r0, [r7, #24]
          if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
 8003368:	6978      	ldr	r0, [r7, #20]
 800336a:	0605      	lsls	r5, r0, #24
 800336c:	d4e1      	bmi.n	8003332 <HAL_PCD_IRQHandler+0x206>
            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
 800336e:	9a03      	ldr	r2, [sp, #12]
 8003370:	6853      	ldr	r3, [r2, #4]
 8003372:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8003376:	6053      	str	r3, [r2, #4]
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8003378:	6820      	ldr	r0, [r4, #0]
 800337a:	6943      	ldr	r3, [r0, #20]
 800337c:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8003380:	6143      	str	r3, [r0, #20]
 8003382:	e7ad      	b.n	80032e0 <HAL_PCD_IRQHandler+0x1b4>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8003384:	9a03      	ldr	r2, [sp, #12]
 8003386:	6853      	ldr	r3, [r2, #4]
 8003388:	f023 0301 	bic.w	r3, r3, #1
 800338c:	6053      	str	r3, [r2, #4]
      if (hpcd->LPM_State == LPM_L1)
 800338e:	f894 34cc 	ldrb.w	r3, [r4, #1228]	@ 0x4cc
 8003392:	2b01      	cmp	r3, #1
 8003394:	f000 817e 	beq.w	8003694 <HAL_PCD_IRQHandler+0x568>
        HAL_PCD_ResumeCallback(hpcd);
 8003398:	4620      	mov	r0, r4
 800339a:	f003 fca9 	bl	8006cf0 <HAL_PCD_ResumeCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 800339e:	6820      	ldr	r0, [r4, #0]
 80033a0:	6943      	ldr	r3, [r0, #20]
 80033a2:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 80033a6:	6143      	str	r3, [r0, #20]
 80033a8:	e714      	b.n	80031d4 <HAL_PCD_IRQHandler+0xa8>
      (void)USB_ActivateSetup(hpcd->Instance);
 80033aa:	f001 fceb 	bl	8004d84 <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 80033ae:	6820      	ldr	r0, [r4, #0]
 80033b0:	f001 fa42 	bl	8004838 <USB_GetDevSpeed>
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 80033b4:	6825      	ldr	r5, [r4, #0]
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 80033b6:	71e0      	strb	r0, [r4, #7]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 80033b8:	f000 fca6 	bl	8003d08 <HAL_RCC_GetHCLKFreq>
 80033bc:	79e2      	ldrb	r2, [r4, #7]
 80033be:	4601      	mov	r1, r0
 80033c0:	4628      	mov	r0, r5
 80033c2:	f001 f969 	bl	8004698 <USB_SetTurnaroundTime>
      HAL_PCD_ResetCallback(hpcd);
 80033c6:	4620      	mov	r0, r4
 80033c8:	f003 fc64 	bl	8006c94 <HAL_PCD_ResetCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 80033cc:	6820      	ldr	r0, [r4, #0]
 80033ce:	6943      	ldr	r3, [r0, #20]
 80033d0:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80033d4:	6143      	str	r3, [r0, #20]
 80033d6:	e72a      	b.n	800322e <HAL_PCD_IRQHandler+0x102>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80033d8:	9a03      	ldr	r2, [sp, #12]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 80033da:	2110      	movs	r1, #16
 80033dc:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80033de:	6853      	ldr	r3, [r2, #4]
 80033e0:	f023 0301 	bic.w	r3, r3, #1
 80033e4:	6053      	str	r3, [r2, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 80033e6:	f001 f9d9 	bl	800479c <USB_FlushTxFifo>
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80033ea:	7920      	ldrb	r0, [r4, #4]
 80033ec:	b1d8      	cbz	r0, 8003426 <HAL_PCD_IRQHandler+0x2fa>
 80033ee:	f507 6310 	add.w	r3, r7, #2304	@ 0x900
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 80033f2:	f64f 317f 	movw	r1, #64383	@ 0xfb7f
 80033f6:	6099      	str	r1, [r3, #8]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80033f8:	3501      	adds	r5, #1
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 80033fa:	681a      	ldr	r2, [r3, #0]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80033fc:	3320      	adds	r3, #32
 80033fe:	4285      	cmp	r5, r0
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8003400:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
 8003404:	f843 2c20 	str.w	r2, [r3, #-32]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 8003408:	f8c3 11e8 	str.w	r1, [r3, #488]	@ 0x1e8
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 800340c:	f8d3 21e0 	ldr.w	r2, [r3, #480]	@ 0x1e0
 8003410:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
 8003414:	f8c3 21e0 	str.w	r2, [r3, #480]	@ 0x1e0
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8003418:	f8d3 21e0 	ldr.w	r2, [r3, #480]	@ 0x1e0
 800341c:	f042 6200 	orr.w	r2, r2, #134217728	@ 0x8000000
 8003420:	f8c3 21e0 	str.w	r2, [r3, #480]	@ 0x1e0
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8003424:	d1e7      	bne.n	80033f6 <HAL_PCD_IRQHandler+0x2ca>
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8003426:	9a03      	ldr	r2, [sp, #12]
 8003428:	69d3      	ldr	r3, [r2, #28]
 800342a:	f043 1301 	orr.w	r3, r3, #65537	@ 0x10001
 800342e:	61d3      	str	r3, [r2, #28]
      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8003430:	7be3      	ldrb	r3, [r4, #15]
 8003432:	2b00      	cmp	r3, #0
 8003434:	f040 8122 	bne.w	800367c <HAL_PCD_IRQHandler+0x550>
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 8003438:	9903      	ldr	r1, [sp, #12]
 800343a:	f242 032b 	movw	r3, #8235	@ 0x202b
 800343e:	694a      	ldr	r2, [r1, #20]
 8003440:	4313      	orrs	r3, r2
 8003442:	614b      	str	r3, [r1, #20]
        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 8003444:	690b      	ldr	r3, [r1, #16]
 8003446:	f043 030b 	orr.w	r3, r3, #11
 800344a:	610b      	str	r3, [r1, #16]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 800344c:	f8d7 3800 	ldr.w	r3, [r7, #2048]	@ 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8003450:	f204 429c 	addw	r2, r4, #1180	@ 0x49c
 8003454:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8003456:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 800345a:	f8c7 3800 	str.w	r3, [r7, #2048]	@ 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 800345e:	79a1      	ldrb	r1, [r4, #6]
 8003460:	f001 fca0 	bl	8004da4 <USB_EP0_OutStart>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8003464:	6820      	ldr	r0, [r4, #0]
 8003466:	6943      	ldr	r3, [r0, #20]
 8003468:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 800346c:	6143      	str	r3, [r0, #20]
 800346e:	e6d7      	b.n	8003220 <HAL_PCD_IRQHandler+0xf4>
      HAL_PCD_ConnectCallback(hpcd);
 8003470:	4620      	mov	r0, r4
 8003472:	f003 fc49 	bl	8006d08 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8003476:	6820      	ldr	r0, [r4, #0]
 8003478:	6943      	ldr	r3, [r0, #20]
 800347a:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 800347e:	6143      	str	r3, [r0, #20]
 8003480:	e734      	b.n	80032ec <HAL_PCD_IRQHandler+0x1c0>
      HAL_PCD_SOFCallback(hpcd);
 8003482:	4620      	mov	r0, r4
 8003484:	f003 fc02 	bl	8006c8c <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8003488:	6820      	ldr	r0, [r4, #0]
 800348a:	6943      	ldr	r3, [r0, #20]
 800348c:	f003 0308 	and.w	r3, r3, #8
 8003490:	6143      	str	r3, [r0, #20]
 8003492:	e6d2      	b.n	800323a <HAL_PCD_IRQHandler+0x10e>
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8003494:	6820      	ldr	r0, [r4, #0]
 8003496:	f001 fc4f 	bl	8004d38 <USB_ReadDevAllInEpInterrupt>
      while (ep_intr != 0U)
 800349a:	4681      	mov	r9, r0
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 800349c:	6820      	ldr	r0, [r4, #0]
      while (ep_intr != 0U)
 800349e:	f1b9 0f00 	cmp.w	r9, #0
 80034a2:	f43f ae91 	beq.w	80031c8 <HAL_PCD_IRQHandler+0x9c>
 80034a6:	f507 6610 	add.w	r6, r7, #2304	@ 0x900
 80034aa:	46a0      	mov	r8, r4
      epnum = 0U;
 80034ac:	f04f 0a00 	mov.w	sl, #0
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 80034b0:	46b3      	mov	fp, r6
 80034b2:	e9cd 7504 	strd	r7, r5, [sp, #16]
 80034b6:	4605      	mov	r5, r0
 80034b8:	e009      	b.n	80034ce <HAL_PCD_IRQHandler+0x3a2>
      while (ep_intr != 0U)
 80034ba:	ea5f 0959 	movs.w	r9, r9, lsr #1
        epnum++;
 80034be:	f10a 0a01 	add.w	sl, sl, #1
      while (ep_intr != 0U)
 80034c2:	f108 0824 	add.w	r8, r8, #36	@ 0x24
 80034c6:	f10b 0b20 	add.w	fp, fp, #32
 80034ca:	f000 8102 	beq.w	80036d2 <HAL_PCD_IRQHandler+0x5a6>
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 80034ce:	f019 0f01 	tst.w	r9, #1
 80034d2:	d0f2      	beq.n	80034ba <HAL_PCD_IRQHandler+0x38e>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 80034d4:	fa5f f68a 	uxtb.w	r6, sl
 80034d8:	4628      	mov	r0, r5
 80034da:	4631      	mov	r1, r6
 80034dc:	f001 fc3e 	bl	8004d5c <USB_ReadDevInEPInterrupt>
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 80034e0:	07c1      	lsls	r1, r0, #31
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 80034e2:	4607      	mov	r7, r0
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 80034e4:	d513      	bpl.n	800350e <HAL_PCD_IRQHandler+0x3e2>
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 80034e6:	2001      	movs	r0, #1
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80034e8:	9b03      	ldr	r3, [sp, #12]
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 80034ea:	f00a 010f 	and.w	r1, sl, #15
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80034ee:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 80034f0:	fa00 f101 	lsl.w	r1, r0, r1
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80034f4:	ea22 0201 	bic.w	r2, r2, r1
 80034f8:	635a      	str	r2, [r3, #52]	@ 0x34
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 80034fa:	f8cb 0008 	str.w	r0, [fp, #8]
            if (hpcd->Init.dma_enable == 1U)
 80034fe:	79a1      	ldrb	r1, [r4, #6]
 8003500:	4281      	cmp	r1, r0
 8003502:	f000 814c 	beq.w	800379e <HAL_PCD_IRQHandler+0x672>
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 8003506:	4631      	mov	r1, r6
 8003508:	4620      	mov	r0, r4
 800350a:	f003 fbb5 	bl	8006c78 <HAL_PCD_DataInStageCallback>
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 800350e:	073a      	lsls	r2, r7, #28
 8003510:	d502      	bpl.n	8003518 <HAL_PCD_IRQHandler+0x3ec>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8003512:	2308      	movs	r3, #8
 8003514:	f8cb 3008 	str.w	r3, [fp, #8]
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8003518:	06fb      	lsls	r3, r7, #27
 800351a:	d502      	bpl.n	8003522 <HAL_PCD_IRQHandler+0x3f6>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 800351c:	2310      	movs	r3, #16
 800351e:	f8cb 3008 	str.w	r3, [fp, #8]
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8003522:	067d      	lsls	r5, r7, #25
 8003524:	d502      	bpl.n	800352c <HAL_PCD_IRQHandler+0x400>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8003526:	2340      	movs	r3, #64	@ 0x40
 8003528:	f8cb 3008 	str.w	r3, [fp, #8]
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 800352c:	07b8      	lsls	r0, r7, #30
 800352e:	f100 8104 	bmi.w	800373a <HAL_PCD_IRQHandler+0x60e>
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8003532:	0639      	lsls	r1, r7, #24
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8003534:	6825      	ldr	r5, [r4, #0]
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8003536:	d5c0      	bpl.n	80034ba <HAL_PCD_IRQHandler+0x38e>
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];

  if (ep->xfer_count > ep->xfer_len)
 8003538:	e9d8 3209 	ldrd	r3, r2, [r8, #36]	@ 0x24
 800353c:	429a      	cmp	r2, r3
 800353e:	d8bc      	bhi.n	80034ba <HAL_PCD_IRQHandler+0x38e>
  {
    return HAL_ERROR;
  }

  len = ep->xfer_len - ep->xfer_count;
 8003540:	eba3 0e02 	sub.w	lr, r3, r2

  if (len > ep->maxpacket)
 8003544:	f8d8 101c 	ldr.w	r1, [r8, #28]
    len = ep->maxpacket;
  }

  len32b = (len + 3U) / 4U;

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8003548:	f505 6c10 	add.w	ip, r5, #2304	@ 0x900
  uint32_t USBx_BASE = (uint32_t)USBx;
 800354c:	9507      	str	r5, [sp, #28]
  if (len > ep->maxpacket)
 800354e:	458e      	cmp	lr, r1
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8003550:	eb0c 174a 	add.w	r7, ip, sl, lsl #5
  if (len > ep->maxpacket)
 8003554:	bf28      	it	cs
 8003556:	468e      	movcs	lr, r1
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8003558:	69b8      	ldr	r0, [r7, #24]
  len32b = (len + 3U) / 4U;
 800355a:	f10e 0103 	add.w	r1, lr, #3
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800355e:	fa1f fe80 	uxth.w	lr, r0
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8003562:	ebbe 0f91 	cmp.w	lr, r1, lsr #2
 8003566:	f0c0 8151 	bcc.w	800380c <HAL_PCD_IRQHandler+0x6e0>
 800356a:	f8cd a018 	str.w	sl, [sp, #24]
 800356e:	e022      	b.n	80035b6 <HAL_PCD_IRQHandler+0x48a>
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;

    if (len > ep->maxpacket)
 8003570:	f8d8 301c 	ldr.w	r3, [r8, #28]
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;

    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 8003574:	4632      	mov	r2, r6
 8003576:	f8d8 1020 	ldr.w	r1, [r8, #32]
 800357a:	4628      	mov	r0, r5
    if (len > ep->maxpacket)
 800357c:	459a      	cmp	sl, r3
 800357e:	bf28      	it	cs
 8003580:	469a      	movcs	sl, r3
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 8003582:	79a3      	ldrb	r3, [r4, #6]
 8003584:	9300      	str	r3, [sp, #0]
 8003586:	fa1f f38a 	uxth.w	r3, sl
 800358a:	f001 fb11 	bl	8004bb0 <USB_WritePacket>
                          (uint8_t)hpcd->Init.dma_enable);

    ep->xfer_buff  += len;
 800358e:	f8d8 3020 	ldr.w	r3, [r8, #32]
    ep->xfer_count += len;
 8003592:	f8d8 2028 	ldr.w	r2, [r8, #40]	@ 0x28
    ep->xfer_buff  += len;
 8003596:	4453      	add	r3, sl
    ep->xfer_count += len;
 8003598:	4452      	add	r2, sl
    len32b = (len + 3U) / 4U;
 800359a:	f10a 0a03 	add.w	sl, sl, #3
    ep->xfer_buff  += len;
 800359e:	f8c8 3020 	str.w	r3, [r8, #32]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80035a2:	69bb      	ldr	r3, [r7, #24]
    ep->xfer_count += len;
 80035a4:	f8c8 2028 	str.w	r2, [r8, #40]	@ 0x28
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80035a8:	b29b      	uxth	r3, r3
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 80035aa:	ebb3 0f9a 	cmp.w	r3, sl, lsr #2
 80035ae:	f0c0 8128 	bcc.w	8003802 <HAL_PCD_IRQHandler+0x6d6>
  }

  if (ep->xfer_len <= ep->xfer_count)
 80035b2:	f8d8 3024 	ldr.w	r3, [r8, #36]	@ 0x24
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80035b6:	429a      	cmp	r2, r3
    len = ep->xfer_len - ep->xfer_count;
 80035b8:	eba3 0a02 	sub.w	sl, r3, r2
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80035bc:	d3d8      	bcc.n	8003570 <HAL_PCD_IRQHandler+0x444>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 80035be:	f8dd a018 	ldr.w	sl, [sp, #24]
 80035c2:	6825      	ldr	r5, [r4, #0]
  {
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80035c4:	9b07      	ldr	r3, [sp, #28]
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 80035c6:	2201      	movs	r2, #1
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80035c8:	f503 6100 	add.w	r1, r3, #2048	@ 0x800
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 80035cc:	f00a 030f 	and.w	r3, sl, #15
 80035d0:	409a      	lsls	r2, r3
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80035d2:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 80035d4:	ea23 0302 	bic.w	r3, r3, r2
 80035d8:	634b      	str	r3, [r1, #52]	@ 0x34
 80035da:	e76e      	b.n	80034ba <HAL_PCD_IRQHandler+0x38e>
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 80035dc:	f001 fba4 	bl	8004d28 <USB_ReadDevAllOutEpInterrupt>
      while (ep_intr != 0U)
 80035e0:	4606      	mov	r6, r0
 80035e2:	2800      	cmp	r0, #0
 80035e4:	d070      	beq.n	80036c8 <HAL_PCD_IRQHandler+0x59c>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 80035e6:	9504      	str	r5, [sp, #16]
 80035e8:	f507 6830 	add.w	r8, r7, #2816	@ 0xb00
 80035ec:	46a3      	mov	fp, r4
      epnum = 0U;
 80035ee:	f04f 0a00 	mov.w	sl, #0
 80035f2:	6820      	ldr	r0, [r4, #0]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 80035f4:	4625      	mov	r5, r4
 80035f6:	e007      	b.n	8003608 <HAL_PCD_IRQHandler+0x4dc>
      while (ep_intr != 0U)
 80035f8:	0876      	lsrs	r6, r6, #1
        epnum++;
 80035fa:	f10a 0a01 	add.w	sl, sl, #1
      while (ep_intr != 0U)
 80035fe:	f108 0820 	add.w	r8, r8, #32
 8003602:	f10b 0b24 	add.w	fp, fp, #36	@ 0x24
 8003606:	d061      	beq.n	80036cc <HAL_PCD_IRQHandler+0x5a0>
        if ((ep_intr & 0x1U) != 0U)
 8003608:	07f4      	lsls	r4, r6, #31
 800360a:	d5f5      	bpl.n	80035f8 <HAL_PCD_IRQHandler+0x4cc>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 800360c:	fa5f f48a 	uxtb.w	r4, sl
 8003610:	4621      	mov	r1, r4
 8003612:	f001 fb99 	bl	8004d48 <USB_ReadDevOutEPInterrupt>
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8003616:	f010 0f01 	tst.w	r0, #1
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 800361a:	4681      	mov	r9, r0
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 800361c:	d16e      	bne.n	80036fc <HAL_PCD_IRQHandler+0x5d0>
          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 800361e:	f019 0f08 	tst.w	r9, #8
 8003622:	d15a      	bne.n	80036da <HAL_PCD_IRQHandler+0x5ae>
          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8003624:	f019 0f10 	tst.w	r9, #16
 8003628:	d002      	beq.n	8003630 <HAL_PCD_IRQHandler+0x504>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 800362a:	2210      	movs	r2, #16
 800362c:	f8c8 2008 	str.w	r2, [r8, #8]
          if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
 8003630:	f019 0f02 	tst.w	r9, #2
 8003634:	d00f      	beq.n	8003656 <HAL_PCD_IRQHandler+0x52a>
            if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
 8003636:	697a      	ldr	r2, [r7, #20]
 8003638:	0610      	lsls	r0, r2, #24
 800363a:	d504      	bpl.n	8003646 <HAL_PCD_IRQHandler+0x51a>
              USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 800363c:	9b03      	ldr	r3, [sp, #12]
 800363e:	685a      	ldr	r2, [r3, #4]
 8003640:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8003644:	605a      	str	r2, [r3, #4]
            if (ep->is_iso_incomplete == 1U)
 8003646:	f89b 2257 	ldrb.w	r2, [fp, #599]	@ 0x257
 800364a:	2a01      	cmp	r2, #1
 800364c:	f000 80e2 	beq.w	8003814 <HAL_PCD_IRQHandler+0x6e8>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 8003650:	2302      	movs	r3, #2
 8003652:	f8c8 3008 	str.w	r3, [r8, #8]
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 8003656:	f019 0f20 	tst.w	r9, #32
 800365a:	d002      	beq.n	8003662 <HAL_PCD_IRQHandler+0x536>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 800365c:	2320      	movs	r3, #32
 800365e:	f8c8 3008 	str.w	r3, [r8, #8]
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 8003662:	f419 5f00 	tst.w	r9, #8192	@ 0x2000
 8003666:	d003      	beq.n	8003670 <HAL_PCD_IRQHandler+0x544>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 8003668:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 800366c:	f8c8 3008 	str.w	r3, [r8, #8]
 8003670:	6828      	ldr	r0, [r5, #0]
 8003672:	e7c1      	b.n	80035f8 <HAL_PCD_IRQHandler+0x4cc>
        HAL_PCD_SuspendCallback(hpcd);
 8003674:	4620      	mov	r0, r4
 8003676:	f003 fb23 	bl	8006cc0 <HAL_PCD_SuspendCallback>
 800367a:	e5ca      	b.n	8003212 <HAL_PCD_IRQHandler+0xe6>
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 800367c:	9a03      	ldr	r2, [sp, #12]
 800367e:	f8d2 3084 	ldr.w	r3, [r2, #132]	@ 0x84
 8003682:	f043 030b 	orr.w	r3, r3, #11
 8003686:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 800368a:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 800368c:	f043 030b 	orr.w	r3, r3, #11
 8003690:	6453      	str	r3, [r2, #68]	@ 0x44
 8003692:	e6db      	b.n	800344c <HAL_PCD_IRQHandler+0x320>
        hpcd->LPM_State = LPM_L0;
 8003694:	2100      	movs	r1, #0
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 8003696:	4620      	mov	r0, r4
        hpcd->LPM_State = LPM_L0;
 8003698:	f884 14cc 	strb.w	r1, [r4, #1228]	@ 0x4cc
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 800369c:	f000 fa1c 	bl	8003ad8 <HAL_PCDEx_LPM_Callback>
 80036a0:	e67d      	b.n	800339e <HAL_PCD_IRQHandler+0x272>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 80036a2:	eb08 08c8 	add.w	r8, r8, r8, lsl #3
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 80036a6:	2208      	movs	r2, #8
 80036a8:	f204 419c 	addw	r1, r4, #1180	@ 0x49c
 80036ac:	4638      	mov	r0, r7
 80036ae:	f001 fa95 	bl	8004bdc <USB_ReadPacket>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 80036b2:	f3c6 130a 	ubfx	r3, r6, #4, #11
 80036b6:	eb04 0288 	add.w	r2, r4, r8, lsl #2
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80036ba:	6820      	ldr	r0, [r4, #0]
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 80036bc:	f8d2 1268 	ldr.w	r1, [r2, #616]	@ 0x268
 80036c0:	440b      	add	r3, r1
 80036c2:	f8c2 3268 	str.w	r3, [r2, #616]	@ 0x268
 80036c6:	e56e      	b.n	80031a6 <HAL_PCD_IRQHandler+0x7a>
 80036c8:	6820      	ldr	r0, [r4, #0]
 80036ca:	e577      	b.n	80031bc <HAL_PCD_IRQHandler+0x90>
 80036cc:	462c      	mov	r4, r5
 80036ce:	9d04      	ldr	r5, [sp, #16]
 80036d0:	e574      	b.n	80031bc <HAL_PCD_IRQHandler+0x90>
 80036d2:	4628      	mov	r0, r5
 80036d4:	e9dd 7504 	ldrd	r7, r5, [sp, #16]
 80036d8:	e576      	b.n	80031c8 <HAL_PCD_IRQHandler+0x9c>
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80036da:	6829      	ldr	r1, [r5, #0]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 80036dc:	2208      	movs	r2, #8
 80036de:	f8c8 2008 	str.w	r2, [r8, #8]
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 80036e2:	f501 6230 	add.w	r2, r1, #2816	@ 0xb00
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 80036e6:	6c08      	ldr	r0, [r1, #64]	@ 0x40

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80036e8:	496e      	ldr	r1, [pc, #440]	@ (80038a4 <HAL_PCD_IRQHandler+0x778>)
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 80036ea:	eb02 124a 	add.w	r2, r2, sl, lsl #5
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80036ee:	4288      	cmp	r0, r1
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 80036f0:	6893      	ldr	r3, [r2, #8]
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80036f2:	d867      	bhi.n	80037c4 <HAL_PCD_IRQHandler+0x698>

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 80036f4:	4628      	mov	r0, r5
 80036f6:	f003 faaf 	bl	8006c58 <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 80036fa:	e793      	b.n	8003624 <HAL_PCD_IRQHandler+0x4f8>
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80036fc:	6828      	ldr	r0, [r5, #0]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 80036fe:	2201      	movs	r2, #1
 8003700:	f8c8 2008 	str.w	r2, [r8, #8]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8003704:	f500 6230 	add.w	r2, r0, #2816	@ 0xb00
  if (hpcd->Init.dma_enable == 1U)
 8003708:	79a9      	ldrb	r1, [r5, #6]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800370a:	eb02 124a 	add.w	r2, r2, sl, lsl #5
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 800370e:	f8d0 e040 	ldr.w	lr, [r0, #64]	@ 0x40
  if (hpcd->Init.dma_enable == 1U)
 8003712:	2901      	cmp	r1, #1
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8003714:	6893      	ldr	r3, [r2, #8]
  if (hpcd->Init.dma_enable == 1U)
 8003716:	d067      	beq.n	80037e8 <HAL_PCD_IRQHandler+0x6bc>
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8003718:	4963      	ldr	r1, [pc, #396]	@ (80038a8 <HAL_PCD_IRQHandler+0x77c>)
 800371a:	458e      	cmp	lr, r1
 800371c:	f000 8086 	beq.w	800382c <HAL_PCD_IRQHandler+0x700>
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 8003720:	f1ba 0f00 	cmp.w	sl, #0
 8003724:	d104      	bne.n	8003730 <HAL_PCD_IRQHandler+0x604>
 8003726:	f8d5 2264 	ldr.w	r2, [r5, #612]	@ 0x264
 800372a:	2a00      	cmp	r2, #0
 800372c:	f000 80ad 	beq.w	800388a <HAL_PCD_IRQHandler+0x75e>
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8003730:	4621      	mov	r1, r4
 8003732:	4628      	mov	r0, r5
 8003734:	f003 fa96 	bl	8006c64 <HAL_PCD_DataOutStageCallback>
 8003738:	e771      	b.n	800361e <HAL_PCD_IRQHandler+0x4f2>
            (void)USB_FlushTxFifo(USBx, epnum);
 800373a:	4651      	mov	r1, sl
 800373c:	9804      	ldr	r0, [sp, #16]
 800373e:	f001 f82d 	bl	800479c <USB_FlushTxFifo>
            if (ep->is_iso_incomplete == 1U)
 8003742:	f898 2017 	ldrb.w	r2, [r8, #23]
 8003746:	2a01      	cmp	r2, #1
 8003748:	d078      	beq.n	800383c <HAL_PCD_IRQHandler+0x710>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 800374a:	2202      	movs	r2, #2
 800374c:	f8cb 2008 	str.w	r2, [fp, #8]
 8003750:	e6ef      	b.n	8003532 <HAL_PCD_IRQHandler+0x406>
        if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
 8003752:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
 8003756:	421e      	tst	r6, r3
 8003758:	f43f ad25 	beq.w	80031a6 <HAL_PCD_IRQHandler+0x7a>
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 800375c:	eb08 08c8 	add.w	r8, r8, r8, lsl #3
 8003760:	f3c6 120a 	ubfx	r2, r6, #4, #11
 8003764:	4638      	mov	r0, r7
 8003766:	eb04 0888 	add.w	r8, r4, r8, lsl #2
 800376a:	4616      	mov	r6, r2
 800376c:	f8d8 1260 	ldr.w	r1, [r8, #608]	@ 0x260
 8003770:	f001 fa34 	bl	8004bdc <USB_ReadPacket>
          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8003774:	f8d8 3260 	ldr.w	r3, [r8, #608]	@ 0x260
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8003778:	6820      	ldr	r0, [r4, #0]
          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800377a:	4433      	add	r3, r6
 800377c:	f8c8 3260 	str.w	r3, [r8, #608]	@ 0x260
          ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8003780:	f8d8 3268 	ldr.w	r3, [r8, #616]	@ 0x268
 8003784:	4433      	add	r3, r6
 8003786:	f8c8 3268 	str.w	r3, [r8, #616]	@ 0x268
 800378a:	e50c      	b.n	80031a6 <HAL_PCD_IRQHandler+0x7a>
        HAL_PCD_DisconnectCallback(hpcd);
 800378c:	4620      	mov	r0, r4
 800378e:	f003 fabf 	bl	8006d10 <HAL_PCD_DisconnectCallback>
      hpcd->Instance->GOTGINT |= RegVal;
 8003792:	6823      	ldr	r3, [r4, #0]
 8003794:	e5b4      	b.n	8003300 <HAL_PCD_IRQHandler+0x1d4>
        HAL_PCD_SuspendCallback(hpcd);
 8003796:	4620      	mov	r0, r4
 8003798:	f003 fa92 	bl	8006cc0 <HAL_PCD_SuspendCallback>
 800379c:	e5bb      	b.n	8003316 <HAL_PCD_IRQHandler+0x1ea>
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 800379e:	e9d8 0207 	ldrd	r0, r2, [r8, #28]
 80037a2:	4402      	add	r2, r0
 80037a4:	f8c8 2020 	str.w	r2, [r8, #32]
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 80037a8:	f1ba 0f00 	cmp.w	sl, #0
 80037ac:	f47f aeab 	bne.w	8003506 <HAL_PCD_IRQHandler+0x3da>
 80037b0:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 80037b2:	2a00      	cmp	r2, #0
 80037b4:	f47f aea7 	bne.w	8003506 <HAL_PCD_IRQHandler+0x3da>
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 80037b8:	f204 429c 	addw	r2, r4, #1180	@ 0x49c
 80037bc:	6820      	ldr	r0, [r4, #0]
 80037be:	f001 faf1 	bl	8004da4 <USB_EP0_OutStart>
 80037c2:	e6a0      	b.n	8003506 <HAL_PCD_IRQHandler+0x3da>
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80037c4:	041b      	lsls	r3, r3, #16
 80037c6:	d52d      	bpl.n	8003824 <HAL_PCD_IRQHandler+0x6f8>
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 80037c8:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
  HAL_PCD_SetupStageCallback(hpcd);
 80037cc:	4628      	mov	r0, r5
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 80037ce:	6091      	str	r1, [r2, #8]
  HAL_PCD_SetupStageCallback(hpcd);
 80037d0:	f003 fa42 	bl	8006c58 <HAL_PCD_SetupStageCallback>
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 80037d4:	79a9      	ldrb	r1, [r5, #6]
 80037d6:	2901      	cmp	r1, #1
 80037d8:	f47f af24 	bne.w	8003624 <HAL_PCD_IRQHandler+0x4f8>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 80037dc:	f205 429c 	addw	r2, r5, #1180	@ 0x49c
 80037e0:	6828      	ldr	r0, [r5, #0]
 80037e2:	f001 fadf 	bl	8004da4 <USB_EP0_OutStart>
 80037e6:	e71d      	b.n	8003624 <HAL_PCD_IRQHandler+0x4f8>
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 80037e8:	0719      	lsls	r1, r3, #28
 80037ea:	d52f      	bpl.n	800384c <HAL_PCD_IRQHandler+0x720>
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80037ec:	492d      	ldr	r1, [pc, #180]	@ (80038a4 <HAL_PCD_IRQHandler+0x778>)
 80037ee:	458e      	cmp	lr, r1
 80037f0:	f67f af15 	bls.w	800361e <HAL_PCD_IRQHandler+0x4f2>
 80037f4:	0418      	lsls	r0, r3, #16
 80037f6:	f57f af12 	bpl.w	800361e <HAL_PCD_IRQHandler+0x4f2>
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 80037fa:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 80037fe:	6091      	str	r1, [r2, #8]
 8003800:	e70d      	b.n	800361e <HAL_PCD_IRQHandler+0x4f2>
  if (ep->xfer_len <= ep->xfer_count)
 8003802:	f8dd a018 	ldr.w	sl, [sp, #24]
 8003806:	f8d8 3024 	ldr.w	r3, [r8, #36]	@ 0x24
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 800380a:	6825      	ldr	r5, [r4, #0]
  if (ep->xfer_len <= ep->xfer_count)
 800380c:	429a      	cmp	r2, r3
 800380e:	f4ff ae54 	bcc.w	80034ba <HAL_PCD_IRQHandler+0x38e>
 8003812:	e6d7      	b.n	80035c4 <HAL_PCD_IRQHandler+0x498>
              ep->is_iso_incomplete = 0U;
 8003814:	2200      	movs	r2, #0
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 8003816:	4621      	mov	r1, r4
 8003818:	4628      	mov	r0, r5
              ep->is_iso_incomplete = 0U;
 800381a:	f88b 2257 	strb.w	r2, [fp, #599]	@ 0x257
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 800381e:	f003 fa6b 	bl	8006cf8 <HAL_PCD_ISOOUTIncompleteCallback>
 8003822:	e715      	b.n	8003650 <HAL_PCD_IRQHandler+0x524>
  HAL_PCD_SetupStageCallback(hpcd);
 8003824:	4628      	mov	r0, r5
 8003826:	f003 fa17 	bl	8006c58 <HAL_PCD_SetupStageCallback>
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 800382a:	e7d3      	b.n	80037d4 <HAL_PCD_IRQHandler+0x6a8>
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 800382c:	0418      	lsls	r0, r3, #16
 800382e:	d4e4      	bmi.n	80037fa <HAL_PCD_IRQHandler+0x6ce>
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 8003830:	0699      	lsls	r1, r3, #26
 8003832:	f57f af7d 	bpl.w	8003730 <HAL_PCD_IRQHandler+0x604>
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8003836:	2120      	movs	r1, #32
 8003838:	6091      	str	r1, [r2, #8]
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 800383a:	e779      	b.n	8003730 <HAL_PCD_IRQHandler+0x604>
              ep->is_iso_incomplete = 0U;
 800383c:	2200      	movs	r2, #0
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 800383e:	4631      	mov	r1, r6
 8003840:	4620      	mov	r0, r4
              ep->is_iso_incomplete = 0U;
 8003842:	f888 2017 	strb.w	r2, [r8, #23]
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 8003846:	f003 fa5b 	bl	8006d00 <HAL_PCD_ISOINIncompleteCallback>
 800384a:	e77e      	b.n	800374a <HAL_PCD_IRQHandler+0x61e>
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 800384c:	0699      	lsls	r1, r3, #26
 800384e:	d502      	bpl.n	8003856 <HAL_PCD_IRQHandler+0x72a>
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8003850:	2120      	movs	r1, #32
 8003852:	6091      	str	r1, [r2, #8]
 8003854:	e6e3      	b.n	800361e <HAL_PCD_IRQHandler+0x4f2>
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8003856:	4913      	ldr	r1, [pc, #76]	@ (80038a4 <HAL_PCD_IRQHandler+0x778>)
 8003858:	458e      	cmp	lr, r1
 800385a:	d901      	bls.n	8003860 <HAL_PCD_IRQHandler+0x734>
 800385c:	041b      	lsls	r3, r3, #16
 800385e:	d4cc      	bmi.n	80037fa <HAL_PCD_IRQHandler+0x6ce>
        ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 8003860:	6911      	ldr	r1, [r2, #16]
 8003862:	f8db 2274 	ldr.w	r2, [fp, #628]	@ 0x274
 8003866:	f3c1 0112 	ubfx	r1, r1, #0, #19
 800386a:	1a52      	subs	r2, r2, r1
 800386c:	f8cb 2268 	str.w	r2, [fp, #616]	@ 0x268
        if (epnum == 0U)
 8003870:	f1ba 0f00 	cmp.w	sl, #0
 8003874:	f47f af5c 	bne.w	8003730 <HAL_PCD_IRQHandler+0x604>
          if (ep->xfer_len == 0U)
 8003878:	f8d5 1264 	ldr.w	r1, [r5, #612]	@ 0x264
 800387c:	b159      	cbz	r1, 8003896 <HAL_PCD_IRQHandler+0x76a>
            ep->xfer_buff += ep->xfer_count;
 800387e:	f8d5 1260 	ldr.w	r1, [r5, #608]	@ 0x260
 8003882:	4411      	add	r1, r2
 8003884:	f8c5 1260 	str.w	r1, [r5, #608]	@ 0x260
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8003888:	e752      	b.n	8003730 <HAL_PCD_IRQHandler+0x604>
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 800388a:	f205 429c 	addw	r2, r5, #1180	@ 0x49c
 800388e:	4651      	mov	r1, sl
 8003890:	f001 fa88 	bl	8004da4 <USB_EP0_OutStart>
 8003894:	e74c      	b.n	8003730 <HAL_PCD_IRQHandler+0x604>
            (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8003896:	f205 429c 	addw	r2, r5, #1180	@ 0x49c
 800389a:	2101      	movs	r1, #1
 800389c:	f001 fa82 	bl	8004da4 <USB_EP0_OutStart>
 80038a0:	e746      	b.n	8003730 <HAL_PCD_IRQHandler+0x604>
 80038a2:	bf00      	nop
 80038a4:	4f54300a 	.word	0x4f54300a
 80038a8:	4f54310a 	.word	0x4f54310a

080038ac <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd);
 80038ac:	f890 2494 	ldrb.w	r2, [r0, #1172]	@ 0x494
 80038b0:	2a01      	cmp	r2, #1
 80038b2:	d00d      	beq.n	80038d0 <HAL_PCD_SetAddress+0x24>
 80038b4:	2201      	movs	r2, #1
{
 80038b6:	b510      	push	{r4, lr}
 80038b8:	4604      	mov	r4, r0
  (void)USB_SetDevAddress(hpcd->Instance, address);
 80038ba:	6800      	ldr	r0, [r0, #0]
  hpcd->USB_Address = address;
 80038bc:	7461      	strb	r1, [r4, #17]
  __HAL_LOCK(hpcd);
 80038be:	f884 2494 	strb.w	r2, [r4, #1172]	@ 0x494
  (void)USB_SetDevAddress(hpcd->Instance, address);
 80038c2:	f001 fa13 	bl	8004cec <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 80038c6:	2300      	movs	r3, #0
  return HAL_OK;
 80038c8:	4618      	mov	r0, r3
  __HAL_UNLOCK(hpcd);
 80038ca:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
}
 80038ce:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 80038d0:	2002      	movs	r0, #2
}
 80038d2:	4770      	bx	lr

080038d4 <HAL_PCD_EP_Open>:
{
 80038d4:	b510      	push	{r4, lr}
 80038d6:	f001 0e0f 	and.w	lr, r1, #15
  if ((ep_addr & 0x80U) == 0x80U)
 80038da:	0609      	lsls	r1, r1, #24
{
 80038dc:	4604      	mov	r4, r0
 80038de:	eb0e 0cce 	add.w	ip, lr, lr, lsl #3
 80038e2:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
  if ((ep_addr & 0x80U) == 0x80U)
 80038e6:	d425      	bmi.n	8003934 <HAL_PCD_EP_Open+0x60>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80038e8:	f50c 7115 	add.w	r1, ip, #596	@ 0x254
    ep->is_in = 0U;
 80038ec:	f04f 0c00 	mov.w	ip, #0
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80038f0:	4401      	add	r1, r0
    ep->is_in = 0U;
 80038f2:	eb0e 00ce 	add.w	r0, lr, lr, lsl #3
 80038f6:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80038fa:	f880 c255 	strb.w	ip, [r0, #597]	@ 0x255
  ep->maxpacket = ep_mps;
 80038fe:	608a      	str	r2, [r1, #8]
  if (ep->is_in != 0U)
 8003900:	784a      	ldrb	r2, [r1, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8003902:	f881 e000 	strb.w	lr, [r1]
  ep->type = ep_type;
 8003906:	710b      	strb	r3, [r1, #4]
  if (ep->is_in != 0U)
 8003908:	b10a      	cbz	r2, 800390e <HAL_PCD_EP_Open+0x3a>
    ep->tx_fifo_num = ep->num;
 800390a:	f8a1 e01a 	strh.w	lr, [r1, #26]
  if (ep_type == EP_TYPE_BULK)
 800390e:	2b02      	cmp	r3, #2
 8003910:	d101      	bne.n	8003916 <HAL_PCD_EP_Open+0x42>
    ep->data_pid_start = 0U;
 8003912:	2300      	movs	r3, #0
 8003914:	714b      	strb	r3, [r1, #5]
  __HAL_LOCK(hpcd);
 8003916:	f894 3494 	ldrb.w	r3, [r4, #1172]	@ 0x494
 800391a:	2b01      	cmp	r3, #1
 800391c:	d016      	beq.n	800394c <HAL_PCD_EP_Open+0x78>
 800391e:	2301      	movs	r3, #1
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8003920:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 8003922:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8003926:	f000 ff93 	bl	8004850 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800392a:	2300      	movs	r3, #0
  return ret;
 800392c:	4618      	mov	r0, r3
  __HAL_UNLOCK(hpcd);
 800392e:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
}
 8003932:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003934:	f10c 0114 	add.w	r1, ip, #20
    ep->is_in = 1U;
 8003938:	f04f 0c01 	mov.w	ip, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800393c:	4401      	add	r1, r0
    ep->is_in = 1U;
 800393e:	eb0e 00ce 	add.w	r0, lr, lr, lsl #3
 8003942:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8003946:	f880 c015 	strb.w	ip, [r0, #21]
 800394a:	e7d8      	b.n	80038fe <HAL_PCD_EP_Open+0x2a>
  __HAL_LOCK(hpcd);
 800394c:	2002      	movs	r0, #2
}
 800394e:	bd10      	pop	{r4, pc}

08003950 <HAL_PCD_EP_Receive>:
{
 8003950:	b510      	push	{r4, lr}
 8003952:	f001 0e0f 	and.w	lr, r1, #15
 8003956:	4614      	mov	r4, r2
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003958:	2124      	movs	r1, #36	@ 0x24
  ep->xfer_buff = pBuf;
 800395a:	eb0e 0cce 	add.w	ip, lr, lr, lsl #3
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800395e:	fb01 010e 	mla	r1, r1, lr, r0
  ep->xfer_buff = pBuf;
 8003962:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003966:	f501 7115 	add.w	r1, r1, #596	@ 0x254
  ep->xfer_len = len;
 800396a:	f8cc 3264 	str.w	r3, [ip, #612]	@ 0x264
  ep->xfer_count = 0U;
 800396e:	2300      	movs	r3, #0
  ep->num = ep_addr & EP_ADDR_MSK;
 8003970:	f88c e254 	strb.w	lr, [ip, #596]	@ 0x254
  ep->xfer_buff = pBuf;
 8003974:	f8cc 2260 	str.w	r2, [ip, #608]	@ 0x260
  ep->xfer_count = 0U;
 8003978:	f8cc 3268 	str.w	r3, [ip, #616]	@ 0x268
  ep->is_in = 0U;
 800397c:	f88c 3255 	strb.w	r3, [ip, #597]	@ 0x255
  if (hpcd->Init.dma_enable == 1U)
 8003980:	7982      	ldrb	r2, [r0, #6]
  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8003982:	6800      	ldr	r0, [r0, #0]
  if (hpcd->Init.dma_enable == 1U)
 8003984:	2a01      	cmp	r2, #1
    ep->dma_addr = (uint32_t)pBuf;
 8003986:	bf08      	it	eq
 8003988:	f8cc 4270 	streq.w	r4, [ip, #624]	@ 0x270
  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800398c:	f000 ffa6 	bl	80048dc <USB_EPStartXfer>
}
 8003990:	2000      	movs	r0, #0
 8003992:	bd10      	pop	{r4, pc}

08003994 <HAL_PCD_EP_Transmit>:
{
 8003994:	b510      	push	{r4, lr}
 8003996:	f001 0e0f 	and.w	lr, r1, #15
 800399a:	4614      	mov	r4, r2
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800399c:	2124      	movs	r1, #36	@ 0x24
  ep->xfer_buff = pBuf;
 800399e:	eb0e 0cce 	add.w	ip, lr, lr, lsl #3
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80039a2:	fb01 010e 	mla	r1, r1, lr, r0
  ep->xfer_buff = pBuf;
 80039a6:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80039aa:	3114      	adds	r1, #20
  ep->xfer_len = len;
 80039ac:	f8cc 3024 	str.w	r3, [ip, #36]	@ 0x24
  ep->xfer_count = 0U;
 80039b0:	2300      	movs	r3, #0
  ep->num = ep_addr & EP_ADDR_MSK;
 80039b2:	f88c e014 	strb.w	lr, [ip, #20]
  ep->xfer_count = 0U;
 80039b6:	f8cc 3028 	str.w	r3, [ip, #40]	@ 0x28
  ep->is_in = 1U;
 80039ba:	2301      	movs	r3, #1
  ep->xfer_buff = pBuf;
 80039bc:	f8cc 2020 	str.w	r2, [ip, #32]
  ep->is_in = 1U;
 80039c0:	f88c 3015 	strb.w	r3, [ip, #21]
  if (hpcd->Init.dma_enable == 1U)
 80039c4:	7982      	ldrb	r2, [r0, #6]
  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 80039c6:	6800      	ldr	r0, [r0, #0]
  if (hpcd->Init.dma_enable == 1U)
 80039c8:	429a      	cmp	r2, r3
    ep->dma_addr = (uint32_t)pBuf;
 80039ca:	bf08      	it	eq
 80039cc:	f8cc 4030 	streq.w	r4, [ip, #48]	@ 0x30
  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 80039d0:	f000 ff84 	bl	80048dc <USB_EPStartXfer>
}
 80039d4:	2000      	movs	r0, #0
 80039d6:	bd10      	pop	{r4, pc}

080039d8 <HAL_PCD_EP_SetStall>:
{
 80039d8:	b538      	push	{r3, r4, r5, lr}
 80039da:	f001 050f 	and.w	r5, r1, #15
  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 80039de:	7903      	ldrb	r3, [r0, #4]
 80039e0:	42ab      	cmp	r3, r5
 80039e2:	d333      	bcc.n	8003a4c <HAL_PCD_EP_SetStall+0x74>
  if ((0x80U & ep_addr) == 0x80U)
 80039e4:	060b      	lsls	r3, r1, #24
 80039e6:	4604      	mov	r4, r0
 80039e8:	d41d      	bmi.n	8003a26 <HAL_PCD_EP_SetStall+0x4e>
    ep = &hpcd->OUT_ep[ep_addr];
 80039ea:	2224      	movs	r2, #36	@ 0x24
    ep->is_in = 0U;
 80039ec:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
    ep = &hpcd->OUT_ep[ep_addr];
 80039f0:	fb02 0101 	mla	r1, r2, r1, r0
    ep->is_in = 0U;
 80039f4:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80039f8:	2200      	movs	r2, #0
    ep = &hpcd->OUT_ep[ep_addr];
 80039fa:	f501 7115 	add.w	r1, r1, #596	@ 0x254
    ep->is_in = 0U;
 80039fe:	f883 2255 	strb.w	r2, [r3, #597]	@ 0x255
  ep->is_stall = 1U;
 8003a02:	2301      	movs	r3, #1
  ep->num = ep_addr & EP_ADDR_MSK;
 8003a04:	700d      	strb	r5, [r1, #0]
  ep->is_stall = 1U;
 8003a06:	708b      	strb	r3, [r1, #2]
  __HAL_LOCK(hpcd);
 8003a08:	f894 2494 	ldrb.w	r2, [r4, #1172]	@ 0x494
 8003a0c:	429a      	cmp	r2, r3
 8003a0e:	d01b      	beq.n	8003a48 <HAL_PCD_EP_SetStall+0x70>
  (void)USB_EPSetStall(hpcd->Instance, ep);
 8003a10:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 8003a12:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
  (void)USB_EPSetStall(hpcd->Instance, ep);
 8003a16:	f001 f905 	bl	8004c24 <USB_EPSetStall>
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8003a1a:	b1cd      	cbz	r5, 8003a50 <HAL_PCD_EP_SetStall+0x78>
  __HAL_UNLOCK(hpcd);
 8003a1c:	2300      	movs	r3, #0
  return HAL_OK;
 8003a1e:	4618      	mov	r0, r3
  __HAL_UNLOCK(hpcd);
 8003a20:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
}
 8003a24:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003a26:	2124      	movs	r1, #36	@ 0x24
    ep->is_in = 1U;
 8003a28:	eb05 03c5 	add.w	r3, r5, r5, lsl #3
 8003a2c:	2201      	movs	r2, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003a2e:	fb01 0105 	mla	r1, r1, r5, r0
    ep->is_in = 1U;
 8003a32:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003a36:	3114      	adds	r1, #20
    ep->is_in = 1U;
 8003a38:	755a      	strb	r2, [r3, #21]
  ep->is_stall = 1U;
 8003a3a:	2301      	movs	r3, #1
  ep->num = ep_addr & EP_ADDR_MSK;
 8003a3c:	700d      	strb	r5, [r1, #0]
  ep->is_stall = 1U;
 8003a3e:	708b      	strb	r3, [r1, #2]
  __HAL_LOCK(hpcd);
 8003a40:	f894 2494 	ldrb.w	r2, [r4, #1172]	@ 0x494
 8003a44:	429a      	cmp	r2, r3
 8003a46:	d1e3      	bne.n	8003a10 <HAL_PCD_EP_SetStall+0x38>
 8003a48:	2002      	movs	r0, #2
}
 8003a4a:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8003a4c:	2001      	movs	r0, #1
}
 8003a4e:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8003a50:	f204 429c 	addw	r2, r4, #1180	@ 0x49c
 8003a54:	79a1      	ldrb	r1, [r4, #6]
 8003a56:	6820      	ldr	r0, [r4, #0]
 8003a58:	f001 f9a4 	bl	8004da4 <USB_EP0_OutStart>
 8003a5c:	e7de      	b.n	8003a1c <HAL_PCD_EP_SetStall+0x44>
 8003a5e:	bf00      	nop

08003a60 <HAL_PCD_EP_ClrStall>:
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8003a60:	f001 020f 	and.w	r2, r1, #15
{
 8003a64:	b538      	push	{r3, r4, r5, lr}
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8003a66:	7903      	ldrb	r3, [r0, #4]
 8003a68:	4293      	cmp	r3, r2
 8003a6a:	d332      	bcc.n	8003ad2 <HAL_PCD_EP_ClrStall+0x72>
  if ((0x80U & ep_addr) == 0x80U)
 8003a6c:	eb02 03c2 	add.w	r3, r2, r2, lsl #3
 8003a70:	0609      	lsls	r1, r1, #24
 8003a72:	4604      	mov	r4, r0
 8003a74:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003a78:	d41a      	bmi.n	8003ab0 <HAL_PCD_EP_ClrStall+0x50>
    ep->is_in = 0U;
 8003a7a:	eb02 00c2 	add.w	r0, r2, r2, lsl #3
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003a7e:	f503 7315 	add.w	r3, r3, #596	@ 0x254
    ep->is_in = 0U;
 8003a82:	2500      	movs	r5, #0
 8003a84:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003a88:	18e1      	adds	r1, r4, r3
    ep->is_in = 0U;
 8003a8a:	f880 5255 	strb.w	r5, [r0, #597]	@ 0x255
  ep->is_stall = 0U;
 8003a8e:	2500      	movs	r5, #0
  ep->num = ep_addr & EP_ADDR_MSK;
 8003a90:	700a      	strb	r2, [r1, #0]
  ep->is_stall = 0U;
 8003a92:	708d      	strb	r5, [r1, #2]
  __HAL_LOCK(hpcd);
 8003a94:	f894 3494 	ldrb.w	r3, [r4, #1172]	@ 0x494
 8003a98:	2b01      	cmp	r3, #1
 8003a9a:	d018      	beq.n	8003ace <HAL_PCD_EP_ClrStall+0x6e>
 8003a9c:	2301      	movs	r3, #1
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8003a9e:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 8003aa0:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8003aa4:	f001 f8f6 	bl	8004c94 <USB_EPClearStall>
  return HAL_OK;
 8003aa8:	4628      	mov	r0, r5
  __HAL_UNLOCK(hpcd);
 8003aaa:	f884 5494 	strb.w	r5, [r4, #1172]	@ 0x494
}
 8003aae:	bd38      	pop	{r3, r4, r5, pc}
    ep->is_in = 1U;
 8003ab0:	eb02 00c2 	add.w	r0, r2, r2, lsl #3
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003ab4:	3314      	adds	r3, #20
    ep->is_in = 1U;
 8003ab6:	2501      	movs	r5, #1
 8003ab8:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003abc:	18e1      	adds	r1, r4, r3
    ep->is_in = 1U;
 8003abe:	7545      	strb	r5, [r0, #21]
  ep->is_stall = 0U;
 8003ac0:	2500      	movs	r5, #0
  ep->num = ep_addr & EP_ADDR_MSK;
 8003ac2:	700a      	strb	r2, [r1, #0]
  ep->is_stall = 0U;
 8003ac4:	708d      	strb	r5, [r1, #2]
  __HAL_LOCK(hpcd);
 8003ac6:	f894 3494 	ldrb.w	r3, [r4, #1172]	@ 0x494
 8003aca:	2b01      	cmp	r3, #1
 8003acc:	d1e6      	bne.n	8003a9c <HAL_PCD_EP_ClrStall+0x3c>
 8003ace:	2002      	movs	r0, #2
}
 8003ad0:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8003ad2:	2001      	movs	r0, #1
}
 8003ad4:	bd38      	pop	{r3, r4, r5, pc}
 8003ad6:	bf00      	nop

08003ad8 <HAL_PCDEx_LPM_Callback>:
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 8003ad8:	4770      	bx	lr
 8003ada:	bf00      	nop

08003adc <HAL_QSPI_Init>:
  *        in the QSPI_InitTypeDef and initialize the associated handle.
  * @param hqspi QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Init(QSPI_HandleTypeDef *hqspi)
{
 8003adc:	b570      	push	{r4, r5, r6, lr}
 8003ade:	4604      	mov	r4, r0
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 8003ae0:	f7fe fad2 	bl	8002088 <HAL_GetTick>

  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
 8003ae4:	2c00      	cmp	r4, #0
 8003ae6:	d050      	beq.n	8003b8a <HAL_QSPI_Init+0xae>
  if (hqspi->Init.DualFlash != QSPI_DUALFLASH_ENABLE )
  {
    assert_param(IS_QSPI_FLASH_ID(hqspi->Init.FlashID));
  }

  if(hqspi->State == HAL_QSPI_STATE_RESET)
 8003ae8:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
 8003aec:	4605      	mov	r5, r0
 8003aee:	2b00      	cmp	r3, #0
 8003af0:	d03c      	beq.n	8003b6c <HAL_QSPI_Init+0x90>
  /* Configure QSPI FIFO Threshold */
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
             ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));

  /* Wait till BUSY flag reset */
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 8003af2:	6ca6      	ldr	r6, [r4, #72]	@ 0x48
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
 8003af4:	6822      	ldr	r2, [r4, #0]
 8003af6:	68a1      	ldr	r1, [r4, #8]
 8003af8:	6813      	ldr	r3, [r2, #0]
 8003afa:	3901      	subs	r1, #1
 8003afc:	f423 53f8 	bic.w	r3, r3, #7936	@ 0x1f00
 8003b00:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8003b04:	6013      	str	r3, [r2, #0]
  */
static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
  /* Wait until flag is in expected state */
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8003b06:	6893      	ldr	r3, [r2, #8]
 8003b08:	069b      	lsls	r3, r3, #26
 8003b0a:	d504      	bpl.n	8003b16 <HAL_QSPI_Init+0x3a>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8003b0c:	1c70      	adds	r0, r6, #1
 8003b0e:	d125      	bne.n	8003b5c <HAL_QSPI_Init+0x80>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8003b10:	6893      	ldr	r3, [r2, #8]
 8003b12:	0699      	lsls	r1, r3, #26
 8003b14:	d4fc      	bmi.n	8003b10 <HAL_QSPI_Init+0x34>
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
 8003b16:	e9d4 5007 	ldrd	r5, r0, [r4, #28]
 8003b1a:	68e3      	ldr	r3, [r4, #12]
 8003b1c:	6811      	ldr	r1, [r2, #0]
 8003b1e:	432b      	orrs	r3, r5
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 8003b20:	2500      	movs	r5, #0
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
 8003b22:	4303      	orrs	r3, r0
 8003b24:	6860      	ldr	r0, [r4, #4]
 8003b26:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8003b2a:	4819      	ldr	r0, [pc, #100]	@ (8003b90 <HAL_QSPI_Init+0xb4>)
 8003b2c:	4008      	ands	r0, r1
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
 8003b2e:	6961      	ldr	r1, [r4, #20]
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
 8003b30:	4303      	orrs	r3, r0
 8003b32:	6013      	str	r3, [r2, #0]
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
 8003b34:	69a3      	ldr	r3, [r4, #24]
 8003b36:	6850      	ldr	r0, [r2, #4]
 8003b38:	430b      	orrs	r3, r1
 8003b3a:	6921      	ldr	r1, [r4, #16]
 8003b3c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8003b40:	4914      	ldr	r1, [pc, #80]	@ (8003b94 <HAL_QSPI_Init+0xb8>)
 8003b42:	4001      	ands	r1, r0
  return status;
 8003b44:	4628      	mov	r0, r5
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
 8003b46:	430b      	orrs	r3, r1
 8003b48:	6053      	str	r3, [r2, #4]
    __HAL_QSPI_ENABLE(hqspi);
 8003b4a:	6813      	ldr	r3, [r2, #0]
 8003b4c:	f043 0301 	orr.w	r3, r3, #1
 8003b50:	6013      	str	r3, [r2, #0]
    hqspi->State = HAL_QSPI_STATE_READY;
 8003b52:	2301      	movs	r3, #1
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 8003b54:	6465      	str	r5, [r4, #68]	@ 0x44
    hqspi->State = HAL_QSPI_STATE_READY;
 8003b56:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
}
 8003b5a:	bd70      	pop	{r4, r5, r6, pc}
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003b5c:	f7fe fa94 	bl	8002088 <HAL_GetTick>
 8003b60:	1b40      	subs	r0, r0, r5
 8003b62:	42b0      	cmp	r0, r6
 8003b64:	d80a      	bhi.n	8003b7c <HAL_QSPI_Init+0xa0>
 8003b66:	b14e      	cbz	r6, 8003b7c <HAL_QSPI_Init+0xa0>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8003b68:	6822      	ldr	r2, [r4, #0]
 8003b6a:	e7cc      	b.n	8003b06 <HAL_QSPI_Init+0x2a>
    HAL_QSPI_MspInit(hqspi);
 8003b6c:	4620      	mov	r0, r4
 8003b6e:	f7fc ff67 	bl	8000a40 <HAL_QSPI_MspInit>
  hqspi->Timeout = Timeout;
 8003b72:	f241 3388 	movw	r3, #5000	@ 0x1388
}
 8003b76:	461e      	mov	r6, r3
  hqspi->Timeout = Timeout;
 8003b78:	64a3      	str	r3, [r4, #72]	@ 0x48
}
 8003b7a:	e7bb      	b.n	8003af4 <HAL_QSPI_Init+0x18>
      {
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 8003b7c:	2304      	movs	r3, #4
 8003b7e:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 8003b82:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8003b84:	f043 0301 	orr.w	r3, r3, #1
 8003b88:	6463      	str	r3, [r4, #68]	@ 0x44
    return HAL_ERROR;
 8003b8a:	2001      	movs	r0, #1
}
 8003b8c:	bd70      	pop	{r4, r5, r6, pc}
 8003b8e:	bf00      	nop
 8003b90:	00ffff2f 	.word	0x00ffff2f
 8003b94:	ffe0f8fe 	.word	0xffe0f8fe

08003b98 <HAL_RAMECC_Init>:
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_RAMECC_Init(RAMECC_HandleTypeDef *hramecc)
{
  /* Check the RAMECC peripheral handle */
  if (hramecc == NULL)
 8003b98:	b300      	cbz	r0, 8003bdc <HAL_RAMECC_Init+0x44>

  /* Check the parameters */
  assert_param (IS_RAMECC_MONITOR_ALL_INSTANCE (hramecc->Instance));

  /* Change RAMECC peripheral state */
  hramecc->State = HAL_RAMECC_STATE_BUSY;
 8003b9a:	2202      	movs	r2, #2
 8003b9c:	4603      	mov	r3, r0

  /* Initialise the RAMECC error detected code */
  hramecc->RAMECCErrorCode = HAL_RAMECC_NO_ERROR;

  /* Update the RAMECC state */
  hramecc->State = HAL_RAMECC_STATE_READY;
 8003b9e:	f04f 0c01 	mov.w	ip, #1
{
 8003ba2:	b430      	push	{r4, r5}
  hramecc->Instance->CR &= ~RAMECC_CR_ECCELEN;
 8003ba4:	6804      	ldr	r4, [r0, #0]
  hramecc->ErrorCode = HAL_RAMECC_ERROR_NONE;
 8003ba6:	2500      	movs	r5, #0
  hramecc->State = HAL_RAMECC_STATE_BUSY;
 8003ba8:	7102      	strb	r2, [r0, #4]
  hramecc->Instance->CR &= ~RAMECC_CR_ECCELEN;
 8003baa:	6822      	ldr	r2, [r4, #0]
  ((RAMECC_TypeDef *)((uint32_t)hramecc->Instance & 0xFFFFFF00U))->IER &= \
 8003bac:	f024 01ff 	bic.w	r1, r4, #255	@ 0xff

  /* Return HAL status */
  return HAL_OK;
 8003bb0:	4628      	mov	r0, r5
  hramecc->Instance->CR &= ~RAMECC_CR_ECCELEN;
 8003bb2:	f022 0220 	bic.w	r2, r2, #32
 8003bb6:	6022      	str	r2, [r4, #0]
  ((RAMECC_TypeDef *)((uint32_t)hramecc->Instance & 0xFFFFFF00U))->IER &= \
 8003bb8:	680a      	ldr	r2, [r1, #0]
 8003bba:	f022 020f 	bic.w	r2, r2, #15
 8003bbe:	600a      	str	r2, [r1, #0]
  hramecc->Instance->CR &= ~(RAMECC_CR_ECCSEIE | RAMECC_CR_ECCDEIE | RAMECC_CR_ECCDEBWIE);
 8003bc0:	6822      	ldr	r2, [r4, #0]
 8003bc2:	f022 021c 	bic.w	r2, r2, #28
 8003bc6:	6022      	str	r2, [r4, #0]
  __HAL_RAMECC_CLEAR_FLAG (hramecc, RAMECC_FLAGS_ALL);
 8003bc8:	6862      	ldr	r2, [r4, #4]
 8003bca:	f022 0207 	bic.w	r2, r2, #7
 8003bce:	6062      	str	r2, [r4, #4]
  hramecc->ErrorCode = HAL_RAMECC_ERROR_NONE;
 8003bd0:	609d      	str	r5, [r3, #8]
  hramecc->RAMECCErrorCode = HAL_RAMECC_NO_ERROR;
 8003bd2:	60dd      	str	r5, [r3, #12]
  hramecc->State = HAL_RAMECC_STATE_READY;
 8003bd4:	f883 c004 	strb.w	ip, [r3, #4]
}
 8003bd8:	bc30      	pop	{r4, r5}
 8003bda:	4770      	bx	lr
    return HAL_ERROR;
 8003bdc:	2001      	movs	r0, #1
}
 8003bde:	4770      	bx	lr

08003be0 <HAL_RCC_GetSysClockFreq.part.0>:
    case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLR
      */
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8003be0:	4b33      	ldr	r3, [pc, #204]	@ (8003cb0 <HAL_RCC_GetSysClockFreq.part.0+0xd0>)
uint32_t HAL_RCC_GetSysClockFreq(void)
 8003be2:	b430      	push	{r4, r5}
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8003be4:	6a99      	ldr	r1, [r3, #40]	@ 0x28
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;
 8003be6:	6a9c      	ldr	r4, [r3, #40]	@ 0x28
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
 8003be8:	6add      	ldr	r5, [r3, #44]	@ 0x2c
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));

      if (pllm != 0U)
 8003bea:	f414 7f7c 	tst.w	r4, #1008	@ 0x3f0
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 8003bee:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;
 8003bf0:	f3c4 1005 	ubfx	r0, r4, #4, #6
      if (pllm != 0U)
 8003bf4:	d036      	beq.n	8003c64 <HAL_RCC_GetSysClockFreq.part.0+0x84>
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 8003bf6:	f3c2 02cc 	ubfx	r2, r2, #3, #13
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
 8003bfa:	f005 0501 	and.w	r5, r5, #1
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8003bfe:	f001 0103 	and.w	r1, r1, #3
          case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

            if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
            {
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8003c02:	ee07 0a90 	vmov	s15, r0
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 8003c06:	fb05 f202 	mul.w	r2, r5, r2
        switch (pllsource)
 8003c0a:	2901      	cmp	r1, #1
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8003c0c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8003c10:	ee06 2a90 	vmov	s13, r2
 8003c14:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
        switch (pllsource)
 8003c18:	d002      	beq.n	8003c20 <HAL_RCC_GetSysClockFreq.part.0+0x40>
 8003c1a:	2902      	cmp	r1, #2
 8003c1c:	d042      	beq.n	8003ca4 <HAL_RCC_GetSysClockFreq.part.0+0xc4>
 8003c1e:	b319      	cbz	r1, 8003c68 <HAL_RCC_GetSysClockFreq.part.0+0x88>
          case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
            break;

          default:
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8003c20:	eddf 7a24 	vldr	s15, [pc, #144]	@ 8003cb4 <HAL_RCC_GetSysClockFreq.part.0+0xd4>
 8003c24:	ee87 6a87 	vdiv.f32	s12, s15, s14
 8003c28:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8003c2a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003c2e:	ee07 3a90 	vmov	s15, r3
 8003c32:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 8003c36:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8003c3a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8003c3e:	ee77 7aa5 	vadd.f32	s15, s15, s11
 8003c42:	ee67 7a86 	vmul.f32	s15, s15, s12
            break;
        }
        pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9) + 1U) ;
 8003c46:	4b1a      	ldr	r3, [pc, #104]	@ (8003cb0 <HAL_RCC_GetSysClockFreq.part.0+0xd0>)
 8003c48:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8003c4a:	f3c3 2346 	ubfx	r3, r3, #9, #7
 8003c4e:	3301      	adds	r3, #1
        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
 8003c50:	ee07 3a10 	vmov	s14, r3
 8003c54:	eef8 6ac7 	vcvt.f32.s32	s13, s14
 8003c58:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8003c5c:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8003c60:	ee17 0a90 	vmov	r0, s15
      sysclockfreq = CSI_VALUE;
      break;
  }

  return sysclockfreq;
}
 8003c64:	bc30      	pop	{r4, r5}
 8003c66:	4770      	bx	lr
            if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8003c68:	681a      	ldr	r2, [r3, #0]
 8003c6a:	0692      	lsls	r2, r2, #26
 8003c6c:	d51d      	bpl.n	8003caa <HAL_RCC_GetSysClockFreq.part.0+0xca>
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8003c6e:	6819      	ldr	r1, [r3, #0]
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8003c70:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8003c74:	4a10      	ldr	r2, [pc, #64]	@ (8003cb8 <HAL_RCC_GetSysClockFreq.part.0+0xd8>)
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8003c76:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8003c78:	f3c1 01c1 	ubfx	r1, r1, #3, #2
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8003c7c:	f3c3 0308 	ubfx	r3, r3, #0, #9
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8003c80:	40ca      	lsrs	r2, r1
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8003c82:	ee07 3a90 	vmov	s15, r3
 8003c86:	ee06 2a10 	vmov	s12, r2
 8003c8a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8003c8e:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
 8003c92:	ee77 6aa6 	vadd.f32	s13, s15, s13
 8003c96:	eec6 7a07 	vdiv.f32	s15, s12, s14
 8003c9a:	ee36 7aa5 	vadd.f32	s14, s13, s11
 8003c9e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8003ca2:	e7d0      	b.n	8003c46 <HAL_RCC_GetSysClockFreq.part.0+0x66>
            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8003ca4:	eddf 7a05 	vldr	s15, [pc, #20]	@ 8003cbc <HAL_RCC_GetSysClockFreq.part.0+0xdc>
 8003ca8:	e7bc      	b.n	8003c24 <HAL_RCC_GetSysClockFreq.part.0+0x44>
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8003caa:	eddf 7a05 	vldr	s15, [pc, #20]	@ 8003cc0 <HAL_RCC_GetSysClockFreq.part.0+0xe0>
 8003cae:	e7b9      	b.n	8003c24 <HAL_RCC_GetSysClockFreq.part.0+0x44>
 8003cb0:	58024400 	.word	0x58024400
 8003cb4:	4a742400 	.word	0x4a742400
 8003cb8:	03d09000 	.word	0x03d09000
 8003cbc:	4bbebc20 	.word	0x4bbebc20
 8003cc0:	4c742400 	.word	0x4c742400

08003cc4 <HAL_RCC_GetSysClockFreq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8003cc4:	4a0c      	ldr	r2, [pc, #48]	@ (8003cf8 <HAL_RCC_GetSysClockFreq+0x34>)
 8003cc6:	6913      	ldr	r3, [r2, #16]
 8003cc8:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8003ccc:	2b10      	cmp	r3, #16
 8003cce:	d00d      	beq.n	8003cec <HAL_RCC_GetSysClockFreq+0x28>
 8003cd0:	2b18      	cmp	r3, #24
 8003cd2:	d009      	beq.n	8003ce8 <HAL_RCC_GetSysClockFreq+0x24>
 8003cd4:	b963      	cbnz	r3, 8003cf0 <HAL_RCC_GetSysClockFreq+0x2c>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8003cd6:	6813      	ldr	r3, [r2, #0]
 8003cd8:	069b      	lsls	r3, r3, #26
 8003cda:	d50b      	bpl.n	8003cf4 <HAL_RCC_GetSysClockFreq+0x30>
        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8003cdc:	6813      	ldr	r3, [r2, #0]
 8003cde:	4807      	ldr	r0, [pc, #28]	@ (8003cfc <HAL_RCC_GetSysClockFreq+0x38>)
 8003ce0:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 8003ce4:	40d8      	lsrs	r0, r3
 8003ce6:	4770      	bx	lr
 8003ce8:	f7ff bf7a 	b.w	8003be0 <HAL_RCC_GetSysClockFreq.part.0>
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8003cec:	4804      	ldr	r0, [pc, #16]	@ (8003d00 <HAL_RCC_GetSysClockFreq+0x3c>)
 8003cee:	4770      	bx	lr
      sysclockfreq = CSI_VALUE;
 8003cf0:	4804      	ldr	r0, [pc, #16]	@ (8003d04 <HAL_RCC_GetSysClockFreq+0x40>)
 8003cf2:	4770      	bx	lr
        sysclockfreq = (uint32_t) HSI_VALUE;
 8003cf4:	4801      	ldr	r0, [pc, #4]	@ (8003cfc <HAL_RCC_GetSysClockFreq+0x38>)
}
 8003cf6:	4770      	bx	lr
 8003cf8:	58024400 	.word	0x58024400
 8003cfc:	03d09000 	.word	0x03d09000
 8003d00:	017d7840 	.word	0x017d7840
 8003d04:	003d0900 	.word	0x003d0900

08003d08 <HAL_RCC_GetHCLKFreq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8003d08:	4a18      	ldr	r2, [pc, #96]	@ (8003d6c <HAL_RCC_GetHCLKFreq+0x64>)
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8003d0a:	b538      	push	{r3, r4, r5, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8003d0c:	6913      	ldr	r3, [r2, #16]
 8003d0e:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8003d12:	2b10      	cmp	r3, #16
 8003d14:	d024      	beq.n	8003d60 <HAL_RCC_GetHCLKFreq+0x58>
 8003d16:	2b18      	cmp	r3, #24
 8003d18:	d009      	beq.n	8003d2e <HAL_RCC_GetHCLKFreq+0x26>
 8003d1a:	bb1b      	cbnz	r3, 8003d64 <HAL_RCC_GetHCLKFreq+0x5c>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8003d1c:	6813      	ldr	r3, [r2, #0]
 8003d1e:	069b      	lsls	r3, r3, #26
 8003d20:	d522      	bpl.n	8003d68 <HAL_RCC_GetHCLKFreq+0x60>
        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8003d22:	6812      	ldr	r2, [r2, #0]
 8003d24:	4b12      	ldr	r3, [pc, #72]	@ (8003d70 <HAL_RCC_GetHCLKFreq+0x68>)
 8003d26:	f3c2 02c1 	ubfx	r2, r2, #3, #2
 8003d2a:	40d3      	lsrs	r3, r2
 8003d2c:	e002      	b.n	8003d34 <HAL_RCC_GetHCLKFreq+0x2c>
 8003d2e:	f7ff ff57 	bl	8003be0 <HAL_RCC_GetSysClockFreq.part.0>
 8003d32:	4603      	mov	r3, r0
  uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8003d34:	490d      	ldr	r1, [pc, #52]	@ (8003d6c <HAL_RCC_GetHCLKFreq+0x64>)
 8003d36:	480f      	ldr	r0, [pc, #60]	@ (8003d74 <HAL_RCC_GetHCLKFreq+0x6c>)
 8003d38:	698a      	ldr	r2, [r1, #24]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8003d3a:	6989      	ldr	r1, [r1, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8003d3c:	f3c2 2203 	ubfx	r2, r2, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8003d40:	4c0d      	ldr	r4, [pc, #52]	@ (8003d78 <HAL_RCC_GetHCLKFreq+0x70>)
 8003d42:	f001 010f 	and.w	r1, r1, #15
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 8003d46:	4d0d      	ldr	r5, [pc, #52]	@ (8003d7c <HAL_RCC_GetHCLKFreq+0x74>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8003d48:	5c82      	ldrb	r2, [r0, r2]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8003d4a:	5c40      	ldrb	r0, [r0, r1]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8003d4c:	f002 021f 	and.w	r2, r2, #31
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8003d50:	f000 001f 	and.w	r0, r0, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8003d54:	40d3      	lsrs	r3, r2
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8003d56:	fa23 f000 	lsr.w	r0, r3, r0
  SystemCoreClock = common_system_clock;
 8003d5a:	602b      	str	r3, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8003d5c:	6020      	str	r0, [r4, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
}
 8003d5e:	bd38      	pop	{r3, r4, r5, pc}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8003d60:	4b07      	ldr	r3, [pc, #28]	@ (8003d80 <HAL_RCC_GetHCLKFreq+0x78>)
 8003d62:	e7e7      	b.n	8003d34 <HAL_RCC_GetHCLKFreq+0x2c>
      sysclockfreq = CSI_VALUE;
 8003d64:	4b07      	ldr	r3, [pc, #28]	@ (8003d84 <HAL_RCC_GetHCLKFreq+0x7c>)
 8003d66:	e7e5      	b.n	8003d34 <HAL_RCC_GetHCLKFreq+0x2c>
        sysclockfreq = (uint32_t) HSI_VALUE;
 8003d68:	4b01      	ldr	r3, [pc, #4]	@ (8003d70 <HAL_RCC_GetHCLKFreq+0x68>)
 8003d6a:	e7e3      	b.n	8003d34 <HAL_RCC_GetHCLKFreq+0x2c>
 8003d6c:	58024400 	.word	0x58024400
 8003d70:	03d09000 	.word	0x03d09000
 8003d74:	08008738 	.word	0x08008738
 8003d78:	24000024 	.word	0x24000024
 8003d7c:	24000028 	.word	0x24000028
 8003d80:	017d7840 	.word	0x017d7840
 8003d84:	003d0900 	.word	0x003d0900

08003d88 <LL_GPIO_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content
  *          - ERROR:   Not applicable
  */
ErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)
{
 8003d88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
  assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));

  /* ------------------------- Configure the port pins ---------------- */
  /* Initialize  pinpos on first pin set */
  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);
 8003d8c:	680c      	ldr	r4, [r1, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8003d8e:	fa94 f2a4 	rbit	r2, r4
  if (value == 0U)
 8003d92:	2a00      	cmp	r2, #0
 8003d94:	d067      	beq.n	8003e66 <LL_GPIO_Init+0xde>
  return __builtin_clz(value);
 8003d96:	fab2 f282 	clz	r2, r2

  /* Configure the port pins */
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8003d9a:	fa34 f302 	lsrs.w	r3, r4, r2
 8003d9e:	d062      	beq.n	8003e66 <LL_GPIO_Init+0xde>
  {
    /* Get current io position */
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001UL << pinpos);
 8003da0:	f04f 0c01 	mov.w	ip, #1
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8003da4:	ea6f 0e04 	mvn.w	lr, r4
 8003da8:	e00e      	b.n	8003dc8 <LL_GPIO_Init+0x40>
  MODIFY_REG(GPIOx->PUPDR, ((Pin * Pin) * GPIO_PUPDR_PUPD0), ((Pin * Pin) * Pull));
 8003daa:	68c3      	ldr	r3, [r0, #12]
 8003dac:	4033      	ands	r3, r6
 8003dae:	ea43 0309 	orr.w	r3, r3, r9
 8003db2:	60c3      	str	r3, [r0, #12]
  MODIFY_REG(GPIOx->MODER, ((Pin * Pin) * GPIO_MODER_MODE0), ((Pin * Pin) * Mode));
 8003db4:	6803      	ldr	r3, [r0, #0]
 8003db6:	fb0b f505 	mul.w	r5, fp, r5
 8003dba:	4033      	ands	r3, r6
 8003dbc:	432b      	orrs	r3, r5
 8003dbe:	6003      	str	r3, [r0, #0]
      }

      /* Pin Mode configuration */
      LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
    }
    pinpos++;
 8003dc0:	3201      	adds	r2, #1
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8003dc2:	fa34 f302 	lsrs.w	r3, r4, r2
 8003dc6:	d04e      	beq.n	8003e66 <LL_GPIO_Init+0xde>
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001UL << pinpos);
 8003dc8:	fa0c f302 	lsl.w	r3, ip, r2
    if (currentpin != 0x00000000U)
 8003dcc:	4023      	ands	r3, r4
  MODIFY_REG(GPIOx->OSPEEDR, ((Pin * Pin) * GPIO_OSPEEDR_OSPEED0), ((Pin * Pin) * Speed));
 8003dce:	fb03 f503 	mul.w	r5, r3, r3
 8003dd2:	d0f5      	beq.n	8003dc0 <LL_GPIO_Init+0x38>
      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8003dd4:	f8d1 b004 	ldr.w	fp, [r1, #4]
 8003dd8:	eb05 0645 	add.w	r6, r5, r5, lsl #1
  MODIFY_REG(GPIOx->PUPDR, ((Pin * Pin) * GPIO_PUPDR_PUPD0), ((Pin * Pin) * Pull));
 8003ddc:	690f      	ldr	r7, [r1, #16]
 8003dde:	f10b 38ff 	add.w	r8, fp, #4294967295
  MODIFY_REG(GPIOx->OSPEEDR, ((Pin * Pin) * GPIO_OSPEEDR_OSPEED0), ((Pin * Pin) * Speed));
 8003de2:	43f6      	mvns	r6, r6
  MODIFY_REG(GPIOx->PUPDR, ((Pin * Pin) * GPIO_PUPDR_PUPD0), ((Pin * Pin) * Pull));
 8003de4:	fb07 f905 	mul.w	r9, r7, r5
 8003de8:	f1b8 0f01 	cmp.w	r8, #1
 8003dec:	d8dd      	bhi.n	8003daa <LL_GPIO_Init+0x22>
  MODIFY_REG(GPIOx->OSPEEDR, ((Pin * Pin) * GPIO_OSPEEDR_OSPEED0), ((Pin * Pin) * Speed));
 8003dee:	f8d0 a008 	ldr.w	sl, [r0, #8]
      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)
 8003df2:	f1bb 0f02 	cmp.w	fp, #2
 8003df6:	688f      	ldr	r7, [r1, #8]
 8003df8:	ea0a 0a06 	and.w	sl, sl, r6
 8003dfc:	fb07 f805 	mul.w	r8, r7, r5
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8003e00:	68cf      	ldr	r7, [r1, #12]
  MODIFY_REG(GPIOx->OSPEEDR, ((Pin * Pin) * GPIO_OSPEEDR_OSPEED0), ((Pin * Pin) * Speed));
 8003e02:	ea48 080a 	orr.w	r8, r8, sl
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8003e06:	fb07 fa04 	mul.w	sl, r7, r4
  MODIFY_REG(GPIOx->OSPEEDR, ((Pin * Pin) * GPIO_OSPEEDR_OSPEED0), ((Pin * Pin) * Speed));
 8003e0a:	f8c0 8008 	str.w	r8, [r0, #8]
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8003e0e:	f8d0 8004 	ldr.w	r8, [r0, #4]
 8003e12:	ea0e 0808 	and.w	r8, lr, r8
 8003e16:	ea48 080a 	orr.w	r8, r8, sl
 8003e1a:	f8c0 8004 	str.w	r8, [r0, #4]
  MODIFY_REG(GPIOx->AFR[1], (((((Pin >> 8U) * (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)) * GPIO_AFRH_AFSEL8),
 8003e1e:	ea4f 2813 	mov.w	r8, r3, lsr #8
  MODIFY_REG(GPIOx->PUPDR, ((Pin * Pin) * GPIO_PUPDR_PUPD0), ((Pin * Pin) * Pull));
 8003e22:	f8d0 a00c 	ldr.w	sl, [r0, #12]
  MODIFY_REG(GPIOx->AFR[1], (((((Pin >> 8U) * (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)) * GPIO_AFRH_AFSEL8),
 8003e26:	fb08 f808 	mul.w	r8, r8, r8
  MODIFY_REG(GPIOx->PUPDR, ((Pin * Pin) * GPIO_PUPDR_PUPD0), ((Pin * Pin) * Pull));
 8003e2a:	ea0a 0a06 	and.w	sl, sl, r6
  MODIFY_REG(GPIOx->AFR[1], (((((Pin >> 8U) * (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)) * GPIO_AFRH_AFSEL8),
 8003e2e:	fb08 f808 	mul.w	r8, r8, r8
  MODIFY_REG(GPIOx->PUPDR, ((Pin * Pin) * GPIO_PUPDR_PUPD0), ((Pin * Pin) * Pull));
 8003e32:	ea4a 0909 	orr.w	r9, sl, r9
 8003e36:	f8c0 900c 	str.w	r9, [r0, #12]
 8003e3a:	d1bb      	bne.n	8003db4 <LL_GPIO_Init+0x2c>
          LL_GPIO_SetAFPin_0_7(GPIOx, currentpin, GPIO_InitStruct->Alternate);
 8003e3c:	f8d1 9014 	ldr.w	r9, [r1, #20]
        if (currentpin < LL_GPIO_PIN_8)
 8003e40:	2bff      	cmp	r3, #255	@ 0xff
  MODIFY_REG(GPIOx->AFR[1], (((((Pin >> 8U) * (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)) * GPIO_AFRH_AFSEL8),
 8003e42:	ebc8 1a08 	rsb	sl, r8, r8, lsl #4
 8003e46:	fb09 f808 	mul.w	r8, r9, r8
 8003e4a:	d80f      	bhi.n	8003e6c <LL_GPIO_Init+0xe4>
  MODIFY_REG(GPIOx->AFR[0], ((((Pin * Pin) * Pin) * Pin) * GPIO_AFRL_AFSEL0),
 8003e4c:	fb05 f805 	mul.w	r8, r5, r5
 8003e50:	6a03      	ldr	r3, [r0, #32]
 8003e52:	fb08 f909 	mul.w	r9, r8, r9
 8003e56:	ebc8 1808 	rsb	r8, r8, r8, lsl #4
 8003e5a:	ea23 0308 	bic.w	r3, r3, r8
 8003e5e:	ea43 0309 	orr.w	r3, r3, r9
 8003e62:	6203      	str	r3, [r0, #32]
}
 8003e64:	e7a6      	b.n	8003db4 <LL_GPIO_Init+0x2c>
  }

  return (SUCCESS);
}
 8003e66:	2000      	movs	r0, #0
 8003e68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  MODIFY_REG(GPIOx->AFR[1], (((((Pin >> 8U) * (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)) * GPIO_AFRH_AFSEL8),
 8003e6c:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 8003e6e:	ea23 030a 	bic.w	r3, r3, sl
 8003e72:	ea43 0308 	orr.w	r3, r3, r8
 8003e76:	6243      	str	r3, [r0, #36]	@ 0x24
}
 8003e78:	e79c      	b.n	8003db4 <LL_GPIO_Init+0x2c>
 8003e7a:	bf00      	nop

08003e7c <LL_RCC_GetPLL1ClockFreq>:
  return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_PLLSRC));
 8003e7c:	4a5e      	ldr	r2, [pc, #376]	@ (8003ff8 <LL_RCC_GetPLL1ClockFreq+0x17c>)
 8003e7e:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 8003e80:	f003 0303 	and.w	r3, r3, #3
  /* PLL_VCO = (HSE_VALUE, CSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP
  */
  pllsource = LL_RCC_PLL_GetSource();

  switch (pllsource)
 8003e84:	2b01      	cmp	r3, #1
{
 8003e86:	b410      	push	{r4}
  switch (pllsource)
 8003e88:	f000 80aa 	beq.w	8003fe0 <LL_RCC_GetPLL1ClockFreq+0x164>
 8003e8c:	2b02      	cmp	r3, #2
 8003e8e:	d00d      	beq.n	8003eac <LL_RCC_GetPLL1ClockFreq+0x30>
 8003e90:	2b00      	cmp	r3, #0
 8003e92:	f040 80ae 	bne.w	8003ff2 <LL_RCC_GetPLL1ClockFreq+0x176>
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8003e96:	6813      	ldr	r3, [r2, #0]
 8003e98:	f013 0c04 	ands.w	ip, r3, #4
 8003e9c:	d00e      	beq.n	8003ebc <LL_RCC_GetPLL1ClockFreq+0x40>
  return (READ_BIT(RCC->CR, RCC_CR_HSIDIV));
 8003e9e:	6812      	ldr	r2, [r2, #0]
  {
    case LL_RCC_PLLSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
      {
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_CR_HSIDIV_Pos);
 8003ea0:	4b56      	ldr	r3, [pc, #344]	@ (8003ffc <LL_RCC_GetPLL1ClockFreq+0x180>)
 8003ea2:	f3c2 02c1 	ubfx	r2, r2, #3, #2
 8003ea6:	fa23 fc02 	lsr.w	ip, r3, r2
 8003eaa:	e007      	b.n	8003ebc <LL_RCC_GetPLL1ClockFreq+0x40>
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 8003eac:	6812      	ldr	r2, [r2, #0]
  uint32_t pllinputfreq = LL_RCC_PERIPH_FREQUENCY_NO, pllsource;
 8003eae:	4b54      	ldr	r3, [pc, #336]	@ (8004000 <LL_RCC_GetPLL1ClockFreq+0x184>)
 8003eb0:	f412 3f00 	tst.w	r2, #131072	@ 0x20000
 8003eb4:	bf14      	ite	ne
 8003eb6:	469c      	movne	ip, r3
 8003eb8:	f04f 0c00 	moveq.w	ip, #0
    default:
      /* PLL clock disabled */
      break;
  }

  PLL_Clocks->PLL_P_Frequency = 0U;
 8003ebc:	2300      	movs	r3, #0
  return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM1) >>  RCC_PLLCKSELR_DIVM1_Pos);
 8003ebe:	4c4e      	ldr	r4, [pc, #312]	@ (8003ff8 <LL_RCC_GetPLL1ClockFreq+0x17c>)
 8003ec0:	e9c0 3300 	strd	r3, r3, [r0]
  PLL_Clocks->PLL_Q_Frequency = 0U;
  PLL_Clocks->PLL_R_Frequency = 0U;
 8003ec4:	6083      	str	r3, [r0, #8]
 8003ec6:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
  return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_N1) >>  RCC_PLL1DIVR_N1_Pos) + 1UL);
 8003ec8:	6b21      	ldr	r1, [r4, #48]	@ 0x30
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL1FRACEN) == RCC_PLLCFGR_PLL1FRACEN) ? 1UL : 0UL);
 8003eca:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
  return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM1) >>  RCC_PLLCKSELR_DIVM1_Pos);
 8003ecc:	f3c2 1205 	ubfx	r2, r2, #4, #6
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL1FRACEN) == RCC_PLLCFGR_PLL1FRACEN) ? 1UL : 0UL);
 8003ed0:	f013 0301 	ands.w	r3, r3, #1
 8003ed4:	d002      	beq.n	8003edc <LL_RCC_GetPLL1ClockFreq+0x60>
  return (uint32_t)(READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_FRACN1) >>  RCC_PLL1FRACR_FRACN1_Pos);
 8003ed6:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8003ed8:	f3c3 03cc 	ubfx	r3, r3, #3, #13
  if (LL_RCC_PLL1FRACN_IsEnabled() != 0U)
  {
    fracn = LL_RCC_PLL1_GetFRACN();
  }

  if (m != 0U)
 8003edc:	2a00      	cmp	r2, #0
 8003ede:	d07c      	beq.n	8003fda <LL_RCC_GetPLL1ClockFreq+0x15e>
  return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_N1) >>  RCC_PLL1DIVR_N1_Pos) + 1UL);
 8003ee0:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8003ee4:	3101      	adds	r1, #1
 8003ee6:	ee07 1a10 	vmov	s14, r1
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP1EN) == RCC_PLLCFGR_DIVP1EN) ? 1UL : 0UL);
 8003eea:	4943      	ldr	r1, [pc, #268]	@ (8003ff8 <LL_RCC_GetPLL1ClockFreq+0x17c>)
 8003eec:	6acc      	ldr	r4, [r1, #44]	@ 0x2c
 8003eee:	03e4      	lsls	r4, r4, #15
 8003ef0:	d523      	bpl.n	8003f3a <LL_RCC_GetPLL1ClockFreq+0xbe>
  */
uint32_t LL_RCC_CalcPLLClockFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t PQR)
{
  float_t freq;

  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 8003ef2:	ee07 3a90 	vmov	s15, r3
 8003ef6:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_P1) >>  RCC_PLL1DIVR_P1_Pos) + 1UL);
 8003efa:	6b09      	ldr	r1, [r1, #48]	@ 0x30
 8003efc:	eef8 4ae7 	vcvt.f32.s32	s9, s15
 8003f00:	ee07 ca90 	vmov	s15, ip
 8003f04:	ed9f 5a3f 	vldr	s10, [pc, #252]	@ 8004004 <LL_RCC_GetPLL1ClockFreq+0x188>
 8003f08:	f3c1 2146 	ubfx	r1, r1, #9, #7
 8003f0c:	eef8 5ae7 	vcvt.f32.s32	s11, s15
 8003f10:	ee07 2a90 	vmov	s15, r2
 8003f14:	eee4 6a85 	vfma.f32	s13, s9, s10
 8003f18:	3101      	adds	r1, #1
 8003f1a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8003f1e:	ee85 6aa7 	vdiv.f32	s12, s11, s15

  freq = freq / (float_t)PQR;
 8003f22:	ee07 1a90 	vmov	s15, r1
 8003f26:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 8003f2a:	ee26 6a26 	vmul.f32	s12, s12, s13
  freq = freq / (float_t)PQR;
 8003f2e:	eec6 6a27 	vdiv.f32	s13, s12, s15

  return (uint32_t)freq;
 8003f32:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 8003f36:	edc0 6a00 	vstr	s13, [r0]
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ1EN) == RCC_PLLCFGR_DIVQ1EN) ? 1UL : 0UL);
 8003f3a:	492f      	ldr	r1, [pc, #188]	@ (8003ff8 <LL_RCC_GetPLL1ClockFreq+0x17c>)
 8003f3c:	6acc      	ldr	r4, [r1, #44]	@ 0x2c
 8003f3e:	03a4      	lsls	r4, r4, #14
 8003f40:	d523      	bpl.n	8003f8a <LL_RCC_GetPLL1ClockFreq+0x10e>
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 8003f42:	ee07 3a90 	vmov	s15, r3
 8003f46:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_Q1) >>  RCC_PLL1DIVR_Q1_Pos) + 1UL);
 8003f4a:	6b09      	ldr	r1, [r1, #48]	@ 0x30
 8003f4c:	eef8 4ae7 	vcvt.f32.s32	s9, s15
 8003f50:	ee07 ca90 	vmov	s15, ip
 8003f54:	ed9f 5a2b 	vldr	s10, [pc, #172]	@ 8004004 <LL_RCC_GetPLL1ClockFreq+0x188>
 8003f58:	f3c1 4106 	ubfx	r1, r1, #16, #7
 8003f5c:	eef8 5ae7 	vcvt.f32.s32	s11, s15
 8003f60:	ee07 2a90 	vmov	s15, r2
 8003f64:	eee4 6a85 	vfma.f32	s13, s9, s10
 8003f68:	3101      	adds	r1, #1
 8003f6a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8003f6e:	ee85 6aa7 	vdiv.f32	s12, s11, s15
  freq = freq / (float_t)PQR;
 8003f72:	ee07 1a90 	vmov	s15, r1
 8003f76:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 8003f7a:	ee26 6a26 	vmul.f32	s12, s12, s13
  freq = freq / (float_t)PQR;
 8003f7e:	eec6 6a27 	vdiv.f32	s13, s12, s15
  return (uint32_t)freq;
 8003f82:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 8003f86:	edc0 6a01 	vstr	s13, [r0, #4]
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR1EN) == RCC_PLLCFGR_DIVR1EN) ? 1UL : 0UL);
 8003f8a:	491b      	ldr	r1, [pc, #108]	@ (8003ff8 <LL_RCC_GetPLL1ClockFreq+0x17c>)
 8003f8c:	6acc      	ldr	r4, [r1, #44]	@ 0x2c
 8003f8e:	0364      	lsls	r4, r4, #13
 8003f90:	d523      	bpl.n	8003fda <LL_RCC_GetPLL1ClockFreq+0x15e>
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 8003f92:	ee07 ca90 	vmov	s15, ip
 8003f96:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8003f9a:	ed9f 5a1a 	vldr	s10, [pc, #104]	@ 8004004 <LL_RCC_GetPLL1ClockFreq+0x188>
 8003f9e:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 8003fa2:	ee07 2a90 	vmov	s15, r2
 8003fa6:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
 8003faa:	ee07 3a90 	vmov	s15, r3
  return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_R1) >>  RCC_PLL1DIVR_R1_Pos) + 1UL);
 8003fae:	6b0b      	ldr	r3, [r1, #48]	@ 0x30
 8003fb0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8003fb4:	eec6 5a86 	vdiv.f32	s11, s13, s12
 8003fb8:	f3c3 6306 	ubfx	r3, r3, #24, #7
 8003fbc:	3301      	adds	r3, #1
 8003fbe:	eea7 7a85 	vfma.f32	s14, s15, s10
  freq = freq / (float_t)PQR;
 8003fc2:	ee07 3a90 	vmov	s15, r3
 8003fc6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 8003fca:	ee65 6a87 	vmul.f32	s13, s11, s14
  freq = freq / (float_t)PQR;
 8003fce:	ee86 7aa7 	vdiv.f32	s14, s13, s15
  return (uint32_t)freq;
 8003fd2:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 8003fd6:	ed80 7a02 	vstr	s14, [r0, #8]
}
 8003fda:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003fde:	4770      	bx	lr
  return ((READ_BIT(RCC->CR, RCC_CR_CSIRDY) == (RCC_CR_CSIRDY)) ? 1UL : 0UL);
 8003fe0:	6812      	ldr	r2, [r2, #0]
  uint32_t pllinputfreq = LL_RCC_PERIPH_FREQUENCY_NO, pllsource;
 8003fe2:	4b09      	ldr	r3, [pc, #36]	@ (8004008 <LL_RCC_GetPLL1ClockFreq+0x18c>)
 8003fe4:	f412 7f80 	tst.w	r2, #256	@ 0x100
 8003fe8:	bf14      	ite	ne
 8003fea:	469c      	movne	ip, r3
 8003fec:	f04f 0c00 	moveq.w	ip, #0
 8003ff0:	e764      	b.n	8003ebc <LL_RCC_GetPLL1ClockFreq+0x40>
 8003ff2:	f04f 0c00 	mov.w	ip, #0
 8003ff6:	e761      	b.n	8003ebc <LL_RCC_GetPLL1ClockFreq+0x40>
 8003ff8:	58024400 	.word	0x58024400
 8003ffc:	03d09000 	.word	0x03d09000
 8004000:	017d7840 	.word	0x017d7840
 8004004:	39000000 	.word	0x39000000
 8004008:	003d0900 	.word	0x003d0900

0800400c <RCC_GetSystemClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800400c:	4b15      	ldr	r3, [pc, #84]	@ (8004064 <RCC_GetSystemClockFreq+0x58>)
 800400e:	691b      	ldr	r3, [r3, #16]
 8004010:	f003 0338 	and.w	r3, r3, #56	@ 0x38
{
  uint32_t frequency = 0U;
  LL_PLL_ClocksTypeDef PLL_Clocks;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetSysClkSource())
 8004014:	2b18      	cmp	r3, #24
 8004016:	d80e      	bhi.n	8004036 <RCC_GetSystemClockFreq+0x2a>
 8004018:	e8df f003 	tbb	[pc, r3]
 800401c:	0d0d0d1a 	.word	0x0d0d0d1a
 8004020:	0d0d0d0d 	.word	0x0d0d0d0d
 8004024:	0d0d0d21 	.word	0x0d0d0d21
 8004028:	0d0d0d0d 	.word	0x0d0d0d0d
 800402c:	0d0d0d18 	.word	0x0d0d0d18
 8004030:	0d0d0d0d 	.word	0x0d0d0d0d
 8004034:	0f          	.byte	0x0f
 8004035:	00          	.byte	0x00
  uint32_t frequency = 0U;
 8004036:	2000      	movs	r0, #0
 8004038:	4770      	bx	lr
{
 800403a:	b500      	push	{lr}
 800403c:	b085      	sub	sp, #20
    case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:
      frequency = HSE_VALUE;
      break;

    case LL_RCC_SYS_CLKSOURCE_STATUS_PLL1:
      LL_RCC_GetPLL1ClockFreq(&PLL_Clocks);
 800403e:	a801      	add	r0, sp, #4
 8004040:	f7ff ff1c 	bl	8003e7c <LL_RCC_GetPLL1ClockFreq>
      frequency = PLL_Clocks.PLL_P_Frequency;
 8004044:	9801      	ldr	r0, [sp, #4]
      /* Nothing to do */
      break;
  }

  return frequency;
}
 8004046:	b005      	add	sp, #20
 8004048:	f85d fb04 	ldr.w	pc, [sp], #4
      frequency = HSE_VALUE;
 800404c:	4806      	ldr	r0, [pc, #24]	@ (8004068 <RCC_GetSystemClockFreq+0x5c>)
      break;
 800404e:	4770      	bx	lr
  return (READ_BIT(RCC->CR, RCC_CR_HSIDIV));
 8004050:	4b04      	ldr	r3, [pc, #16]	@ (8004064 <RCC_GetSystemClockFreq+0x58>)
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_CR_HSIDIV_Pos);
 8004052:	4806      	ldr	r0, [pc, #24]	@ (800406c <RCC_GetSystemClockFreq+0x60>)
 8004054:	681b      	ldr	r3, [r3, #0]
 8004056:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 800405a:	40d8      	lsrs	r0, r3
  return frequency;
 800405c:	4770      	bx	lr
  switch (LL_RCC_GetSysClkSource())
 800405e:	4804      	ldr	r0, [pc, #16]	@ (8004070 <RCC_GetSystemClockFreq+0x64>)
}
 8004060:	4770      	bx	lr
 8004062:	bf00      	nop
 8004064:	58024400 	.word	0x58024400
 8004068:	017d7840 	.word	0x017d7840
 800406c:	03d09000 	.word	0x03d09000
 8004070:	003d0900 	.word	0x003d0900

08004074 <LL_RCC_GetPLL2ClockFreq>:
  return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_PLLSRC));
 8004074:	4a5e      	ldr	r2, [pc, #376]	@ (80041f0 <LL_RCC_GetPLL2ClockFreq+0x17c>)
 8004076:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 8004078:	f003 0303 	and.w	r3, r3, #3
  switch (pllsource)
 800407c:	2b01      	cmp	r3, #1
{
 800407e:	b410      	push	{r4}
  switch (pllsource)
 8004080:	f000 80aa 	beq.w	80041d8 <LL_RCC_GetPLL2ClockFreq+0x164>
 8004084:	2b02      	cmp	r3, #2
 8004086:	d00d      	beq.n	80040a4 <LL_RCC_GetPLL2ClockFreq+0x30>
 8004088:	2b00      	cmp	r3, #0
 800408a:	f040 80ae 	bne.w	80041ea <LL_RCC_GetPLL2ClockFreq+0x176>
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 800408e:	6813      	ldr	r3, [r2, #0]
 8004090:	f013 0c04 	ands.w	ip, r3, #4
 8004094:	d00e      	beq.n	80040b4 <LL_RCC_GetPLL2ClockFreq+0x40>
  return (READ_BIT(RCC->CR, RCC_CR_HSIDIV));
 8004096:	6812      	ldr	r2, [r2, #0]
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_CR_HSIDIV_Pos);
 8004098:	4b56      	ldr	r3, [pc, #344]	@ (80041f4 <LL_RCC_GetPLL2ClockFreq+0x180>)
 800409a:	f3c2 02c1 	ubfx	r2, r2, #3, #2
 800409e:	fa23 fc02 	lsr.w	ip, r3, r2
 80040a2:	e007      	b.n	80040b4 <LL_RCC_GetPLL2ClockFreq+0x40>
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 80040a4:	6812      	ldr	r2, [r2, #0]
  uint32_t pllinputfreq = LL_RCC_PERIPH_FREQUENCY_NO, pllsource;
 80040a6:	4b54      	ldr	r3, [pc, #336]	@ (80041f8 <LL_RCC_GetPLL2ClockFreq+0x184>)
 80040a8:	f412 3f00 	tst.w	r2, #131072	@ 0x20000
 80040ac:	bf14      	ite	ne
 80040ae:	469c      	movne	ip, r3
 80040b0:	f04f 0c00 	moveq.w	ip, #0
  PLL_Clocks->PLL_P_Frequency = 0U;
 80040b4:	2300      	movs	r3, #0
  * @rmtoll PLLCKSELR       DIVM2          LL_RCC_PLL2_GetM
  * @retval A value between 0 and 63
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetM(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM2) >>  RCC_PLLCKSELR_DIVM2_Pos);
 80040b6:	4c4e      	ldr	r4, [pc, #312]	@ (80041f0 <LL_RCC_GetPLL2ClockFreq+0x17c>)
 80040b8:	e9c0 3300 	strd	r3, r3, [r0]
  PLL_Clocks->PLL_R_Frequency = 0U;
 80040bc:	6083      	str	r3, [r0, #8]
 80040be:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
  return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_N2) >>  RCC_PLL2DIVR_N2_Pos) + 1UL);
 80040c0:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL2FRACEN) == RCC_PLLCFGR_PLL2FRACEN) ? 1UL : 0UL);
 80040c2:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
  return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM2) >>  RCC_PLLCKSELR_DIVM2_Pos);
 80040c4:	f3c2 3205 	ubfx	r2, r2, #12, #6
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL2FRACEN) == RCC_PLLCFGR_PLL2FRACEN) ? 1UL : 0UL);
 80040c8:	f013 0310 	ands.w	r3, r3, #16
 80040cc:	d002      	beq.n	80040d4 <LL_RCC_GetPLL2ClockFreq+0x60>
  * @rmtoll PLL2FRACR      FRACN2          LL_RCC_PLL2_GetFRACN
  * @retval A value between 0 and 8191 (0x1FFF)
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetFRACN(void)
{
  return (uint32_t)(READ_BIT(RCC->PLL2FRACR, RCC_PLL2FRACR_FRACN2) >>  RCC_PLL2FRACR_FRACN2_Pos);
 80040ce:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 80040d0:	f3c3 03cc 	ubfx	r3, r3, #3, #13
  if (m != 0U)
 80040d4:	2a00      	cmp	r2, #0
 80040d6:	d07c      	beq.n	80041d2 <LL_RCC_GetPLL2ClockFreq+0x15e>
  return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_N2) >>  RCC_PLL2DIVR_N2_Pos) + 1UL);
 80040d8:	f3c1 0108 	ubfx	r1, r1, #0, #9
 80040dc:	3101      	adds	r1, #1
 80040de:	ee07 1a10 	vmov	s14, r1
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP2EN) == RCC_PLLCFGR_DIVP2EN) ? 1UL : 0UL);
 80040e2:	4943      	ldr	r1, [pc, #268]	@ (80041f0 <LL_RCC_GetPLL2ClockFreq+0x17c>)
 80040e4:	6acc      	ldr	r4, [r1, #44]	@ 0x2c
 80040e6:	0324      	lsls	r4, r4, #12
 80040e8:	d523      	bpl.n	8004132 <LL_RCC_GetPLL2ClockFreq+0xbe>
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 80040ea:	ee07 3a90 	vmov	s15, r3
 80040ee:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_P2) >>  RCC_PLL2DIVR_P2_Pos) + 1UL);
 80040f2:	6b89      	ldr	r1, [r1, #56]	@ 0x38
 80040f4:	eef8 4ae7 	vcvt.f32.s32	s9, s15
 80040f8:	ee07 ca90 	vmov	s15, ip
 80040fc:	ed9f 5a3f 	vldr	s10, [pc, #252]	@ 80041fc <LL_RCC_GetPLL2ClockFreq+0x188>
 8004100:	f3c1 2146 	ubfx	r1, r1, #9, #7
 8004104:	eef8 5ae7 	vcvt.f32.s32	s11, s15
 8004108:	ee07 2a90 	vmov	s15, r2
 800410c:	eee4 6a85 	vfma.f32	s13, s9, s10
 8004110:	3101      	adds	r1, #1
 8004112:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004116:	ee85 6aa7 	vdiv.f32	s12, s11, s15
  freq = freq / (float_t)PQR;
 800411a:	ee07 1a90 	vmov	s15, r1
 800411e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 8004122:	ee26 6a26 	vmul.f32	s12, s12, s13
  freq = freq / (float_t)PQR;
 8004126:	eec6 6a27 	vdiv.f32	s13, s12, s15
  return (uint32_t)freq;
 800412a:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800412e:	edc0 6a00 	vstr	s13, [r0]
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ2EN) == RCC_PLLCFGR_DIVQ2EN) ? 1UL : 0UL);
 8004132:	492f      	ldr	r1, [pc, #188]	@ (80041f0 <LL_RCC_GetPLL2ClockFreq+0x17c>)
 8004134:	6acc      	ldr	r4, [r1, #44]	@ 0x2c
 8004136:	02e4      	lsls	r4, r4, #11
 8004138:	d523      	bpl.n	8004182 <LL_RCC_GetPLL2ClockFreq+0x10e>
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 800413a:	ee07 3a90 	vmov	s15, r3
 800413e:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_Q2) >>  RCC_PLL2DIVR_Q2_Pos) + 1UL);
 8004142:	6b89      	ldr	r1, [r1, #56]	@ 0x38
 8004144:	eef8 4ae7 	vcvt.f32.s32	s9, s15
 8004148:	ee07 ca90 	vmov	s15, ip
 800414c:	ed9f 5a2b 	vldr	s10, [pc, #172]	@ 80041fc <LL_RCC_GetPLL2ClockFreq+0x188>
 8004150:	f3c1 4106 	ubfx	r1, r1, #16, #7
 8004154:	eef8 5ae7 	vcvt.f32.s32	s11, s15
 8004158:	ee07 2a90 	vmov	s15, r2
 800415c:	eee4 6a85 	vfma.f32	s13, s9, s10
 8004160:	3101      	adds	r1, #1
 8004162:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004166:	ee85 6aa7 	vdiv.f32	s12, s11, s15
  freq = freq / (float_t)PQR;
 800416a:	ee07 1a90 	vmov	s15, r1
 800416e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 8004172:	ee26 6a26 	vmul.f32	s12, s12, s13
  freq = freq / (float_t)PQR;
 8004176:	eec6 6a27 	vdiv.f32	s13, s12, s15
  return (uint32_t)freq;
 800417a:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800417e:	edc0 6a01 	vstr	s13, [r0, #4]
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR2EN) == RCC_PLLCFGR_DIVR2EN) ? 1UL : 0UL);
 8004182:	491b      	ldr	r1, [pc, #108]	@ (80041f0 <LL_RCC_GetPLL2ClockFreq+0x17c>)
 8004184:	6acc      	ldr	r4, [r1, #44]	@ 0x2c
 8004186:	02a4      	lsls	r4, r4, #10
 8004188:	d523      	bpl.n	80041d2 <LL_RCC_GetPLL2ClockFreq+0x15e>
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 800418a:	ee07 ca90 	vmov	s15, ip
 800418e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8004192:	ed9f 5a1a 	vldr	s10, [pc, #104]	@ 80041fc <LL_RCC_GetPLL2ClockFreq+0x188>
 8004196:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 800419a:	ee07 2a90 	vmov	s15, r2
 800419e:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
 80041a2:	ee07 3a90 	vmov	s15, r3
  return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_R2) >>  RCC_PLL2DIVR_R2_Pos) + 1UL);
 80041a6:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
 80041a8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80041ac:	eec6 5a86 	vdiv.f32	s11, s13, s12
 80041b0:	f3c3 6306 	ubfx	r3, r3, #24, #7
 80041b4:	3301      	adds	r3, #1
 80041b6:	eea7 7a85 	vfma.f32	s14, s15, s10
  freq = freq / (float_t)PQR;
 80041ba:	ee07 3a90 	vmov	s15, r3
 80041be:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 80041c2:	ee65 6a87 	vmul.f32	s13, s11, s14
  freq = freq / (float_t)PQR;
 80041c6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
  return (uint32_t)freq;
 80041ca:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 80041ce:	ed80 7a02 	vstr	s14, [r0, #8]
}
 80041d2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80041d6:	4770      	bx	lr
  return ((READ_BIT(RCC->CR, RCC_CR_CSIRDY) == (RCC_CR_CSIRDY)) ? 1UL : 0UL);
 80041d8:	6812      	ldr	r2, [r2, #0]
  uint32_t pllinputfreq = LL_RCC_PERIPH_FREQUENCY_NO, pllsource;
 80041da:	4b09      	ldr	r3, [pc, #36]	@ (8004200 <LL_RCC_GetPLL2ClockFreq+0x18c>)
 80041dc:	f412 7f80 	tst.w	r2, #256	@ 0x100
 80041e0:	bf14      	ite	ne
 80041e2:	469c      	movne	ip, r3
 80041e4:	f04f 0c00 	moveq.w	ip, #0
 80041e8:	e764      	b.n	80040b4 <LL_RCC_GetPLL2ClockFreq+0x40>
 80041ea:	f04f 0c00 	mov.w	ip, #0
 80041ee:	e761      	b.n	80040b4 <LL_RCC_GetPLL2ClockFreq+0x40>
 80041f0:	58024400 	.word	0x58024400
 80041f4:	03d09000 	.word	0x03d09000
 80041f8:	017d7840 	.word	0x017d7840
 80041fc:	39000000 	.word	0x39000000
 8004200:	003d0900 	.word	0x003d0900

08004204 <LL_RCC_GetPLL3ClockFreq>:
  return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_PLLSRC));
 8004204:	4a5b      	ldr	r2, [pc, #364]	@ (8004374 <LL_RCC_GetPLL3ClockFreq+0x170>)
 8004206:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 8004208:	f003 0303 	and.w	r3, r3, #3
  switch (pllsource)
 800420c:	2b01      	cmp	r3, #1
 800420e:	d019      	beq.n	8004244 <LL_RCC_GetPLL3ClockFreq+0x40>
 8004210:	2b02      	cmp	r3, #2
 8004212:	d00f      	beq.n	8004234 <LL_RCC_GetPLL3ClockFreq+0x30>
 8004214:	b91b      	cbnz	r3, 800421e <LL_RCC_GetPLL3ClockFreq+0x1a>
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8004216:	6813      	ldr	r3, [r2, #0]
 8004218:	075b      	lsls	r3, r3, #29
 800421a:	f100 80a3 	bmi.w	8004364 <LL_RCC_GetPLL3ClockFreq+0x160>
  PLL_Clocks->PLL_P_Frequency = 0U;
 800421e:	2200      	movs	r2, #0
  * @rmtoll PLLCKSELR       DIVM3          LL_RCC_PLL3_GetM
  * @retval A value between 0 and 63
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetM(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM3) >>  RCC_PLLCKSELR_DIVM3_Pos);
 8004220:	4b54      	ldr	r3, [pc, #336]	@ (8004374 <LL_RCC_GetPLL3ClockFreq+0x170>)
 8004222:	e9c0 2200 	strd	r2, r2, [r0]
  PLL_Clocks->PLL_R_Frequency = 0U;
 8004226:	6082      	str	r2, [r0, #8]
 8004228:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
  return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_N3) >>  RCC_PLL3DIVR_N3_Pos) + 1UL);
 800422a:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL3FRACEN) == RCC_PLLCFGR_PLL3FRACEN) ? 1UL : 0UL);
 800422c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800422e:	05d2      	lsls	r2, r2, #23
 8004230:	d406      	bmi.n	8004240 <LL_RCC_GetPLL3ClockFreq+0x3c>
 8004232:	4770      	bx	lr
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 8004234:	6813      	ldr	r3, [r2, #0]
 8004236:	039a      	lsls	r2, r3, #14
 8004238:	d5f1      	bpl.n	800421e <LL_RCC_GetPLL3ClockFreq+0x1a>
        pllinputfreq = HSE_VALUE;
 800423a:	ed9f 6a4f 	vldr	s12, [pc, #316]	@ 8004378 <LL_RCC_GetPLL3ClockFreq+0x174>
 800423e:	e006      	b.n	800424e <LL_RCC_GetPLL3ClockFreq+0x4a>
  * @rmtoll PLL3FRACR      FRACN3          LL_RCC_PLL3_GetFRACN
  * @retval A value between 0 and 8191 (0x1FFF)
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetFRACN(void)
{
  return (uint32_t)(READ_BIT(RCC->PLL3FRACR, RCC_PLL3FRACR_FRACN3) >>  RCC_PLL3FRACR_FRACN3_Pos);
 8004240:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
  if ((m != 0U) && (pllinputfreq != 0U))
 8004242:	4770      	bx	lr
  return ((READ_BIT(RCC->CR, RCC_CR_CSIRDY) == (RCC_CR_CSIRDY)) ? 1UL : 0UL);
 8004244:	6813      	ldr	r3, [r2, #0]
 8004246:	05d9      	lsls	r1, r3, #23
 8004248:	d5e9      	bpl.n	800421e <LL_RCC_GetPLL3ClockFreq+0x1a>
        pllinputfreq = CSI_VALUE;
 800424a:	ed9f 6a4c 	vldr	s12, [pc, #304]	@ 800437c <LL_RCC_GetPLL3ClockFreq+0x178>
  PLL_Clocks->PLL_P_Frequency = 0U;
 800424e:	2300      	movs	r3, #0
{
 8004250:	b410      	push	{r4}
  return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM3) >>  RCC_PLLCKSELR_DIVM3_Pos);
 8004252:	4c48      	ldr	r4, [pc, #288]	@ (8004374 <LL_RCC_GetPLL3ClockFreq+0x170>)
  PLL_Clocks->PLL_R_Frequency = 0U;
 8004254:	6083      	str	r3, [r0, #8]
  PLL_Clocks->PLL_P_Frequency = 0U;
 8004256:	e9c0 3300 	strd	r3, r3, [r0]
 800425a:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
  return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_N3) >>  RCC_PLL3DIVR_N3_Pos) + 1UL);
 800425c:	6c21      	ldr	r1, [r4, #64]	@ 0x40
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL3FRACEN) == RCC_PLLCFGR_PLL3FRACEN) ? 1UL : 0UL);
 800425e:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
  return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM3) >>  RCC_PLLCKSELR_DIVM3_Pos);
 8004260:	f3c2 5205 	ubfx	r2, r2, #20, #6
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL3FRACEN) == RCC_PLLCFGR_PLL3FRACEN) ? 1UL : 0UL);
 8004264:	f413 7380 	ands.w	r3, r3, #256	@ 0x100
 8004268:	ee07 3a10 	vmov	s14, r3
 800426c:	d004      	beq.n	8004278 <LL_RCC_GetPLL3ClockFreq+0x74>
  return (uint32_t)(READ_BIT(RCC->PLL3FRACR, RCC_PLL3FRACR_FRACN3) >>  RCC_PLL3FRACR_FRACN3_Pos);
 800426e:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8004270:	f3c3 03cc 	ubfx	r3, r3, #3, #13
 8004274:	ee07 3a10 	vmov	s14, r3
  if ((m != 0U) && (pllinputfreq != 0U))
 8004278:	2a00      	cmp	r2, #0
 800427a:	d070      	beq.n	800435e <LL_RCC_GetPLL3ClockFreq+0x15a>
  return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_N3) >>  RCC_PLL3DIVR_N3_Pos) + 1UL);
 800427c:	f3c1 0308 	ubfx	r3, r1, #0, #9
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP3EN) == RCC_PLLCFGR_DIVP3EN) ? 1UL : 0UL);
 8004280:	4c3c      	ldr	r4, [pc, #240]	@ (8004374 <LL_RCC_GetPLL3ClockFreq+0x170>)
  return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_N3) >>  RCC_PLL3DIVR_N3_Pos) + 1UL);
 8004282:	3301      	adds	r3, #1
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP3EN) == RCC_PLLCFGR_DIVP3EN) ? 1UL : 0UL);
 8004284:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
  return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_N3) >>  RCC_PLL3DIVR_N3_Pos) + 1UL);
 8004286:	ee07 3a90 	vmov	s15, r3
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP3EN) == RCC_PLLCFGR_DIVP3EN) ? 1UL : 0UL);
 800428a:	024b      	lsls	r3, r1, #9
 800428c:	d51f      	bpl.n	80042ce <LL_RCC_GetPLL3ClockFreq+0xca>
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 800428e:	ee06 2a90 	vmov	s13, r2
 8004292:	eef8 4ac6 	vcvt.f32.s32	s9, s12
 8004296:	eef8 3ac7 	vcvt.f32.s32	s7, s14
  return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_P3) >>  RCC_PLL3DIVR_P3_Pos) + 1UL);
 800429a:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 800429c:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 80042a0:	ed9f 4a37 	vldr	s8, [pc, #220]	@ 8004380 <LL_RCC_GetPLL3ClockFreq+0x17c>
 80042a4:	eef8 5ae7 	vcvt.f32.s32	s11, s15
 80042a8:	f3c3 2346 	ubfx	r3, r3, #9, #7
 80042ac:	ee84 5aa6 	vdiv.f32	s10, s9, s13
 80042b0:	3301      	adds	r3, #1
  freq = freq / (float_t)PQR;
 80042b2:	ee06 3a90 	vmov	s13, r3
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 80042b6:	eee3 5a84 	vfma.f32	s11, s7, s8
  freq = freq / (float_t)PQR;
 80042ba:	eef8 6ae6 	vcvt.f32.s32	s13, s13
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 80042be:	ee25 5a25 	vmul.f32	s10, s10, s11
  freq = freq / (float_t)PQR;
 80042c2:	eec5 5a26 	vdiv.f32	s11, s10, s13
  return (uint32_t)freq;
 80042c6:	eefc 5ae5 	vcvt.u32.f32	s11, s11
 80042ca:	edc0 5a00 	vstr	s11, [r0]
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ3EN) == RCC_PLLCFGR_DIVQ3EN) ? 1UL : 0UL);
 80042ce:	4b29      	ldr	r3, [pc, #164]	@ (8004374 <LL_RCC_GetPLL3ClockFreq+0x170>)
 80042d0:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 80042d2:	020c      	lsls	r4, r1, #8
 80042d4:	d51f      	bpl.n	8004316 <LL_RCC_GetPLL3ClockFreq+0x112>
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 80042d6:	ee06 2a90 	vmov	s13, r2
 80042da:	eef8 4ac6 	vcvt.f32.s32	s9, s12
 80042de:	eef8 3ac7 	vcvt.f32.s32	s7, s14
  return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_Q3) >>  RCC_PLL3DIVR_Q3_Pos) + 1UL);
 80042e2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80042e4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 80042e8:	ed9f 4a25 	vldr	s8, [pc, #148]	@ 8004380 <LL_RCC_GetPLL3ClockFreq+0x17c>
 80042ec:	eef8 5ae7 	vcvt.f32.s32	s11, s15
 80042f0:	f3c3 4306 	ubfx	r3, r3, #16, #7
 80042f4:	ee84 5aa6 	vdiv.f32	s10, s9, s13
 80042f8:	3301      	adds	r3, #1
  freq = freq / (float_t)PQR;
 80042fa:	ee06 3a90 	vmov	s13, r3
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 80042fe:	eee3 5a84 	vfma.f32	s11, s7, s8
  freq = freq / (float_t)PQR;
 8004302:	eef8 6ae6 	vcvt.f32.s32	s13, s13
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 8004306:	ee25 5a25 	vmul.f32	s10, s10, s11
  freq = freq / (float_t)PQR;
 800430a:	eec5 5a26 	vdiv.f32	s11, s10, s13
  return (uint32_t)freq;
 800430e:	eefc 5ae5 	vcvt.u32.f32	s11, s11
 8004312:	edc0 5a01 	vstr	s11, [r0, #4]
  return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR3EN) == RCC_PLLCFGR_DIVR3EN) ? 1UL : 0UL);
 8004316:	4b17      	ldr	r3, [pc, #92]	@ (8004374 <LL_RCC_GetPLL3ClockFreq+0x170>)
 8004318:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 800431a:	01c9      	lsls	r1, r1, #7
 800431c:	d51f      	bpl.n	800435e <LL_RCC_GetPLL3ClockFreq+0x15a>
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 800431e:	ee06 2a90 	vmov	s13, r2
 8004322:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
 8004326:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  return (uint32_t)((READ_BIT(RCC->PLL3DIVR, RCC_PLL3DIVR_R3) >>  RCC_PLL3DIVR_R3_Pos) + 1UL);
 800432a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800432c:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8004330:	ed9f 5a13 	vldr	s10, [pc, #76]	@ 8004380 <LL_RCC_GetPLL3ClockFreq+0x17c>
 8004334:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004338:	f3c3 6306 	ubfx	r3, r3, #24, #7
 800433c:	eec6 5a26 	vdiv.f32	s11, s12, s13
 8004340:	3301      	adds	r3, #1
 8004342:	eee7 7a05 	vfma.f32	s15, s14, s10
  freq = freq / (float_t)PQR;
 8004346:	ee07 3a10 	vmov	s14, r3
 800434a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 800434e:	ee65 6aa7 	vmul.f32	s13, s11, s15
  freq = freq / (float_t)PQR;
 8004352:	eec6 7a87 	vdiv.f32	s15, s13, s14
  return (uint32_t)freq;
 8004356:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800435a:	edc0 7a02 	vstr	s15, [r0, #8]
}
 800435e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004362:	4770      	bx	lr
  return (READ_BIT(RCC->CR, RCC_CR_HSIDIV));
 8004364:	6812      	ldr	r2, [r2, #0]
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_CR_HSIDIV_Pos);
 8004366:	4b07      	ldr	r3, [pc, #28]	@ (8004384 <LL_RCC_GetPLL3ClockFreq+0x180>)
 8004368:	f3c2 02c1 	ubfx	r2, r2, #3, #2
 800436c:	40d3      	lsrs	r3, r2
 800436e:	ee06 3a10 	vmov	s12, r3
 8004372:	e76c      	b.n	800424e <LL_RCC_GetPLL3ClockFreq+0x4a>
 8004374:	58024400 	.word	0x58024400
 8004378:	017d7840 	.word	0x017d7840
 800437c:	003d0900 	.word	0x003d0900
 8004380:	39000000 	.word	0x39000000
 8004384:	03d09000 	.word	0x03d09000

08004388 <LL_RCC_GetUSARTClockFreq>:
  return (uint32_t)(Periph | (((READ_BIT(*pReg, LL_CLKSOURCE_MASK(Periph))) >> LL_CLKSOURCE_SHIFT(Periph)) << LL_RCC_CONFIG_SHIFT));
 8004388:	4a4b      	ldr	r2, [pc, #300]	@ (80044b8 <LL_RCC_GetUSARTClockFreq+0x130>)
 800438a:	f3c0 2104 	ubfx	r1, r0, #8, #5
 800438e:	0e03      	lsrs	r3, r0, #24
 8004390:	fa52 f280 	uxtab	r2, r2, r0
 8004394:	408b      	lsls	r3, r1
 8004396:	f8d2 244c 	ldr.w	r2, [r2, #1100]	@ 0x44c
 800439a:	4013      	ands	r3, r2
 800439c:	40cb      	lsrs	r3, r1
{
 800439e:	b510      	push	{r4, lr}
 80043a0:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
 80043a4:	4c45      	ldr	r4, [pc, #276]	@ (80044bc <LL_RCC_GetUSARTClockFreq+0x134>)
{
 80043a6:	b084      	sub	sp, #16
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
 80043a8:	42a0      	cmp	r0, r4
 80043aa:	d07b      	beq.n	80044a4 <LL_RCC_GetUSARTClockFreq+0x11c>
 80043ac:	d818      	bhi.n	80043e0 <LL_RCC_GetUSARTClockFreq+0x58>
 80043ae:	4b44      	ldr	r3, [pc, #272]	@ (80044c0 <LL_RCC_GetUSARTClockFreq+0x138>)
 80043b0:	4298      	cmp	r0, r3
 80043b2:	d067      	beq.n	8004484 <LL_RCC_GetUSARTClockFreq+0xfc>
 80043b4:	d93e      	bls.n	8004434 <LL_RCC_GetUSARTClockFreq+0xac>
 80043b6:	4b43      	ldr	r3, [pc, #268]	@ (80044c4 <LL_RCC_GetUSARTClockFreq+0x13c>)
 80043b8:	4298      	cmp	r0, r3
 80043ba:	d007      	beq.n	80043cc <LL_RCC_GetUSARTClockFreq+0x44>
 80043bc:	f503 437d 	add.w	r3, r3, #64768	@ 0xfd00
 80043c0:	4298      	cmp	r0, r3
 80043c2:	d06f      	beq.n	80044a4 <LL_RCC_GetUSARTClockFreq+0x11c>
 80043c4:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
 80043c8:	4298      	cmp	r0, r3
 80043ca:	d168      	bne.n	800449e <LL_RCC_GetUSARTClockFreq+0x116>
  return ((READ_BIT(RCC->CR, RCC_CR_PLL2RDY) == (RCC_CR_PLL2RDY)) ? 1UL : 0UL);
 80043cc:	4b3e      	ldr	r3, [pc, #248]	@ (80044c8 <LL_RCC_GetUSARTClockFreq+0x140>)
 80043ce:	6818      	ldr	r0, [r3, #0]
 80043d0:	f010 6000 	ands.w	r0, r0, #134217728	@ 0x8000000
 80043d4:	d01e      	beq.n	8004414 <LL_RCC_GetUSARTClockFreq+0x8c>
        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);
 80043d6:	a801      	add	r0, sp, #4
 80043d8:	f7ff fe4c 	bl	8004074 <LL_RCC_GetPLL2ClockFreq>
        usart_frequency = PLL_Clocks.PLL_Q_Frequency;
 80043dc:	9802      	ldr	r0, [sp, #8]
 80043de:	e019      	b.n	8004414 <LL_RCC_GetUSARTClockFreq+0x8c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
 80043e0:	4b3a      	ldr	r3, [pc, #232]	@ (80044cc <LL_RCC_GetUSARTClockFreq+0x144>)
 80043e2:	4298      	cmp	r0, r3
 80043e4:	d045      	beq.n	8004472 <LL_RCC_GetUSARTClockFreq+0xea>
 80043e6:	d817      	bhi.n	8004418 <LL_RCC_GetUSARTClockFreq+0x90>
 80043e8:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
 80043ec:	4298      	cmp	r0, r3
 80043ee:	d007      	beq.n	8004400 <LL_RCC_GetUSARTClockFreq+0x78>
 80043f0:	f503 437d 	add.w	r3, r3, #64768	@ 0xfd00
 80043f4:	4298      	cmp	r0, r3
 80043f6:	d03c      	beq.n	8004472 <LL_RCC_GetUSARTClockFreq+0xea>
 80043f8:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
 80043fc:	4298      	cmp	r0, r3
 80043fe:	d14e      	bne.n	800449e <LL_RCC_GetUSARTClockFreq+0x116>
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8004400:	4b31      	ldr	r3, [pc, #196]	@ (80044c8 <LL_RCC_GetUSARTClockFreq+0x140>)
 8004402:	6818      	ldr	r0, [r3, #0]
 8004404:	f010 0004 	ands.w	r0, r0, #4
 8004408:	d004      	beq.n	8004414 <LL_RCC_GetUSARTClockFreq+0x8c>
  return (READ_BIT(RCC->CR, RCC_CR_HSIDIV));
 800440a:	681b      	ldr	r3, [r3, #0]
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_CR_HSIDIV_Pos);
 800440c:	4830      	ldr	r0, [pc, #192]	@ (80044d0 <LL_RCC_GetUSARTClockFreq+0x148>)
 800440e:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 8004412:	40d8      	lsrs	r0, r3
}
 8004414:	b004      	add	sp, #16
 8004416:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
 8004418:	4b2e      	ldr	r3, [pc, #184]	@ (80044d4 <LL_RCC_GetUSARTClockFreq+0x14c>)
 800441a:	4298      	cmp	r0, r3
 800441c:	d003      	beq.n	8004426 <LL_RCC_GetUSARTClockFreq+0x9e>
 800441e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8004422:	4298      	cmp	r0, r3
 8004424:	d13b      	bne.n	800449e <LL_RCC_GetUSARTClockFreq+0x116>
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8004426:	4b28      	ldr	r3, [pc, #160]	@ (80044c8 <LL_RCC_GetUSARTClockFreq+0x140>)
 8004428:	6f18      	ldr	r0, [r3, #112]	@ 0x70
 800442a:	f3c0 0040 	ubfx	r0, r0, #1, #1
 800442e:	03c0      	lsls	r0, r0, #15
}
 8004430:	b004      	add	sp, #16
 8004432:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
 8004434:	f5a3 7340 	sub.w	r3, r3, #768	@ 0x300
 8004438:	4298      	cmp	r0, r3
 800443a:	d130      	bne.n	800449e <LL_RCC_GetUSARTClockFreq+0x116>
      usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(), LL_RCC_GetSysPrescaler())));
 800443c:	f7ff fde6 	bl	800400c <RCC_GetSystemClockFreq>
  return (uint32_t)(READ_BIT(RCC->D1CFGR, RCC_D1CFGR_D1CPRE));
 8004440:	4b21      	ldr	r3, [pc, #132]	@ (80044c8 <LL_RCC_GetUSARTClockFreq+0x140>)
 8004442:	6999      	ldr	r1, [r3, #24]
  return (uint32_t)(READ_BIT(RCC->D1CFGR, RCC_D1CFGR_HPRE));
 8004444:	699a      	ldr	r2, [r3, #24]
  return (uint32_t)(READ_BIT(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1));
 8004446:	69db      	ldr	r3, [r3, #28]
 8004448:	f3c1 2103 	ubfx	r1, r1, #8, #4
  return (uint32_t)(READ_BIT(RCC->D1CFGR, RCC_D1CFGR_HPRE));
 800444c:	f002 020f 	and.w	r2, r2, #15
  * @retval PCLK1 clock frequency (in Hz)
  */
static uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
{
  /* PCLK1 clock frequency */
  return LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
 8004450:	f3c3 1302 	ubfx	r3, r3, #4, #3
      usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(), LL_RCC_GetSysPrescaler())));
 8004454:	4c20      	ldr	r4, [pc, #128]	@ (80044d8 <LL_RCC_GetUSARTClockFreq+0x150>)
 8004456:	5c61      	ldrb	r1, [r4, r1]
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
 8004458:	5ca2      	ldrb	r2, [r4, r2]
      usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(), LL_RCC_GetSysPrescaler())));
 800445a:	f001 011f 	and.w	r1, r1, #31
  return LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
 800445e:	5ce3      	ldrb	r3, [r4, r3]
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
 8004460:	f002 021f 	and.w	r2, r2, #31
      usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(), LL_RCC_GetSysPrescaler())));
 8004464:	40c8      	lsrs	r0, r1
  return LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
 8004466:	f003 031f 	and.w	r3, r3, #31
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
 800446a:	40d0      	lsrs	r0, r2
  return LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
 800446c:	40d8      	lsrs	r0, r3
}
 800446e:	b004      	add	sp, #16
 8004470:	bd10      	pop	{r4, pc}
  return ((READ_BIT(RCC->CR, RCC_CR_CSIRDY) == (RCC_CR_CSIRDY)) ? 1UL : 0UL);
 8004472:	4b15      	ldr	r3, [pc, #84]	@ (80044c8 <LL_RCC_GetUSARTClockFreq+0x140>)
  uint32_t usart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
 8004474:	4819      	ldr	r0, [pc, #100]	@ (80044dc <LL_RCC_GetUSARTClockFreq+0x154>)
 8004476:	681b      	ldr	r3, [r3, #0]
 8004478:	f413 7f80 	tst.w	r3, #256	@ 0x100
 800447c:	bf08      	it	eq
 800447e:	2000      	moveq	r0, #0
}
 8004480:	b004      	add	sp, #16
 8004482:	bd10      	pop	{r4, pc}
      usart_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(), LL_RCC_GetSysPrescaler())));
 8004484:	f7ff fdc2 	bl	800400c <RCC_GetSystemClockFreq>
  return (uint32_t)(READ_BIT(RCC->D1CFGR, RCC_D1CFGR_D1CPRE));
 8004488:	4b0f      	ldr	r3, [pc, #60]	@ (80044c8 <LL_RCC_GetUSARTClockFreq+0x140>)
 800448a:	6999      	ldr	r1, [r3, #24]
  return (uint32_t)(READ_BIT(RCC->D1CFGR, RCC_D1CFGR_HPRE));
 800448c:	699a      	ldr	r2, [r3, #24]
  return (uint32_t)(READ_BIT(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2));
 800448e:	69db      	ldr	r3, [r3, #28]
 8004490:	f3c1 2103 	ubfx	r1, r1, #8, #4
  return (uint32_t)(READ_BIT(RCC->D1CFGR, RCC_D1CFGR_HPRE));
 8004494:	f002 020f 	and.w	r2, r2, #15
  * @retval PCLK2 clock frequency (in Hz)
  */
static uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
{
  /* PCLK2 clock frequency */
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
 8004498:	f3c3 2302 	ubfx	r3, r3, #8, #3
 800449c:	e7da      	b.n	8004454 <LL_RCC_GetUSARTClockFreq+0xcc>
  uint32_t usart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
 800449e:	2000      	movs	r0, #0
}
 80044a0:	b004      	add	sp, #16
 80044a2:	bd10      	pop	{r4, pc}
  return ((READ_BIT(RCC->CR, RCC_CR_PLL3RDY) == (RCC_CR_PLL3RDY)) ? 1UL : 0UL);
 80044a4:	4b08      	ldr	r3, [pc, #32]	@ (80044c8 <LL_RCC_GetUSARTClockFreq+0x140>)
 80044a6:	6818      	ldr	r0, [r3, #0]
 80044a8:	f010 5000 	ands.w	r0, r0, #536870912	@ 0x20000000
 80044ac:	d0b2      	beq.n	8004414 <LL_RCC_GetUSARTClockFreq+0x8c>
        LL_RCC_GetPLL3ClockFreq(&PLL_Clocks);
 80044ae:	a801      	add	r0, sp, #4
 80044b0:	f7ff fea8 	bl	8004204 <LL_RCC_GetPLL3ClockFreq>
        usart_frequency = PLL_Clocks.PLL_Q_Frequency;
 80044b4:	9802      	ldr	r0, [sp, #8]
 80044b6:	e7ad      	b.n	8004414 <LL_RCC_GetUSARTClockFreq+0x8c>
 80044b8:	58024000 	.word	0x58024000
 80044bc:	07020308 	.word	0x07020308
 80044c0:	07000308 	.word	0x07000308
 80044c4:	07010308 	.word	0x07010308
 80044c8:	58024400 	.word	0x58024400
 80044cc:	07040308 	.word	0x07040308
 80044d0:	03d09000 	.word	0x03d09000
 80044d4:	07050008 	.word	0x07050008
 80044d8:	08008748 	.word	0x08008748
 80044dc:	003d0900 	.word	0x003d0900

080044e0 <LL_SPI_Init>:
  return ((READ_BIT(SPIx->CR1, SPI_CR1_SPE) == (SPI_CR1_SPE)) ? 1UL : 0UL);
 80044e0:	6802      	ldr	r2, [r0, #0]
 80044e2:	07d3      	lsls	r3, r2, #31
 80044e4:	d43a      	bmi.n	800455c <LL_SPI_Init+0x7c>
       * Configure SPIx CFG1 with parameters:
       * - Master Baud Rate       : SPI_CFG1_MBR[2:0] bits
       * - CRC Computation Enable : SPI_CFG1_CRCEN bit
       * - Length of data frame   : SPI_CFG1_DSIZE[4:0] bits
       */
    MODIFY_REG(SPIx->CFG1, SPI_CFG1_MBR | SPI_CFG1_CRCEN | SPI_CFG1_DSIZE,
 80044e6:	698a      	ldr	r2, [r1, #24]
 80044e8:	4603      	mov	r3, r0
{
 80044ea:	b470      	push	{r4, r5, r6}
    MODIFY_REG(SPIx->CFG1, SPI_CFG1_MBR | SPI_CFG1_CRCEN | SPI_CFG1_DSIZE,
 80044ec:	6a0c      	ldr	r4, [r1, #32]
 80044ee:	6885      	ldr	r5, [r0, #8]
 80044f0:	ea44 0002 	orr.w	r0, r4, r2
 80044f4:	688a      	ldr	r2, [r1, #8]
 80044f6:	4310      	orrs	r0, r2
 80044f8:	4a23      	ldr	r2, [pc, #140]	@ (8004588 <LL_SPI_Init+0xa8>)
 80044fa:	402a      	ands	r2, r5
 80044fc:	4310      	orrs	r0, r2
               SPI_InitStruct->BaudRate  | SPI_InitStruct->CRCCalculation | SPI_InitStruct->DataWidth);

    tmp_nss  = SPI_InitStruct->NSS;
 80044fe:	694a      	ldr	r2, [r1, #20]
    tmp_mode = SPI_InitStruct->Mode;
    tmp_nss_polarity = LL_SPI_GetNSSPolarity(SPIx);

    /* Checks to setup Internal SS signal level and avoid a MODF Error */
    if ((tmp_nss == LL_SPI_NSS_SOFT) && (((tmp_nss_polarity == LL_SPI_NSS_POLARITY_LOW)  && \
 8004500:	f1b2 6f80 	cmp.w	r2, #67108864	@ 0x4000000
    MODIFY_REG(SPIx->CFG1, SPI_CFG1_MBR | SPI_CFG1_CRCEN | SPI_CFG1_DSIZE,
 8004504:	6098      	str	r0, [r3, #8]
    tmp_mode = SPI_InitStruct->Mode;
 8004506:	6848      	ldr	r0, [r1, #4]
  return (uint32_t)(READ_BIT(SPIx->CFG2, SPI_CFG2_SSIOP));
 8004508:	68dd      	ldr	r5, [r3, #12]
    if ((tmp_nss == LL_SPI_NSS_SOFT) && (((tmp_nss_polarity == LL_SPI_NSS_POLARITY_LOW)  && \
 800450a:	d02c      	beq.n	8004566 <LL_SPI_Init+0x86>
       * - ClockPhase             : SPI_CFG2_CPHA bit
       * - BitOrder               : SPI_CFG2_LSBFRST bit
       * - Master/Slave Mode      : SPI_CFG2_MASTER bit
       * - SPI Mode               : SPI_CFG2_COMM[1:0] bits
       */
    MODIFY_REG(SPIx->CFG2, SPI_CFG2_SSM   | SPI_CFG2_SSOE    |
 800450c:	4302      	orrs	r2, r0
 800450e:	68c8      	ldr	r0, [r1, #12]
 8004510:	68de      	ldr	r6, [r3, #12]

    /*---------------------------- SPIx CRCPOLY Configuration ----------------------
       * Configure SPIx CRCPOLY with parameter:
       * - CRCPoly                : CRCPOLY[31:0] bits
       */
    if (SPI_InitStruct->CRCCalculation == LL_SPI_CRCCALCULATION_ENABLE)
 8004512:	f5b4 0f80 	cmp.w	r4, #4194304	@ 0x400000
    MODIFY_REG(SPIx->CFG2, SPI_CFG2_SSM   | SPI_CFG2_SSOE    |
 8004516:	ea42 0200 	orr.w	r2, r2, r0
 800451a:	6908      	ldr	r0, [r1, #16]
 800451c:	4d1b      	ldr	r5, [pc, #108]	@ (800458c <LL_SPI_Init+0xac>)
 800451e:	ea42 0200 	orr.w	r2, r2, r0
 8004522:	69c8      	ldr	r0, [r1, #28]
 8004524:	ea05 0506 	and.w	r5, r5, r6
 8004528:	ea42 0200 	orr.w	r2, r2, r0
 800452c:	6808      	ldr	r0, [r1, #0]
 800452e:	f400 2cc0 	and.w	ip, r0, #393216	@ 0x60000
    MODIFY_REG(SPIx->CR1, SPI_CR1_HDDIR, SPI_InitStruct->TransferDirection & SPI_CR1_HDDIR);
 8004532:	f400 6000 	and.w	r0, r0, #2048	@ 0x800
    MODIFY_REG(SPIx->CFG2, SPI_CFG2_SSM   | SPI_CFG2_SSOE    |
 8004536:	ea42 020c 	orr.w	r2, r2, ip
 800453a:	ea42 0205 	orr.w	r2, r2, r5
 800453e:	60da      	str	r2, [r3, #12]
    MODIFY_REG(SPIx->CR1, SPI_CR1_HDDIR, SPI_InitStruct->TransferDirection & SPI_CR1_HDDIR);
 8004540:	681a      	ldr	r2, [r3, #0]
 8004542:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 8004546:	ea42 0200 	orr.w	r2, r2, r0
 800454a:	601a      	str	r2, [r3, #0]
    if (SPI_InitStruct->CRCCalculation == LL_SPI_CRCCALCULATION_ENABLE)
 800454c:	d008      	beq.n	8004560 <LL_SPI_Init+0x80>
      assert_param(IS_LL_SPI_CRC_POLYNOMIAL(SPI_InitStruct->CRCPoly));
      LL_SPI_SetCRCPolynomial(SPIx, SPI_InitStruct->CRCPoly);
    }

    /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    CLEAR_BIT(SPIx->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 800454e:	6d1a      	ldr	r2, [r3, #80]	@ 0x50

    status = SUCCESS;
 8004550:	2000      	movs	r0, #0
    CLEAR_BIT(SPIx->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8004552:	f022 0201 	bic.w	r2, r2, #1
  }

  return status;
}
 8004556:	bc70      	pop	{r4, r5, r6}
    CLEAR_BIT(SPIx->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8004558:	651a      	str	r2, [r3, #80]	@ 0x50
}
 800455a:	4770      	bx	lr
  ErrorStatus status = ERROR;
 800455c:	2001      	movs	r0, #1
}
 800455e:	4770      	bx	lr
      LL_SPI_SetCRCPolynomial(SPIx, SPI_InitStruct->CRCPoly);
 8004560:	6a4a      	ldr	r2, [r1, #36]	@ 0x24
  * @param  CRCPoly 0..0xFFFFFFFF
  * @retval None
  */
__STATIC_INLINE void LL_SPI_SetCRCPolynomial(SPI_TypeDef *SPIx, uint32_t CRCPoly)
{
  WRITE_REG(SPIx->CRCPOLY, CRCPoly);
 8004562:	641a      	str	r2, [r3, #64]	@ 0x40
}
 8004564:	e7f3      	b.n	800454e <LL_SPI_Init+0x6e>
    if ((tmp_nss == LL_SPI_NSS_SOFT) && (((tmp_nss_polarity == LL_SPI_NSS_POLARITY_LOW)  && \
 8004566:	f015 5580 	ands.w	r5, r5, #268435456	@ 0x10000000
 800456a:	d107      	bne.n	800457c <LL_SPI_Init+0x9c>
 800456c:	f5b0 0f80 	cmp.w	r0, #4194304	@ 0x400000
 8004570:	d104      	bne.n	800457c <LL_SPI_Init+0x9c>
  MODIFY_REG(SPIx->CR1, SPI_CR1_SSI, SSLevel);
 8004572:	681d      	ldr	r5, [r3, #0]
 8004574:	f445 5580 	orr.w	r5, r5, #4096	@ 0x1000
 8004578:	601d      	str	r5, [r3, #0]
}
 800457a:	e7c7      	b.n	800450c <LL_SPI_Init+0x2c>
                                          (tmp_mode == LL_SPI_MODE_MASTER))              || \
 800457c:	2d00      	cmp	r5, #0
 800457e:	d0c5      	beq.n	800450c <LL_SPI_Init+0x2c>
 8004580:	2800      	cmp	r0, #0
 8004582:	d0f6      	beq.n	8004572 <LL_SPI_Init+0x92>
 8004584:	e7c2      	b.n	800450c <LL_SPI_Init+0x2c>
 8004586:	bf00      	nop
 8004588:	8fbfffe0 	.word	0x8fbfffe0
 800458c:	d839ffff 	.word	0xd839ffff

08004590 <LL_USART_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: USART registers are initialized according to USART_InitStruct content
  *          - ERROR: Problem occurred during USART Registers initialization
  */
ErrorStatus LL_USART_Init(USART_TypeDef *USARTx, const LL_USART_InitTypeDef *USART_InitStruct)
{
 8004590:	b538      	push	{r3, r4, r5, lr}
  return ((READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE)) ? 1UL : 0UL);
 8004592:	6803      	ldr	r3, [r0, #0]
 8004594:	07db      	lsls	r3, r3, #31
 8004596:	d43b      	bmi.n	8004610 <LL_USART_Init+0x80>
     * - DataWidth:          USART_CR1_M bits according to USART_InitStruct->DataWidth value
     * - Parity:             USART_CR1_PCE, USART_CR1_PS bits according to USART_InitStruct->Parity value
     * - TransferDirection:  USART_CR1_TE, USART_CR1_RE bits according to USART_InitStruct->TransferDirection value
     * - Oversampling:       USART_CR1_OVER8 bit according to USART_InitStruct->OverSampling value.
     */
    MODIFY_REG(USARTx->CR1,
 8004598:	4604      	mov	r4, r0
 800459a:	688b      	ldr	r3, [r1, #8]
 800459c:	460d      	mov	r5, r1
 800459e:	e9d1 0204 	ldrd	r0, r2, [r1, #16]
 80045a2:	6821      	ldr	r1, [r4, #0]
 80045a4:	4303      	orrs	r3, r0
 80045a6:	4313      	orrs	r3, r2
 80045a8:	69ea      	ldr	r2, [r5, #28]
 80045aa:	4313      	orrs	r3, r2
 80045ac:	4a33      	ldr	r2, [pc, #204]	@ (800467c <LL_USART_Init+0xec>)
 80045ae:	400a      	ands	r2, r1
  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 80045b0:	68e9      	ldr	r1, [r5, #12]
 80045b2:	4313      	orrs	r3, r2
    LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);

    /*---------------------------- USART BRR Configuration ---------------------
     * Retrieve Clock frequency used for USART Peripheral
     */
    if (USARTx == USART1)
 80045b4:	4a32      	ldr	r2, [pc, #200]	@ (8004680 <LL_USART_Init+0xf0>)
    MODIFY_REG(USARTx->CR1,
 80045b6:	6023      	str	r3, [r4, #0]
    if (USARTx == USART1)
 80045b8:	4294      	cmp	r4, r2
 80045ba:	6863      	ldr	r3, [r4, #4]
 80045bc:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
 80045c0:	ea43 0301 	orr.w	r3, r3, r1
  MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 80045c4:	69a9      	ldr	r1, [r5, #24]
  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 80045c6:	6063      	str	r3, [r4, #4]
  MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 80045c8:	68a3      	ldr	r3, [r4, #8]
 80045ca:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 80045ce:	ea43 0301 	orr.w	r3, r3, r1
 80045d2:	60a3      	str	r3, [r4, #8]
 80045d4:	d041      	beq.n	800465a <LL_USART_Init+0xca>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART16_CLKSOURCE);
    }
    else if (USARTx == USART2)
 80045d6:	4b2b      	ldr	r3, [pc, #172]	@ (8004684 <LL_USART_Init+0xf4>)
 80045d8:	429c      	cmp	r4, r3
 80045da:	d01b      	beq.n	8004614 <LL_USART_Init+0x84>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);
    }
    else if (USARTx == USART3)
 80045dc:	4b2a      	ldr	r3, [pc, #168]	@ (8004688 <LL_USART_Init+0xf8>)
 80045de:	429c      	cmp	r4, r3
 80045e0:	d018      	beq.n	8004614 <LL_USART_Init+0x84>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);
    }
    else if (USARTx == UART4)
 80045e2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80045e6:	429c      	cmp	r4, r3
 80045e8:	d014      	beq.n	8004614 <LL_USART_Init+0x84>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);
    }
    else if (USARTx == UART5)
 80045ea:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80045ee:	429c      	cmp	r4, r3
 80045f0:	d010      	beq.n	8004614 <LL_USART_Init+0x84>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);
    }
    else if (USARTx == USART6)
 80045f2:	f503 4344 	add.w	r3, r3, #50176	@ 0xc400
 80045f6:	429c      	cmp	r4, r3
 80045f8:	d02f      	beq.n	800465a <LL_USART_Init+0xca>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART16_CLKSOURCE);
    }
    else if (USARTx == UART7)
 80045fa:	f5a3 431c 	sub.w	r3, r3, #39936	@ 0x9c00
 80045fe:	429c      	cmp	r4, r3
 8004600:	d008      	beq.n	8004614 <LL_USART_Init+0x84>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);
    }
    else if (USARTx == UART8)
 8004602:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8004606:	429c      	cmp	r4, r3
 8004608:	d004      	beq.n	8004614 <LL_USART_Init+0x84>

    /*---------------------------- USART PRESC Configuration -----------------------
     * Configure USARTx PRESC (Prescaler) with parameters:
     * - PrescalerValue: USART_PRESC_PRESCALER bits according to USART_InitStruct->PrescalerValue value.
     */
    LL_USART_SetPrescaler(USARTx, USART_InitStruct->PrescalerValue);
 800460a:	682a      	ldr	r2, [r5, #0]
  ErrorStatus status = ERROR;
 800460c:	2001      	movs	r0, #1
 800460e:	e01d      	b.n	800464c <LL_USART_Init+0xbc>
 8004610:	2001      	movs	r0, #1
  }
  /* Endif (=> USART not in Disabled state => return ERROR) */

  return (status);
}
 8004612:	bd38      	pop	{r3, r4, r5, pc}
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART234578_CLKSOURCE);
 8004614:	481d      	ldr	r0, [pc, #116]	@ (800468c <LL_USART_Init+0xfc>)
 8004616:	f7ff feb7 	bl	8004388 <LL_RCC_GetUSARTClockFreq>
                           USART_InitStruct->PrescalerValue,
 800461a:	682a      	ldr	r2, [r5, #0]
    if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)
 800461c:	b1a8      	cbz	r0, 800464a <LL_USART_Init+0xba>
        && (USART_InitStruct->BaudRate != 0U))
 800461e:	6869      	ldr	r1, [r5, #4]
 8004620:	b199      	cbz	r1, 800464a <LL_USART_Init+0xba>
  if (PrescalerValue > LL_USART_PRESCALER_DIV256)
 8004622:	2a0b      	cmp	r2, #11
 8004624:	d80f      	bhi.n	8004646 <LL_USART_Init+0xb6>
  else if (OverSampling == LL_USART_OVERSAMPLING_8)
 8004626:	69ed      	ldr	r5, [r5, #28]
    usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, (uint8_t)PrescalerValue, BaudRate));
 8004628:	4b19      	ldr	r3, [pc, #100]	@ (8004690 <LL_USART_Init+0x100>)
  else if (OverSampling == LL_USART_OVERSAMPLING_8)
 800462a:	f5b5 4f00 	cmp.w	r5, #32768	@ 0x8000
    usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, (uint8_t)PrescalerValue, BaudRate));
 800462e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8004632:	fbb0 f0f3 	udiv	r0, r0, r3
 8004636:	ea4f 0351 	mov.w	r3, r1, lsr #1
  else if (OverSampling == LL_USART_OVERSAMPLING_8)
 800463a:	d012      	beq.n	8004662 <LL_USART_Init+0xd2>
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, (uint8_t)PrescalerValue, BaudRate));
 800463c:	4403      	add	r3, r0
 800463e:	fbb3 f3f1 	udiv	r3, r3, r1
 8004642:	b29b      	uxth	r3, r3
 8004644:	60e3      	str	r3, [r4, #12]
      status = SUCCESS;
 8004646:	2000      	movs	r0, #0
 8004648:	e000      	b.n	800464c <LL_USART_Init+0xbc>
  ErrorStatus status = ERROR;
 800464a:	2001      	movs	r0, #1
  MODIFY_REG(USARTx->PRESC, USART_PRESC_PRESCALER, (uint16_t)PrescalerValue);
 800464c:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 800464e:	b292      	uxth	r2, r2
 8004650:	f023 030f 	bic.w	r3, r3, #15
 8004654:	4313      	orrs	r3, r2
 8004656:	62e3      	str	r3, [r4, #44]	@ 0x2c
}
 8004658:	bd38      	pop	{r3, r4, r5, pc}
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART16_CLKSOURCE);
 800465a:	480e      	ldr	r0, [pc, #56]	@ (8004694 <LL_USART_Init+0x104>)
 800465c:	f7ff fe94 	bl	8004388 <LL_RCC_GetUSARTClockFreq>
 8004660:	e7db      	b.n	800461a <LL_USART_Init+0x8a>
    usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, (uint8_t)PrescalerValue, BaudRate));
 8004662:	eb03 0340 	add.w	r3, r3, r0, lsl #1
    brrtemp = usartdiv & 0xFFF0U;
 8004666:	f64f 70f0 	movw	r0, #65520	@ 0xfff0
    usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, (uint8_t)PrescalerValue, BaudRate));
 800466a:	fbb3 f3f1 	udiv	r3, r3, r1
    brrtemp = usartdiv & 0xFFF0U;
 800466e:	ea03 0100 	and.w	r1, r3, r0
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8004672:	f3c3 0342 	ubfx	r3, r3, #1, #3
 8004676:	430b      	orrs	r3, r1
    USARTx->BRR = brrtemp;
 8004678:	60e3      	str	r3, [r4, #12]
 800467a:	e7e4      	b.n	8004646 <LL_USART_Init+0xb6>
 800467c:	efff69f3 	.word	0xefff69f3
 8004680:	40011000 	.word	0x40011000
 8004684:	40004400 	.word	0x40004400
 8004688:	40004800 	.word	0x40004800
 800468c:	07000008 	.word	0x07000008
 8004690:	08008758 	.word	0x08008758
 8004694:	07000308 	.word	0x07000308

08004698 <USB_SetTurnaroundTime>:

  /* The USBTRD is configured according to the tables below, depending on AHB frequency
  used by application. In the low AHB frequency range it is used to stretch enough the USB response
  time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
  latency to the Data FIFO */
  if (speed == USBD_FS_SPEED)
 8004698:	2a02      	cmp	r2, #2
{
 800469a:	4603      	mov	r3, r0
  if (speed == USBD_FS_SPEED)
 800469c:	d00a      	beq.n	80046b4 <USB_SetTurnaroundTime+0x1c>
 800469e:	f44f 5110 	mov.w	r1, #9216	@ 0x2400
  else
  {
    UsbTrd = USBD_DEFAULT_TRDT_VALUE;
  }

  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 80046a2:	68da      	ldr	r2, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);

  return HAL_OK;
}
 80046a4:	2000      	movs	r0, #0
  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 80046a6:	f422 5270 	bic.w	r2, r2, #15360	@ 0x3c00
 80046aa:	60da      	str	r2, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 80046ac:	68da      	ldr	r2, [r3, #12]
 80046ae:	430a      	orrs	r2, r1
 80046b0:	60da      	str	r2, [r3, #12]
}
 80046b2:	4770      	bx	lr
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 80046b4:	4a23      	ldr	r2, [pc, #140]	@ (8004744 <USB_SetTurnaroundTime+0xac>)
 80046b6:	4824      	ldr	r0, [pc, #144]	@ (8004748 <USB_SetTurnaroundTime+0xb0>)
 80046b8:	440a      	add	r2, r1
 80046ba:	4282      	cmp	r2, r0
 80046bc:	d92c      	bls.n	8004718 <USB_SetTurnaroundTime+0x80>
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 80046be:	4a23      	ldr	r2, [pc, #140]	@ (800474c <USB_SetTurnaroundTime+0xb4>)
 80046c0:	4823      	ldr	r0, [pc, #140]	@ (8004750 <USB_SetTurnaroundTime+0xb8>)
 80046c2:	440a      	add	r2, r1
 80046c4:	4282      	cmp	r2, r0
 80046c6:	d92a      	bls.n	800471e <USB_SetTurnaroundTime+0x86>
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 80046c8:	4a22      	ldr	r2, [pc, #136]	@ (8004754 <USB_SetTurnaroundTime+0xbc>)
 80046ca:	4823      	ldr	r0, [pc, #140]	@ (8004758 <USB_SetTurnaroundTime+0xc0>)
 80046cc:	440a      	add	r2, r1
 80046ce:	4282      	cmp	r2, r0
 80046d0:	d928      	bls.n	8004724 <USB_SetTurnaroundTime+0x8c>
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 80046d2:	4a22      	ldr	r2, [pc, #136]	@ (800475c <USB_SetTurnaroundTime+0xc4>)
 80046d4:	4822      	ldr	r0, [pc, #136]	@ (8004760 <USB_SetTurnaroundTime+0xc8>)
 80046d6:	440a      	add	r2, r1
 80046d8:	4282      	cmp	r2, r0
 80046da:	d326      	bcc.n	800472a <USB_SetTurnaroundTime+0x92>
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 80046dc:	4a21      	ldr	r2, [pc, #132]	@ (8004764 <USB_SetTurnaroundTime+0xcc>)
 80046de:	4822      	ldr	r0, [pc, #136]	@ (8004768 <USB_SetTurnaroundTime+0xd0>)
 80046e0:	440a      	add	r2, r1
 80046e2:	4282      	cmp	r2, r0
 80046e4:	d924      	bls.n	8004730 <USB_SetTurnaroundTime+0x98>
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 80046e6:	4a21      	ldr	r2, [pc, #132]	@ (800476c <USB_SetTurnaroundTime+0xd4>)
 80046e8:	4821      	ldr	r0, [pc, #132]	@ (8004770 <USB_SetTurnaroundTime+0xd8>)
 80046ea:	440a      	add	r2, r1
 80046ec:	4282      	cmp	r2, r0
 80046ee:	d322      	bcc.n	8004736 <USB_SetTurnaroundTime+0x9e>
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 80046f0:	4a20      	ldr	r2, [pc, #128]	@ (8004774 <USB_SetTurnaroundTime+0xdc>)
 80046f2:	4821      	ldr	r0, [pc, #132]	@ (8004778 <USB_SetTurnaroundTime+0xe0>)
 80046f4:	440a      	add	r2, r1
 80046f6:	4282      	cmp	r2, r0
 80046f8:	d3d1      	bcc.n	800469e <USB_SetTurnaroundTime+0x6>
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 80046fa:	4a20      	ldr	r2, [pc, #128]	@ (800477c <USB_SetTurnaroundTime+0xe4>)
 80046fc:	4820      	ldr	r0, [pc, #128]	@ (8004780 <USB_SetTurnaroundTime+0xe8>)
 80046fe:	440a      	add	r2, r1
 8004700:	4282      	cmp	r2, r0
 8004702:	d31b      	bcc.n	800473c <USB_SetTurnaroundTime+0xa4>
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 8004704:	4a1f      	ldr	r2, [pc, #124]	@ (8004784 <USB_SetTurnaroundTime+0xec>)
 8004706:	4820      	ldr	r0, [pc, #128]	@ (8004788 <USB_SetTurnaroundTime+0xf0>)
 8004708:	440a      	add	r2, r1
 800470a:	4282      	cmp	r2, r0
 800470c:	bf2c      	ite	cs
 800470e:	f44f 51c0 	movcs.w	r1, #6144	@ 0x1800
 8004712:	f44f 51e0 	movcc.w	r1, #7168	@ 0x1c00
 8004716:	e7c4      	b.n	80046a2 <USB_SetTurnaroundTime+0xa>
 8004718:	f44f 5170 	mov.w	r1, #15360	@ 0x3c00
 800471c:	e7c1      	b.n	80046a2 <USB_SetTurnaroundTime+0xa>
 800471e:	f44f 5160 	mov.w	r1, #14336	@ 0x3800
 8004722:	e7be      	b.n	80046a2 <USB_SetTurnaroundTime+0xa>
 8004724:	f44f 5150 	mov.w	r1, #13312	@ 0x3400
 8004728:	e7bb      	b.n	80046a2 <USB_SetTurnaroundTime+0xa>
 800472a:	f44f 5140 	mov.w	r1, #12288	@ 0x3000
 800472e:	e7b8      	b.n	80046a2 <USB_SetTurnaroundTime+0xa>
 8004730:	f44f 5130 	mov.w	r1, #11264	@ 0x2c00
 8004734:	e7b5      	b.n	80046a2 <USB_SetTurnaroundTime+0xa>
 8004736:	f44f 5120 	mov.w	r1, #10240	@ 0x2800
 800473a:	e7b2      	b.n	80046a2 <USB_SetTurnaroundTime+0xa>
 800473c:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 8004740:	e7af      	b.n	80046a2 <USB_SetTurnaroundTime+0xa>
 8004742:	bf00      	nop
 8004744:	ff275340 	.word	0xff275340
 8004748:	000c34ff 	.word	0x000c34ff
 800474c:	ff1b1e40 	.word	0xff1b1e40
 8004750:	000f423f 	.word	0x000f423f
 8004754:	ff0bdc00 	.word	0xff0bdc00
 8004758:	00124f7f 	.word	0x00124f7f
 800475c:	fef98c80 	.word	0xfef98c80
 8004760:	0013d620 	.word	0x0013d620
 8004764:	fee5b660 	.word	0xfee5b660
 8004768:	0016e35f 	.word	0x0016e35f
 800476c:	feced300 	.word	0xfeced300
 8004770:	001b7740 	.word	0x001b7740
 8004774:	feb35bc0 	.word	0xfeb35bc0
 8004778:	002191c0 	.word	0x002191c0
 800477c:	fe91ca00 	.word	0xfe91ca00
 8004780:	00387520 	.word	0x00387520
 8004784:	fe5954e0 	.word	0xfe5954e0
 8004788:	00419ce0 	.word	0x00419ce0

0800478c <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 800478c:	4603      	mov	r3, r0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
  return HAL_OK;
}
 800478e:	2000      	movs	r0, #0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8004790:	689a      	ldr	r2, [r3, #8]
 8004792:	f042 0201 	orr.w	r2, r2, #1
 8004796:	609a      	str	r2, [r3, #8]
}
 8004798:	4770      	bx	lr
 800479a:	bf00      	nop

0800479c <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
 800479c:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 800479e:	2300      	movs	r3, #0
 80047a0:	9301      	str	r3, [sp, #4]
 80047a2:	e002      	b.n	80047aa <USB_FlushTxFifo+0xe>

    if (count > HAL_USB_TIMEOUT)
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80047a4:	6903      	ldr	r3, [r0, #16]
 80047a6:	2b00      	cmp	r3, #0
 80047a8:	db09      	blt.n	80047be <USB_FlushTxFifo+0x22>
    count++;
 80047aa:	9b01      	ldr	r3, [sp, #4]
 80047ac:	3301      	adds	r3, #1
 80047ae:	9301      	str	r3, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 80047b0:	9b01      	ldr	r3, [sp, #4]
 80047b2:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 80047b6:	d9f5      	bls.n	80047a4 <USB_FlushTxFifo+0x8>
      return HAL_TIMEOUT;
 80047b8:	2003      	movs	r0, #3
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);

  return HAL_OK;
}
 80047ba:	b002      	add	sp, #8
 80047bc:	4770      	bx	lr
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 80047be:	0189      	lsls	r1, r1, #6
  count = 0U;
 80047c0:	2300      	movs	r3, #0
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 80047c2:	f041 0120 	orr.w	r1, r1, #32
  count = 0U;
 80047c6:	9301      	str	r3, [sp, #4]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 80047c8:	6101      	str	r1, [r0, #16]
 80047ca:	e003      	b.n	80047d4 <USB_FlushTxFifo+0x38>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 80047cc:	6903      	ldr	r3, [r0, #16]
 80047ce:	f013 0320 	ands.w	r3, r3, #32
 80047d2:	d007      	beq.n	80047e4 <USB_FlushTxFifo+0x48>
    count++;
 80047d4:	9b01      	ldr	r3, [sp, #4]
 80047d6:	3301      	adds	r3, #1
 80047d8:	9301      	str	r3, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 80047da:	9b01      	ldr	r3, [sp, #4]
 80047dc:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 80047e0:	d9f4      	bls.n	80047cc <USB_FlushTxFifo+0x30>
 80047e2:	e7e9      	b.n	80047b8 <USB_FlushTxFifo+0x1c>
  return HAL_OK;
 80047e4:	4618      	mov	r0, r3
}
 80047e6:	b002      	add	sp, #8
 80047e8:	4770      	bx	lr
 80047ea:	bf00      	nop

080047ec <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo  Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
 80047ec:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 80047ee:	2300      	movs	r3, #0
 80047f0:	9301      	str	r3, [sp, #4]
 80047f2:	e002      	b.n	80047fa <USB_FlushRxFifo+0xe>

    if (count > HAL_USB_TIMEOUT)
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80047f4:	6903      	ldr	r3, [r0, #16]
 80047f6:	2b00      	cmp	r3, #0
 80047f8:	db09      	blt.n	800480e <USB_FlushRxFifo+0x22>
    count++;
 80047fa:	9b01      	ldr	r3, [sp, #4]
 80047fc:	3301      	adds	r3, #1
 80047fe:	9301      	str	r3, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 8004800:	9b01      	ldr	r3, [sp, #4]
 8004802:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8004806:	d9f5      	bls.n	80047f4 <USB_FlushRxFifo+0x8>
      return HAL_TIMEOUT;
 8004808:	2003      	movs	r0, #3
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);

  return HAL_OK;
}
 800480a:	b002      	add	sp, #8
 800480c:	4770      	bx	lr
  count = 0U;
 800480e:	2200      	movs	r2, #0
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8004810:	2310      	movs	r3, #16
  count = 0U;
 8004812:	9201      	str	r2, [sp, #4]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8004814:	6103      	str	r3, [r0, #16]
 8004816:	e003      	b.n	8004820 <USB_FlushRxFifo+0x34>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8004818:	6903      	ldr	r3, [r0, #16]
 800481a:	f013 0310 	ands.w	r3, r3, #16
 800481e:	d007      	beq.n	8004830 <USB_FlushRxFifo+0x44>
    count++;
 8004820:	9b01      	ldr	r3, [sp, #4]
 8004822:	3301      	adds	r3, #1
 8004824:	9301      	str	r3, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 8004826:	9b01      	ldr	r3, [sp, #4]
 8004828:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 800482c:	d9f4      	bls.n	8004818 <USB_FlushRxFifo+0x2c>
 800482e:	e7eb      	b.n	8004808 <USB_FlushRxFifo+0x1c>
  return HAL_OK;
 8004830:	4618      	mov	r0, r3
}
 8004832:	b002      	add	sp, #8
 8004834:	4770      	bx	lr
 8004836:	bf00      	nop

08004838 <USB_GetDevSpeed>:
  */
uint8_t USB_GetDevSpeed(const USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint8_t speed;
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 8004838:	f8d0 3808 	ldr.w	r3, [r0, #2056]	@ 0x808

  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 800483c:	079a      	lsls	r2, r3, #30
 800483e:	d405      	bmi.n	800484c <USB_GetDevSpeed+0x14>
  {
    speed = USBD_FS_SPEED;
  }
  else
  {
    speed = 0xFU;
 8004840:	f013 0f06 	tst.w	r3, #6
 8004844:	bf0c      	ite	eq
 8004846:	2000      	moveq	r0, #0
 8004848:	200f      	movne	r0, #15
 800484a:	4770      	bx	lr
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 800484c:	2002      	movs	r0, #2
  }

  return speed;
}
 800484e:	4770      	bx	lr

08004850 <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8004850:	b530      	push	{r4, r5, lr}
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t epnum = (uint32_t)ep->num;
 8004852:	780a      	ldrb	r2, [r1, #0]

  if (ep->is_in == 1U)
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8004854:	2301      	movs	r3, #1
 8004856:	f500 6c00 	add.w	ip, r0, #2048	@ 0x800
 800485a:	f002 0e0f 	and.w	lr, r2, #15

    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 800485e:	eb00 1042 	add.w	r0, r0, r2, lsl #5
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8004862:	fa03 f30e 	lsl.w	r3, r3, lr
  if (ep->is_in == 1U)
 8004866:	f891 e001 	ldrb.w	lr, [r1, #1]
 800486a:	f1be 0f01 	cmp.w	lr, #1
 800486e:	d018      	beq.n	80048a2 <USB_ActivateEndpoint+0x52>
                                   USB_OTG_DIEPCTL_USBAEP;
    }
  }
  else
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 8004870:	f8dc 201c 	ldr.w	r2, [ip, #28]
 8004874:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 8004878:	f8cc 301c 	str.w	r3, [ip, #28]

    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 800487c:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	@ 0xb00
 8004880:	041b      	lsls	r3, r3, #16
 8004882:	d40c      	bmi.n	800489e <USB_ActivateEndpoint+0x4e>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8004884:	688b      	ldr	r3, [r1, #8]
 8004886:	f8d0 4b00 	ldr.w	r4, [r0, #2816]	@ 0xb00
 800488a:	f3c3 030a 	ubfx	r3, r3, #0, #11
                                    ((uint32_t)ep->type << 18) |
 800488e:	7909      	ldrb	r1, [r1, #4]
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8004890:	4a11      	ldr	r2, [pc, #68]	@ (80048d8 <USB_ActivateEndpoint+0x88>)
 8004892:	4323      	orrs	r3, r4
 8004894:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 8004898:	431a      	orrs	r2, r3
 800489a:	f8c0 2b00 	str.w	r2, [r0, #2816]	@ 0xb00
                                    USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_USBAEP;
    }
  }
  return HAL_OK;
}
 800489e:	2000      	movs	r0, #0
 80048a0:	bd30      	pop	{r4, r5, pc}
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 80048a2:	f8dc 401c 	ldr.w	r4, [ip, #28]
 80048a6:	4323      	orrs	r3, r4
 80048a8:	f8cc 301c 	str.w	r3, [ip, #28]
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 80048ac:	f8d0 3900 	ldr.w	r3, [r0, #2304]	@ 0x900
 80048b0:	041c      	lsls	r4, r3, #16
 80048b2:	d4f4      	bmi.n	800489e <USB_ActivateEndpoint+0x4e>
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 80048b4:	688b      	ldr	r3, [r1, #8]
 80048b6:	f8d0 5900 	ldr.w	r5, [r0, #2304]	@ 0x900
 80048ba:	f3c3 030a 	ubfx	r3, r3, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 80048be:	790c      	ldrb	r4, [r1, #4]
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 80048c0:	4905      	ldr	r1, [pc, #20]	@ (80048d8 <USB_ActivateEndpoint+0x88>)
 80048c2:	432b      	orrs	r3, r5
 80048c4:	ea43 4384 	orr.w	r3, r3, r4, lsl #18
 80048c8:	ea43 5382 	orr.w	r3, r3, r2, lsl #22
 80048cc:	4319      	orrs	r1, r3
 80048ce:	f8c0 1900 	str.w	r1, [r0, #2304]	@ 0x900
}
 80048d2:	2000      	movs	r0, #0
 80048d4:	bd30      	pop	{r4, r5, pc}
 80048d6:	bf00      	nop
 80048d8:	10008000 	.word	0x10008000

080048dc <USB_EPStartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 80048dc:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t epnum = (uint32_t)ep->num;
  uint16_t pktcnt;

  /* IN endpoint */
  if (ep->is_in == 1U)
 80048de:	f891 e001 	ldrb.w	lr, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 80048e2:	780d      	ldrb	r5, [r1, #0]
  if (ep->is_in == 1U)
 80048e4:	f1be 0f01 	cmp.w	lr, #1
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 80048e8:	690c      	ldr	r4, [r1, #16]
    {
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80048ea:	eb00 1345 	add.w	r3, r0, r5, lsl #5
                                       (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
      }

      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);

      if (ep->type == EP_TYPE_ISOC)
 80048ee:	f891 c004 	ldrb.w	ip, [r1, #4]
  if (ep->is_in == 1U)
 80048f2:	d05f      	beq.n	80049b4 <USB_EPStartXfer+0xd8>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 80048f4:	4626      	mov	r6, r4
 80048f6:	f8d3 4b10 	ldr.w	r4, [r3, #2832]	@ 0xb10
 80048fa:	f503 6e30 	add.w	lr, r3, #2816	@ 0xb00
 80048fe:	f36f 0412 	bfc	r4, #0, #19
 8004902:	f8c3 4b10 	str.w	r4, [r3, #2832]	@ 0xb10
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8004906:	f8d3 4b10 	ldr.w	r4, [r3, #2832]	@ 0xb10
 800490a:	f36f 44dc 	bfc	r4, #19, #10
 800490e:	f8c3 4b10 	str.w	r4, [r3, #2832]	@ 0xb10

    if (epnum == 0U)
    {
      if (ep->xfer_len > 0U)
      {
        ep->xfer_len = ep->maxpacket;
 8004912:	688c      	ldr	r4, [r1, #8]
    if (epnum == 0U)
 8004914:	bb55      	cbnz	r5, 800496c <USB_EPStartXfer+0x90>
      if (ep->xfer_len > 0U)
 8004916:	b106      	cbz	r6, 800491a <USB_EPStartXfer+0x3e>
        ep->xfer_len = ep->maxpacket;
 8004918:	610c      	str	r4, [r1, #16]
      }

      /* Store transfer size, for EP0 this is equal to endpoint max packet size */
      ep->xfer_size = ep->maxpacket;
 800491a:	620c      	str	r4, [r1, #32]
    }
    else
    {
      if (ep->xfer_len == 0U)
      {
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 800491c:	f8de 5010 	ldr.w	r5, [lr, #16]
 8004920:	f3c4 0412 	ubfx	r4, r4, #0, #19
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
      }
    }

    if (dma == 1U)
 8004924:	2a01      	cmp	r2, #1
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8004926:	ea44 0405 	orr.w	r4, r4, r5
 800492a:	f8ce 4010 	str.w	r4, [lr, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800492e:	f8de 4010 	ldr.w	r4, [lr, #16]
 8004932:	f444 2400 	orr.w	r4, r4, #524288	@ 0x80000
 8004936:	f8ce 4010 	str.w	r4, [lr, #16]
    if (dma == 1U)
 800493a:	d035      	beq.n	80049a8 <USB_EPStartXfer+0xcc>
      {
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 800493c:	f1bc 0f01 	cmp.w	ip, #1
 8004940:	d10c      	bne.n	800495c <USB_EPStartXfer+0x80>
    {
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8004942:	f8d0 2808 	ldr.w	r2, [r0, #2056]	@ 0x808
 8004946:	f412 7f80 	tst.w	r2, #256	@ 0x100
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 800494a:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	@ 0xb00
 800494e:	bf0c      	ite	eq
 8004950:	f042 5200 	orreq.w	r2, r2, #536870912	@ 0x20000000
      }
      else
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 8004954:	f042 5280 	orrne.w	r2, r2, #268435456	@ 0x10000000
 8004958:	f8c3 2b00 	str.w	r2, [r3, #2816]	@ 0xb00
      }
    }
    /* EP enable */
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 800495c:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	@ 0xb00
 8004960:	f042 4204 	orr.w	r2, r2, #2214592512	@ 0x84000000
 8004964:	f8c3 2b00 	str.w	r2, [r3, #2816]	@ 0xb00
  }

  return HAL_OK;
}
 8004968:	2000      	movs	r0, #0
 800496a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (ep->xfer_len == 0U)
 800496c:	2e00      	cmp	r6, #0
 800496e:	d0d5      	beq.n	800491c <USB_EPStartXfer+0x40>
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8004970:	19a5      	adds	r5, r4, r6
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8004972:	4e69      	ldr	r6, [pc, #420]	@ (8004b18 <USB_EPStartXfer+0x23c>)
    if (dma == 1U)
 8004974:	2a01      	cmp	r2, #1
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8004976:	f105 35ff 	add.w	r5, r5, #4294967295
 800497a:	fbb5 f5f4 	udiv	r5, r5, r4
 800497e:	b2ad      	uxth	r5, r5
        ep->xfer_size = ep->maxpacket * pktcnt;
 8004980:	fb05 f404 	mul.w	r4, r5, r4
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8004984:	ea06 45c5 	and.w	r5, r6, r5, lsl #19
 8004988:	f8de 6010 	ldr.w	r6, [lr, #16]
        ep->xfer_size = ep->maxpacket * pktcnt;
 800498c:	620c      	str	r4, [r1, #32]
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 800498e:	f3c4 0412 	ubfx	r4, r4, #0, #19
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8004992:	ea45 0506 	orr.w	r5, r5, r6
 8004996:	f8ce 5010 	str.w	r5, [lr, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 800499a:	f8de 5010 	ldr.w	r5, [lr, #16]
 800499e:	ea44 0405 	orr.w	r4, r4, r5
 80049a2:	f8ce 4010 	str.w	r4, [lr, #16]
    if (dma == 1U)
 80049a6:	d1c9      	bne.n	800493c <USB_EPStartXfer+0x60>
      if ((uint32_t)ep->xfer_buff != 0U)
 80049a8:	68ca      	ldr	r2, [r1, #12]
 80049aa:	2a00      	cmp	r2, #0
 80049ac:	d0c6      	beq.n	800493c <USB_EPStartXfer+0x60>
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 80049ae:	f8ce 2014 	str.w	r2, [lr, #20]
 80049b2:	e7c3      	b.n	800493c <USB_EPStartXfer+0x60>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80049b4:	f503 6610 	add.w	r6, r3, #2304	@ 0x900
 80049b8:	6937      	ldr	r7, [r6, #16]
    if (ep->xfer_len == 0U)
 80049ba:	2c00      	cmp	r4, #0
 80049bc:	d135      	bne.n	8004a2a <USB_EPStartXfer+0x14e>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80049be:	f36f 47dc 	bfc	r7, #19, #10
    if (dma == 1U)
 80049c2:	2a01      	cmp	r2, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80049c4:	6137      	str	r7, [r6, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 80049c6:	6937      	ldr	r7, [r6, #16]
 80049c8:	f447 2700 	orr.w	r7, r7, #524288	@ 0x80000
 80049cc:	6137      	str	r7, [r6, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80049ce:	6937      	ldr	r7, [r6, #16]
 80049d0:	f36f 0712 	bfc	r7, #0, #19
 80049d4:	6137      	str	r7, [r6, #16]
    if (dma == 1U)
 80049d6:	d077      	beq.n	8004ac8 <USB_EPStartXfer+0x1ec>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80049d8:	f8d3 6900 	ldr.w	r6, [r3, #2304]	@ 0x900
      if (ep->type != EP_TYPE_ISOC)
 80049dc:	f1bc 0f01 	cmp.w	ip, #1
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80049e0:	f046 4604 	orr.w	r6, r6, #2214592512	@ 0x84000000
 80049e4:	f8c3 6900 	str.w	r6, [r3, #2304]	@ 0x900
      if (ep->type != EP_TYPE_ISOC)
 80049e8:	d1be      	bne.n	8004968 <USB_EPStartXfer+0x8c>
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 80049ea:	f8d0 6808 	ldr.w	r6, [r0, #2056]	@ 0x808
 80049ee:	f416 7f80 	tst.w	r6, #256	@ 0x100
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 80049f2:	f8d3 6900 	ldr.w	r6, [r3, #2304]	@ 0x900
 80049f6:	bf0c      	ite	eq
 80049f8:	f046 5600 	orreq.w	r6, r6, #536870912	@ 0x20000000
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 80049fc:	f046 5680 	orrne.w	r6, r6, #268435456	@ 0x10000000
 8004a00:	f8c3 6900 	str.w	r6, [r3, #2304]	@ 0x900
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint8_t *pSrc = src;
  uint32_t count32b;
  uint32_t i;

  if (dma == 0U)
 8004a04:	2a00      	cmp	r2, #0
 8004a06:	d1af      	bne.n	8004968 <USB_EPStartXfer+0x8c>
  {
    count32b = ((uint32_t)len + 3U) / 4U;
 8004a08:	b2a4      	uxth	r4, r4
 8004a0a:	3403      	adds	r4, #3
    for (i = 0U; i < count32b; i++)
 8004a0c:	08a4      	lsrs	r4, r4, #2
 8004a0e:	d0ab      	beq.n	8004968 <USB_EPStartXfer+0x8c>
        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 8004a10:	68cb      	ldr	r3, [r1, #12]
    {
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8004a12:	eb00 3505 	add.w	r5, r0, r5, lsl #12
 8004a16:	eb03 0184 	add.w	r1, r3, r4, lsl #2
 8004a1a:	f505 5580 	add.w	r5, r5, #4096	@ 0x1000
 8004a1e:	f853 2b04 	ldr.w	r2, [r3], #4
    for (i = 0U; i < count32b; i++)
 8004a22:	4299      	cmp	r1, r3
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8004a24:	602a      	str	r2, [r5, #0]
    for (i = 0U; i < count32b; i++)
 8004a26:	d1fa      	bne.n	8004a1e <USB_EPStartXfer+0x142>
 8004a28:	e79e      	b.n	8004968 <USB_EPStartXfer+0x8c>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8004a2a:	f36f 0712 	bfc	r7, #0, #19
 8004a2e:	6137      	str	r7, [r6, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8004a30:	6937      	ldr	r7, [r6, #16]
 8004a32:	f36f 47dc 	bfc	r7, #19, #10
 8004a36:	6137      	str	r7, [r6, #16]
        if (ep->xfer_len > ep->maxpacket)
 8004a38:	688f      	ldr	r7, [r1, #8]
      if (epnum == 0U)
 8004a3a:	bb25      	cbnz	r5, 8004a86 <USB_EPStartXfer+0x1aa>
        if (ep->xfer_len > ep->maxpacket)
 8004a3c:	42a7      	cmp	r7, r4
 8004a3e:	d351      	bcc.n	8004ae4 <USB_EPStartXfer+0x208>
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8004a40:	6937      	ldr	r7, [r6, #16]
 8004a42:	f447 2700 	orr.w	r7, r7, #524288	@ 0x80000
 8004a46:	6137      	str	r7, [r6, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8004a48:	6937      	ldr	r7, [r6, #16]
 8004a4a:	f3c4 0412 	ubfx	r4, r4, #0, #19
      if (ep->type == EP_TYPE_ISOC)
 8004a4e:	f1bc 0f01 	cmp.w	ip, #1
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8004a52:	ea44 0407 	orr.w	r4, r4, r7
 8004a56:	6134      	str	r4, [r6, #16]
      if (ep->type == EP_TYPE_ISOC)
 8004a58:	d024      	beq.n	8004aa4 <USB_EPStartXfer+0x1c8>
    if (dma == 1U)
 8004a5a:	2a01      	cmp	r2, #1
 8004a5c:	d056      	beq.n	8004b0c <USB_EPStartXfer+0x230>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8004a5e:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
        if (ep->xfer_len > 0U)
 8004a62:	690c      	ldr	r4, [r1, #16]
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8004a64:	f042 4204 	orr.w	r2, r2, #2214592512	@ 0x84000000
 8004a68:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
        if (ep->xfer_len > 0U)
 8004a6c:	2c00      	cmp	r4, #0
 8004a6e:	f43f af7b 	beq.w	8004968 <USB_EPStartXfer+0x8c>
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 8004a72:	f005 050f 	and.w	r5, r5, #15
 8004a76:	2301      	movs	r3, #1
 8004a78:	f8d0 2834 	ldr.w	r2, [r0, #2100]	@ 0x834
 8004a7c:	40ab      	lsls	r3, r5
 8004a7e:	4313      	orrs	r3, r2
 8004a80:	f8c0 3834 	str.w	r3, [r0, #2100]	@ 0x834
 8004a84:	e770      	b.n	8004968 <USB_EPStartXfer+0x8c>
                                       (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 8004a86:	eb07 0e04 	add.w	lr, r7, r4
 8004a8a:	f10e 3eff 	add.w	lr, lr, #4294967295
 8004a8e:	fbbe fef7 	udiv	lr, lr, r7
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
 8004a92:	4f21      	ldr	r7, [pc, #132]	@ (8004b18 <USB_EPStartXfer+0x23c>)
 8004a94:	ea07 47ce 	and.w	r7, r7, lr, lsl #19
 8004a98:	f8d6 e010 	ldr.w	lr, [r6, #16]
 8004a9c:	ea47 070e 	orr.w	r7, r7, lr
 8004aa0:	6137      	str	r7, [r6, #16]
 8004aa2:	e7d1      	b.n	8004a48 <USB_EPStartXfer+0x16c>
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 8004aa4:	6934      	ldr	r4, [r6, #16]
    if (dma == 1U)
 8004aa6:	2a01      	cmp	r2, #1
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 8004aa8:	f024 44c0 	bic.w	r4, r4, #1610612736	@ 0x60000000
 8004aac:	6134      	str	r4, [r6, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 8004aae:	6934      	ldr	r4, [r6, #16]
 8004ab0:	f044 5400 	orr.w	r4, r4, #536870912	@ 0x20000000
 8004ab4:	6134      	str	r4, [r6, #16]
    if (dma == 1U)
 8004ab6:	d018      	beq.n	8004aea <USB_EPStartXfer+0x20e>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8004ab8:	f8d3 4900 	ldr.w	r4, [r3, #2304]	@ 0x900
 8004abc:	f044 4404 	orr.w	r4, r4, #2214592512	@ 0x84000000
 8004ac0:	f8c3 4900 	str.w	r4, [r3, #2304]	@ 0x900
        if (ep->xfer_len > 0U)
 8004ac4:	690c      	ldr	r4, [r1, #16]
 8004ac6:	e790      	b.n	80049ea <USB_EPStartXfer+0x10e>
      if ((uint32_t)ep->dma_addr != 0U)
 8004ac8:	69ca      	ldr	r2, [r1, #28]
 8004aca:	b102      	cbz	r2, 8004ace <USB_EPStartXfer+0x1f2>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8004acc:	6172      	str	r2, [r6, #20]
      if (ep->type == EP_TYPE_ISOC)
 8004ace:	f1bc 0f01 	cmp.w	ip, #1
 8004ad2:	d00d      	beq.n	8004af0 <USB_EPStartXfer+0x214>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8004ad4:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
}
 8004ad8:	2000      	movs	r0, #0
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8004ada:	f042 4204 	orr.w	r2, r2, #2214592512	@ 0x84000000
 8004ade:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
}
 8004ae2:	bdf0      	pop	{r4, r5, r6, r7, pc}
          ep->xfer_len = ep->maxpacket;
 8004ae4:	463c      	mov	r4, r7
 8004ae6:	610f      	str	r7, [r1, #16]
 8004ae8:	e7aa      	b.n	8004a40 <USB_EPStartXfer+0x164>
      if ((uint32_t)ep->dma_addr != 0U)
 8004aea:	69ca      	ldr	r2, [r1, #28]
 8004aec:	b102      	cbz	r2, 8004af0 <USB_EPStartXfer+0x214>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8004aee:	6172      	str	r2, [r6, #20]
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8004af0:	f8d0 2808 	ldr.w	r2, [r0, #2056]	@ 0x808
 8004af4:	f412 7f80 	tst.w	r2, #256	@ 0x100
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8004af8:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
 8004afc:	bf0c      	ite	eq
 8004afe:	f042 5200 	orreq.w	r2, r2, #536870912	@ 0x20000000
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8004b02:	f042 5280 	orrne.w	r2, r2, #268435456	@ 0x10000000
 8004b06:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
 8004b0a:	e7e3      	b.n	8004ad4 <USB_EPStartXfer+0x1f8>
      if ((uint32_t)ep->dma_addr != 0U)
 8004b0c:	69ca      	ldr	r2, [r1, #28]
 8004b0e:	2a00      	cmp	r2, #0
 8004b10:	d0e0      	beq.n	8004ad4 <USB_EPStartXfer+0x1f8>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8004b12:	6172      	str	r2, [r6, #20]
      if (ep->type == EP_TYPE_ISOC)
 8004b14:	e7de      	b.n	8004ad4 <USB_EPStartXfer+0x1f8>
 8004b16:	bf00      	nop
 8004b18:	1ff80000 	.word	0x1ff80000

08004b1c <USB_EPStopXfer>:
{
 8004b1c:	b410      	push	{r4}
  __IO uint32_t count = 0U;
 8004b1e:	2300      	movs	r3, #0
{
 8004b20:	b083      	sub	sp, #12
  if (ep->is_in == 1U)
 8004b22:	784a      	ldrb	r2, [r1, #1]
  __IO uint32_t count = 0U;
 8004b24:	9301      	str	r3, [sp, #4]
  if (ep->is_in == 1U)
 8004b26:	2a01      	cmp	r2, #1
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8004b28:	780b      	ldrb	r3, [r1, #0]
 8004b2a:	ea4f 1343 	mov.w	r3, r3, lsl #5
  if (ep->is_in == 1U)
 8004b2e:	d023      	beq.n	8004b78 <USB_EPStopXfer+0x5c>
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8004b30:	f500 6030 	add.w	r0, r0, #2816	@ 0xb00
 8004b34:	58c1      	ldr	r1, [r0, r3]
 8004b36:	18c2      	adds	r2, r0, r3
 8004b38:	2900      	cmp	r1, #0
 8004b3a:	db04      	blt.n	8004b46 <USB_EPStopXfer+0x2a>
  HAL_StatusTypeDef ret = HAL_OK;
 8004b3c:	2000      	movs	r0, #0
}
 8004b3e:	b003      	add	sp, #12
 8004b40:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004b44:	4770      	bx	lr
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 8004b46:	58c4      	ldr	r4, [r0, r3]
        if (count > 10000U)
 8004b48:	f242 7110 	movw	r1, #10000	@ 0x2710
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 8004b4c:	f044 6400 	orr.w	r4, r4, #134217728	@ 0x8000000
 8004b50:	50c4      	str	r4, [r0, r3]
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
 8004b52:	58c4      	ldr	r4, [r0, r3]
 8004b54:	f044 4480 	orr.w	r4, r4, #1073741824	@ 0x40000000
 8004b58:	50c4      	str	r4, [r0, r3]
 8004b5a:	e002      	b.n	8004b62 <USB_EPStopXfer+0x46>
      } while (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) ==  USB_OTG_DOEPCTL_EPENA);
 8004b5c:	6813      	ldr	r3, [r2, #0]
 8004b5e:	2b00      	cmp	r3, #0
 8004b60:	daec      	bge.n	8004b3c <USB_EPStopXfer+0x20>
        count++;
 8004b62:	9b01      	ldr	r3, [sp, #4]
 8004b64:	3301      	adds	r3, #1
 8004b66:	9301      	str	r3, [sp, #4]
        if (count > 10000U)
 8004b68:	9b01      	ldr	r3, [sp, #4]
 8004b6a:	428b      	cmp	r3, r1
 8004b6c:	d9f6      	bls.n	8004b5c <USB_EPStopXfer+0x40>
          ret = HAL_ERROR;
 8004b6e:	2001      	movs	r0, #1
}
 8004b70:	b003      	add	sp, #12
 8004b72:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004b76:	4770      	bx	lr
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8004b78:	f500 6010 	add.w	r0, r0, #2304	@ 0x900
 8004b7c:	58c1      	ldr	r1, [r0, r3]
 8004b7e:	18c2      	adds	r2, r0, r3
 8004b80:	2900      	cmp	r1, #0
 8004b82:	dadb      	bge.n	8004b3c <USB_EPStopXfer+0x20>
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 8004b84:	58c4      	ldr	r4, [r0, r3]
        if (count > 10000U)
 8004b86:	f242 7110 	movw	r1, #10000	@ 0x2710
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 8004b8a:	f044 6400 	orr.w	r4, r4, #134217728	@ 0x8000000
 8004b8e:	50c4      	str	r4, [r0, r3]
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
 8004b90:	58c4      	ldr	r4, [r0, r3]
 8004b92:	f044 4480 	orr.w	r4, r4, #1073741824	@ 0x40000000
 8004b96:	50c4      	str	r4, [r0, r3]
 8004b98:	e002      	b.n	8004ba0 <USB_EPStopXfer+0x84>
      } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) ==  USB_OTG_DIEPCTL_EPENA);
 8004b9a:	6813      	ldr	r3, [r2, #0]
 8004b9c:	2b00      	cmp	r3, #0
 8004b9e:	dacd      	bge.n	8004b3c <USB_EPStopXfer+0x20>
        count++;
 8004ba0:	9b01      	ldr	r3, [sp, #4]
 8004ba2:	3301      	adds	r3, #1
 8004ba4:	9301      	str	r3, [sp, #4]
        if (count > 10000U)
 8004ba6:	9b01      	ldr	r3, [sp, #4]
 8004ba8:	428b      	cmp	r3, r1
 8004baa:	d9f6      	bls.n	8004b9a <USB_EPStopXfer+0x7e>
 8004bac:	e7df      	b.n	8004b6e <USB_EPStopXfer+0x52>
 8004bae:	bf00      	nop

08004bb0 <USB_WritePacket>:
{
 8004bb0:	b410      	push	{r4}
 8004bb2:	f89d 4004 	ldrb.w	r4, [sp, #4]
  if (dma == 0U)
 8004bb6:	b964      	cbnz	r4, 8004bd2 <USB_WritePacket+0x22>
    count32b = ((uint32_t)len + 3U) / 4U;
 8004bb8:	3303      	adds	r3, #3
    for (i = 0U; i < count32b; i++)
 8004bba:	089b      	lsrs	r3, r3, #2
 8004bbc:	d009      	beq.n	8004bd2 <USB_WritePacket+0x22>
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8004bbe:	3201      	adds	r2, #1
 8004bc0:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8004bc4:	eb00 3002 	add.w	r0, r0, r2, lsl #12
 8004bc8:	f851 2b04 	ldr.w	r2, [r1], #4
    for (i = 0U; i < count32b; i++)
 8004bcc:	428b      	cmp	r3, r1
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8004bce:	6002      	str	r2, [r0, #0]
    for (i = 0U; i < count32b; i++)
 8004bd0:	d1fa      	bne.n	8004bc8 <USB_WritePacket+0x18>
      pSrc++;
    }
  }

  return HAL_OK;
}
 8004bd2:	2000      	movs	r0, #0
 8004bd4:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004bd8:	4770      	bx	lr
 8004bda:	bf00      	nop

08004bdc <USB_ReadPacket>:
  * @param  dest  source pointer
  * @param  len  Number of bytes to read
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 8004bdc:	b570      	push	{r4, r5, r6, lr}
  uint32_t pData;
  uint32_t i;
  uint32_t count32b = (uint32_t)len >> 2U;
  uint16_t remaining_bytes = len % 4U;

  for (i = 0U; i < count32b; i++)
 8004bde:	ea5f 0e92 	movs.w	lr, r2, lsr #2
{
 8004be2:	4605      	mov	r5, r0
  uint16_t remaining_bytes = len % 4U;
 8004be4:	f002 0603 	and.w	r6, r2, #3
  for (i = 0U; i < count32b; i++)
 8004be8:	d019      	beq.n	8004c1e <USB_ReadPacket+0x42>

  /* When Number of data is not word aligned, read the remaining byte */
  if (remaining_bytes != 0U)
  {
    i = 0U;
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 8004bea:	f500 5480 	add.w	r4, r0, #4096	@ 0x1000
  uint8_t *pDest = dest;
 8004bee:	468c      	mov	ip, r1
  for (i = 0U; i < count32b; i++)
 8004bf0:	2300      	movs	r3, #0
 8004bf2:	3301      	adds	r3, #1
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 8004bf4:	6822      	ldr	r2, [r4, #0]
  for (i = 0U; i < count32b; i++)
 8004bf6:	459e      	cmp	lr, r3
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 8004bf8:	f84c 2b04 	str.w	r2, [ip], #4
  for (i = 0U; i < count32b; i++)
 8004bfc:	d1f9      	bne.n	8004bf2 <USB_ReadPacket+0x16>
 8004bfe:	eb01 008e 	add.w	r0, r1, lr, lsl #2
  if (remaining_bytes != 0U)
 8004c02:	b15e      	cbz	r6, 8004c1c <USB_ReadPacket+0x40>
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 8004c04:	f505 5580 	add.w	r5, r5, #4096	@ 0x1000
 8004c08:	4406      	add	r6, r0
 8004c0a:	2200      	movs	r2, #0
 8004c0c:	6829      	ldr	r1, [r5, #0]

    do
    {
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8004c0e:	fa21 f302 	lsr.w	r3, r1, r2
 8004c12:	3208      	adds	r2, #8
 8004c14:	f800 3b01 	strb.w	r3, [r0], #1
      i++;
      pDest++;
      remaining_bytes--;
    } while (remaining_bytes != 0U);
 8004c18:	42b0      	cmp	r0, r6
 8004c1a:	d1f8      	bne.n	8004c0e <USB_ReadPacket+0x32>
  }

  return ((void *)pDest);
}
 8004c1c:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t *pDest = dest;
 8004c1e:	4608      	mov	r0, r1
 8004c20:	e7ef      	b.n	8004c02 <USB_ReadPacket+0x26>
 8004c22:	bf00      	nop

08004c24 <USB_EPSetStall>:
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t epnum = (uint32_t)ep->num;
 8004c24:	780b      	ldrb	r3, [r1, #0]

  if (ep->is_in == 1U)
 8004c26:	784a      	ldrb	r2, [r1, #1]
  {
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 8004c28:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 8004c2c:	3b00      	subs	r3, #0
 8004c2e:	bf18      	it	ne
 8004c30:	2301      	movne	r3, #1
  if (ep->is_in == 1U)
 8004c32:	2a01      	cmp	r2, #1
 8004c34:	d00c      	beq.n	8004c50 <USB_EPSetStall+0x2c>
    }
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
  }
  else
  {
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 8004c36:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	@ 0xb00
 8004c3a:	2a00      	cmp	r2, #0
 8004c3c:	db00      	blt.n	8004c40 <USB_EPSetStall+0x1c>
 8004c3e:	b9a3      	cbnz	r3, 8004c6a <USB_EPSetStall+0x46>
    {
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
    }
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 8004c40:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	@ 0xb00
 8004c44:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8004c48:	f8c0 3b00 	str.w	r3, [r0, #2816]	@ 0xb00
  }

  return HAL_OK;
}
 8004c4c:	2000      	movs	r0, #0
 8004c4e:	4770      	bx	lr
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 8004c50:	f8d0 2900 	ldr.w	r2, [r0, #2304]	@ 0x900
 8004c54:	2a00      	cmp	r2, #0
 8004c56:	db00      	blt.n	8004c5a <USB_EPSetStall+0x36>
 8004c58:	b973      	cbnz	r3, 8004c78 <USB_EPSetStall+0x54>
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8004c5a:	f8d0 3900 	ldr.w	r3, [r0, #2304]	@ 0x900
 8004c5e:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8004c62:	f8c0 3900 	str.w	r3, [r0, #2304]	@ 0x900
}
 8004c66:	2000      	movs	r0, #0
 8004c68:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 8004c6a:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	@ 0xb00
 8004c6e:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8004c72:	f8c0 3b00 	str.w	r3, [r0, #2816]	@ 0xb00
 8004c76:	e7e3      	b.n	8004c40 <USB_EPSetStall+0x1c>
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 8004c78:	f8d0 3900 	ldr.w	r3, [r0, #2304]	@ 0x900
 8004c7c:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8004c80:	f8c0 3900 	str.w	r3, [r0, #2304]	@ 0x900
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8004c84:	f8d0 3900 	ldr.w	r3, [r0, #2304]	@ 0x900
 8004c88:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8004c8c:	f8c0 3900 	str.w	r3, [r0, #2304]	@ 0x900
 8004c90:	e7e9      	b.n	8004c66 <USB_EPSetStall+0x42>
 8004c92:	bf00      	nop

08004c94 <USB_EPClearStall>:
  uint32_t epnum = (uint32_t)ep->num;

  if (ep->is_in == 1U)
  {
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8004c94:	790b      	ldrb	r3, [r1, #4]
  if (ep->is_in == 1U)
 8004c96:	784a      	ldrb	r2, [r1, #1]
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8004c98:	f891 c000 	ldrb.w	ip, [r1]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8004c9c:	3b02      	subs	r3, #2
  if (ep->is_in == 1U)
 8004c9e:	2a01      	cmp	r2, #1
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8004ca0:	eb00 104c 	add.w	r0, r0, ip, lsl #5
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8004ca4:	b2db      	uxtb	r3, r3
  if (ep->is_in == 1U)
 8004ca6:	d011      	beq.n	8004ccc <USB_EPClearStall+0x38>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }
  }
  else
  {
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8004ca8:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	@ 0xb00
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8004cac:	2b01      	cmp	r3, #1
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8004cae:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
 8004cb2:	f8c0 2b00 	str.w	r2, [r0, #2816]	@ 0xb00
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8004cb6:	d901      	bls.n	8004cbc <USB_EPClearStall+0x28>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }
  }
  return HAL_OK;
}
 8004cb8:	2000      	movs	r0, #0
 8004cba:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8004cbc:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	@ 0xb00
 8004cc0:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8004cc4:	f8c0 3b00 	str.w	r3, [r0, #2816]	@ 0xb00
}
 8004cc8:	2000      	movs	r0, #0
 8004cca:	4770      	bx	lr
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8004ccc:	f8d0 2900 	ldr.w	r2, [r0, #2304]	@ 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8004cd0:	2b01      	cmp	r3, #1
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8004cd2:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
 8004cd6:	f8c0 2900 	str.w	r2, [r0, #2304]	@ 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8004cda:	d8ed      	bhi.n	8004cb8 <USB_EPClearStall+0x24>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8004cdc:	f8d0 3900 	ldr.w	r3, [r0, #2304]	@ 0x900
 8004ce0:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8004ce4:	f8c0 3900 	str.w	r3, [r0, #2304]	@ 0x900
}
 8004ce8:	2000      	movs	r0, #0
 8004cea:	4770      	bx	lr

08004cec <USB_SetDevAddress>:
  * @param  address  new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetDevAddress(const USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
 8004cec:	4603      	mov	r3, r0
  uint32_t USBx_BASE = (uint32_t)USBx;

  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 8004cee:	0109      	lsls	r1, r1, #4

  return HAL_OK;
}
 8004cf0:	2000      	movs	r0, #0
  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 8004cf2:	f8d3 2800 	ldr.w	r2, [r3, #2048]	@ 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 8004cf6:	f401 61fe 	and.w	r1, r1, #2032	@ 0x7f0
  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 8004cfa:	f422 62fe 	bic.w	r2, r2, #2032	@ 0x7f0
 8004cfe:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 8004d02:	f8d3 2800 	ldr.w	r2, [r3, #2048]	@ 0x800
 8004d06:	4311      	orrs	r1, r2
 8004d08:	f8c3 1800 	str.w	r1, [r3, #2048]	@ 0x800
}
 8004d0c:	4770      	bx	lr
 8004d0e:	bf00      	nop

08004d10 <USB_ReadInterrupts>:
  */
uint32_t USB_ReadInterrupts(USB_OTG_GlobalTypeDef const *USBx)
{
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
 8004d10:	6942      	ldr	r2, [r0, #20]
  tmpreg &= USBx->GINTMSK;
 8004d12:	6980      	ldr	r0, [r0, #24]

  return tmpreg;
}
 8004d14:	4010      	ands	r0, r2
 8004d16:	4770      	bx	lr

08004d18 <USB_ReadChInterrupts>:
uint32_t USB_ReadChInterrupts(const USB_OTG_GlobalTypeDef *USBx, uint8_t chnum)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t tmpreg;

  tmpreg = USBx_HC(chnum)->HCINT;
 8004d18:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 8004d1c:	f8d1 0508 	ldr.w	r0, [r1, #1288]	@ 0x508
  tmpreg &= USBx_HC(chnum)->HCINTMSK;
 8004d20:	f8d1 350c 	ldr.w	r3, [r1, #1292]	@ 0x50c

  return tmpreg;
}
 8004d24:	4018      	ands	r0, r3
 8004d26:	4770      	bx	lr

08004d28 <USB_ReadDevAllOutEpInterrupt>:
uint32_t USB_ReadDevAllOutEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 8004d28:	f8d0 3818 	ldr.w	r3, [r0, #2072]	@ 0x818
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8004d2c:	f8d0 081c 	ldr.w	r0, [r0, #2076]	@ 0x81c
 8004d30:	4018      	ands	r0, r3

  return ((tmpreg & 0xffff0000U) >> 16);
}
 8004d32:	0c00      	lsrs	r0, r0, #16
 8004d34:	4770      	bx	lr
 8004d36:	bf00      	nop

08004d38 <USB_ReadDevAllInEpInterrupt>:
uint32_t USB_ReadDevAllInEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 8004d38:	f8d0 3818 	ldr.w	r3, [r0, #2072]	@ 0x818
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8004d3c:	f8d0 081c 	ldr.w	r0, [r0, #2076]	@ 0x81c
 8004d40:	4018      	ands	r0, r3

  return ((tmpreg & 0xFFFFU));
}
 8004d42:	b280      	uxth	r0, r0
 8004d44:	4770      	bx	lr
 8004d46:	bf00      	nop

08004d48 <USB_ReadDevOutEPInterrupt>:
uint32_t USB_ReadDevOutEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t tmpreg;

  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8004d48:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  tmpreg &= USBx_DEVICE->DOEPMSK;
 8004d4c:	f500 6000 	add.w	r0, r0, #2048	@ 0x800
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8004d50:	f8d1 2b08 	ldr.w	r2, [r1, #2824]	@ 0xb08
  tmpreg &= USBx_DEVICE->DOEPMSK;
 8004d54:	6940      	ldr	r0, [r0, #20]

  return tmpreg;
}
 8004d56:	4010      	ands	r0, r2
 8004d58:	4770      	bx	lr
 8004d5a:	bf00      	nop

08004d5c <USB_ReadDevInEPInterrupt>:
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t tmpreg;
  uint32_t msk;
  uint32_t emp;

  msk = USBx_DEVICE->DIEPMSK;
 8004d5c:	f8d0 2810 	ldr.w	r2, [r0, #2064]	@ 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 8004d60:	f8d0 3834 	ldr.w	r3, [r0, #2100]	@ 0x834
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8004d64:	eb00 1041 	add.w	r0, r0, r1, lsl #5
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 8004d68:	f001 010f 	and.w	r1, r1, #15
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8004d6c:	f8d0 0908 	ldr.w	r0, [r0, #2312]	@ 0x908
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 8004d70:	40cb      	lsrs	r3, r1
 8004d72:	01db      	lsls	r3, r3, #7
 8004d74:	b2db      	uxtb	r3, r3
 8004d76:	4313      	orrs	r3, r2

  return tmpreg;
}
 8004d78:	4018      	ands	r0, r3
 8004d7a:	4770      	bx	lr

08004d7c <USB_GetMode>:
  *           0 : Host
  *           1 : Device
  */
uint32_t USB_GetMode(const USB_OTG_GlobalTypeDef *USBx)
{
  return ((USBx->GINTSTS) & 0x1U);
 8004d7c:	6940      	ldr	r0, [r0, #20]
}
 8004d7e:	f000 0001 	and.w	r0, r0, #1
 8004d82:	4770      	bx	lr

08004d84 <USB_ActivateSetup>:
  * @brief  Activate EP0 for Setup transactions
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateSetup(const USB_OTG_GlobalTypeDef *USBx)
{
 8004d84:	4603      	mov	r3, r0
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;

  return HAL_OK;
}
 8004d86:	2000      	movs	r0, #0
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8004d88:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8004d8c:	f503 6100 	add.w	r1, r3, #2048	@ 0x800
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8004d90:	f36f 020a 	bfc	r2, #0, #11
 8004d94:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8004d98:	f8d3 3804 	ldr.w	r3, [r3, #2052]	@ 0x804
 8004d9c:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8004da0:	604b      	str	r3, [r1, #4]
}
 8004da2:	4770      	bx	lr

08004da4 <USB_EP0_OutStart>:
  *           1 : DMA feature used
  * @param  psetup  pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(const USB_OTG_GlobalTypeDef *USBx, uint8_t dma, const uint8_t *psetup)
{
 8004da4:	b430      	push	{r4, r5}
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 8004da6:	6c05      	ldr	r5, [r0, #64]	@ 0x40

  if (gSNPSiD > USB_OTG_CORE_ID_300A)
  {
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8004da8:	f500 6330 	add.w	r3, r0, #2816	@ 0xb00
  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 8004dac:	4c10      	ldr	r4, [pc, #64]	@ (8004df0 <USB_EP0_OutStart+0x4c>)
 8004dae:	42a5      	cmp	r5, r4
 8004db0:	d903      	bls.n	8004dba <USB_EP0_OutStart+0x16>
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8004db2:	f8d0 4b00 	ldr.w	r4, [r0, #2816]	@ 0xb00
 8004db6:	2c00      	cmp	r4, #0
 8004db8:	db16      	blt.n	8004de8 <USB_EP0_OutStart+0x44>
    {
      return HAL_OK;
    }
  }

  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8004dba:	2400      	movs	r4, #0
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;

  if (dma == 1U)
 8004dbc:	2901      	cmp	r1, #1
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8004dbe:	611c      	str	r4, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8004dc0:	691c      	ldr	r4, [r3, #16]
 8004dc2:	f444 2400 	orr.w	r4, r4, #524288	@ 0x80000
 8004dc6:	611c      	str	r4, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8004dc8:	691c      	ldr	r4, [r3, #16]
 8004dca:	f044 0418 	orr.w	r4, r4, #24
 8004dce:	611c      	str	r4, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 8004dd0:	691c      	ldr	r4, [r3, #16]
 8004dd2:	f044 44c0 	orr.w	r4, r4, #1610612736	@ 0x60000000
 8004dd6:	611c      	str	r4, [r3, #16]
  if (dma == 1U)
 8004dd8:	d106      	bne.n	8004de8 <USB_EP0_OutStart+0x44>
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 8004dda:	615a      	str	r2, [r3, #20]
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 8004ddc:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	@ 0xb00
 8004de0:	f043 2380 	orr.w	r3, r3, #2147516416	@ 0x80008000
 8004de4:	f8c0 3b00 	str.w	r3, [r0, #2816]	@ 0xb00
  }

  return HAL_OK;
}
 8004de8:	2000      	movs	r0, #0
 8004dea:	bc30      	pop	{r4, r5}
 8004dec:	4770      	bx	lr
 8004dee:	bf00      	nop
 8004df0:	4f54300a 	.word	0x4f54300a

08004df4 <USB_InitFSLSPClkSel>:
  */
HAL_StatusTypeDef USB_InitFSLSPClkSel(const USB_OTG_GlobalTypeDef *USBx, uint8_t freq)
{
  uint32_t USBx_BASE = (uint32_t)USBx;

  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
 8004df4:	f8d0 2400 	ldr.w	r2, [r0, #1024]	@ 0x400
  USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
 8004df8:	f001 0303 	and.w	r3, r1, #3

  if (freq == HCFG_48_MHZ)
 8004dfc:	2901      	cmp	r1, #1
  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
 8004dfe:	f500 6c80 	add.w	ip, r0, #1024	@ 0x400
 8004e02:	f022 0203 	bic.w	r2, r2, #3
 8004e06:	f8c0 2400 	str.w	r2, [r0, #1024]	@ 0x400
  USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
 8004e0a:	f8d0 2400 	ldr.w	r2, [r0, #1024]	@ 0x400
 8004e0e:	ea43 0302 	orr.w	r3, r3, r2
 8004e12:	f8c0 3400 	str.w	r3, [r0, #1024]	@ 0x400
  if (freq == HCFG_48_MHZ)
 8004e16:	d009      	beq.n	8004e2c <USB_InitFSLSPClkSel+0x38>
  {
    USBx_HOST->HFIR = HFIR_48_MHZ;
  }
  else if (freq == HCFG_6_MHZ)
 8004e18:	2902      	cmp	r1, #2
 8004e1a:	d105      	bne.n	8004e28 <USB_InitFSLSPClkSel+0x34>
  {
    USBx_HOST->HFIR = HFIR_6_MHZ;
 8004e1c:	f241 7370 	movw	r3, #6000	@ 0x1770
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
 8004e20:	2000      	movs	r0, #0
    USBx_HOST->HFIR = HFIR_6_MHZ;
 8004e22:	f8cc 3004 	str.w	r3, [ip, #4]
 8004e26:	4770      	bx	lr
    return HAL_ERROR;
 8004e28:	2001      	movs	r0, #1
}
 8004e2a:	4770      	bx	lr
    USBx_HOST->HFIR = HFIR_48_MHZ;
 8004e2c:	f64b 3380 	movw	r3, #48000	@ 0xbb80
  return HAL_OK;
 8004e30:	2000      	movs	r0, #0
    USBx_HOST->HFIR = HFIR_48_MHZ;
 8004e32:	f8cc 3004 	str.w	r3, [ip, #4]
 8004e36:	4770      	bx	lr

08004e38 <USB_ResetPort>:
  * @retval HAL status
  * @note (1)The application must wait at least 10 ms
  *   before clearing the reset bit.
  */
HAL_StatusTypeDef USB_ResetPort(const USB_OTG_GlobalTypeDef *USBx)
{
 8004e38:	b530      	push	{r4, r5, lr}
 8004e3a:	4604      	mov	r4, r0
 8004e3c:	b083      	sub	sp, #12
  uint32_t USBx_BASE = (uint32_t)USBx;

  __IO uint32_t hprt0 = 0U;
 8004e3e:	2500      	movs	r5, #0

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
  HAL_Delay(100U);                                 /* See Note #1 */
 8004e40:	2064      	movs	r0, #100	@ 0x64
  __IO uint32_t hprt0 = 0U;
 8004e42:	9501      	str	r5, [sp, #4]
  hprt0 = USBx_HPRT0;
 8004e44:	f8d4 3440 	ldr.w	r3, [r4, #1088]	@ 0x440
 8004e48:	9301      	str	r3, [sp, #4]
  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 8004e4a:	9b01      	ldr	r3, [sp, #4]
 8004e4c:	f023 032e 	bic.w	r3, r3, #46	@ 0x2e
 8004e50:	9301      	str	r3, [sp, #4]
  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
 8004e52:	9b01      	ldr	r3, [sp, #4]
 8004e54:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8004e58:	f8c4 3440 	str.w	r3, [r4, #1088]	@ 0x440
  HAL_Delay(100U);                                 /* See Note #1 */
 8004e5c:	f7fd f91a 	bl	8002094 <HAL_Delay>
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
 8004e60:	9b01      	ldr	r3, [sp, #4]
  HAL_Delay(10U);
 8004e62:	200a      	movs	r0, #10
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
 8004e64:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8004e68:	f8c4 3440 	str.w	r3, [r4, #1088]	@ 0x440
  HAL_Delay(10U);
 8004e6c:	f7fd f912 	bl	8002094 <HAL_Delay>

  return HAL_OK;
}
 8004e70:	4628      	mov	r0, r5
 8004e72:	b003      	add	sp, #12
 8004e74:	bd30      	pop	{r4, r5, pc}
 8004e76:	bf00      	nop

08004e78 <USB_DriveVbus>:
  *           0 : Deactivate VBUS
  *           1 : Activate VBUS
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DriveVbus(const USB_OTG_GlobalTypeDef *USBx, uint8_t state)
{
 8004e78:	b082      	sub	sp, #8
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
 8004e7a:	2300      	movs	r3, #0
 8004e7c:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
 8004e7e:	f8d0 3440 	ldr.w	r3, [r0, #1088]	@ 0x440
 8004e82:	9301      	str	r3, [sp, #4]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 8004e84:	9b01      	ldr	r3, [sp, #4]
 8004e86:	f023 032e 	bic.w	r3, r3, #46	@ 0x2e
 8004e8a:	9301      	str	r3, [sp, #4]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 8004e8c:	9b01      	ldr	r3, [sp, #4]
 8004e8e:	f413 5f80 	tst.w	r3, #4096	@ 0x1000
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 8004e92:	9b01      	ldr	r3, [sp, #4]
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 8004e94:	d101      	bne.n	8004e9a <USB_DriveVbus+0x22>
 8004e96:	2901      	cmp	r1, #1
 8004e98:	d00d      	beq.n	8004eb6 <USB_DriveVbus+0x3e>
  }
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 8004e9a:	04db      	lsls	r3, r3, #19
 8004e9c:	d500      	bpl.n	8004ea0 <USB_DriveVbus+0x28>
 8004e9e:	b111      	cbz	r1, 8004ea6 <USB_DriveVbus+0x2e>
  {
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
  }
  return HAL_OK;
}
 8004ea0:	2000      	movs	r0, #0
 8004ea2:	b002      	add	sp, #8
 8004ea4:	4770      	bx	lr
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
 8004ea6:	9b01      	ldr	r3, [sp, #4]
 8004ea8:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8004eac:	f8c0 3440 	str.w	r3, [r0, #1088]	@ 0x440
}
 8004eb0:	2000      	movs	r0, #0
 8004eb2:	b002      	add	sp, #8
 8004eb4:	4770      	bx	lr
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 8004eb6:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8004eba:	f8c0 3440 	str.w	r3, [r0, #1088]	@ 0x440
}
 8004ebe:	2000      	movs	r0, #0
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 8004ec0:	9b01      	ldr	r3, [sp, #4]
}
 8004ec2:	b002      	add	sp, #8
 8004ec4:	4770      	bx	lr
 8004ec6:	bf00      	nop

08004ec8 <USB_GetHostSpeed>:
  *            @arg HCD_SPEED_HIGH: High speed mode
  *            @arg HCD_SPEED_FULL: Full speed mode
  *            @arg HCD_SPEED_LOW: Low speed mode
  */
uint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef const *USBx)
{
 8004ec8:	b082      	sub	sp, #8
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
 8004eca:	2300      	movs	r3, #0
 8004ecc:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
 8004ece:	f8d0 3440 	ldr.w	r3, [r0, #1088]	@ 0x440
 8004ed2:	9301      	str	r3, [sp, #4]
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
 8004ed4:	9801      	ldr	r0, [sp, #4]
}
 8004ed6:	f3c0 4041 	ubfx	r0, r0, #17, #2
 8004eda:	b002      	add	sp, #8
 8004edc:	4770      	bx	lr
 8004ede:	bf00      	nop

08004ee0 <USB_HC_Init>:
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num,
                              uint8_t epnum, uint8_t dev_address, uint8_t speed,
                              uint8_t ep_type, uint16_t mps)
{
 8004ee0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004ee4:	b082      	sub	sp, #8
  uint32_t HCcharEpDir;
  uint32_t HCcharLowSpeed;
  uint32_t HostCoreSpeed;

  /* Clear old interrupt conditions for this host channel. */
  USBx_HC((uint32_t)ch_num)->HCINT = CLEAR_INTERRUPT_MASK;
 8004ee6:	eb00 1441 	add.w	r4, r0, r1, lsl #5
{
 8004eea:	4684      	mov	ip, r0
  USBx_HC((uint32_t)ch_num)->HCINT = CLEAR_INTERRUPT_MASK;
 8004eec:	f04f 30ff 	mov.w	r0, #4294967295
{
 8004ef0:	f89d 802c 	ldrb.w	r8, [sp, #44]	@ 0x2c
  USBx_HC((uint32_t)ch_num)->HCINT = CLEAR_INTERRUPT_MASK;
 8004ef4:	f504 6aa0 	add.w	sl, r4, #1280	@ 0x500
{
 8004ef8:	f89d 6028 	ldrb.w	r6, [sp, #40]	@ 0x28
                                            USB_OTG_HCINTMSK_TXERRM |
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_NAKM;

      if ((epnum & 0x80U) == 0x80U)
 8004efc:	b255      	sxtb	r5, r2
{
 8004efe:	f8bd 7030 	ldrh.w	r7, [sp, #48]	@ 0x30
  USBx_HC((uint32_t)ch_num)->HCINT = CLEAR_INTERRUPT_MASK;
 8004f02:	f8c4 0508 	str.w	r0, [r4, #1288]	@ 0x508
  switch (ep_type)
 8004f06:	f1b8 0f03 	cmp.w	r8, #3
 8004f0a:	d87d      	bhi.n	8005008 <USB_HC_Init+0x128>
 8004f0c:	e8df f008 	tbb	[pc, r8]
 8004f10:	61026f02 	.word	0x61026f02
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 8004f14:	f240 409d 	movw	r0, #1181	@ 0x49d
      if ((epnum & 0x80U) == 0x80U)
 8004f18:	2d00      	cmp	r5, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 8004f1a:	f8ca 000c 	str.w	r0, [sl, #12]
      {
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
 8004f1e:	f8da 000c 	ldr.w	r0, [sl, #12]
      if ((epnum & 0x80U) == 0x80U)
 8004f22:	db5e      	blt.n	8004fe2 <USB_HC_Init+0x102>
      }
      else
      {
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET |
 8004f24:	f040 0060 	orr.w	r0, r0, #96	@ 0x60
 8004f28:	f8ca 000c 	str.w	r0, [sl, #12]
  HAL_StatusTypeDef ret = HAL_OK;
 8004f2c:	2000      	movs	r0, #0
      ret = HAL_ERROR;
      break;
  }

  /* Clear Hub Start Split transaction */
  USBx_HC((uint32_t)ch_num)->HCSPLT = 0U;
 8004f2e:	f04f 0900 	mov.w	r9, #0
  else
  {
    HCcharLowSpeed = 0U;
  }

  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 8004f32:	ea4f 5e83 	mov.w	lr, r3, lsl #22
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8004f36:	f001 010f 	and.w	r1, r1, #15
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) |
 8004f3a:	f3c7 070a 	ubfx	r7, r7, #0, #11
  USBx_HC((uint32_t)ch_num)->HCSPLT = 0U;
 8004f3e:	f8ca 9004 	str.w	r9, [sl, #4]
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 8004f42:	f00e 5efe 	and.w	lr, lr, #532676608	@ 0x1fc00000
  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;
 8004f46:	f8da 300c 	ldr.w	r3, [sl, #12]
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 8004f4a:	02d2      	lsls	r2, r2, #11
  if ((epnum & 0x80U) == 0x80U)
 8004f4c:	0fed      	lsrs	r5, r5, #31
  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;
 8004f4e:	f043 0302 	orr.w	r3, r3, #2
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 8004f52:	f402 42f0 	and.w	r2, r2, #30720	@ 0x7800
  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_CHHM;
 8004f56:	f8ca 300c 	str.w	r3, [sl, #12]
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8004f5a:	2301      	movs	r3, #1
 8004f5c:	408b      	lsls	r3, r1
 8004f5e:	f8dc 1418 	ldr.w	r1, [ip, #1048]	@ 0x418
 8004f62:	430b      	orrs	r3, r1
                                      USB_OTG_HCCHAR_MC_0 | HCcharEpDir | HCcharLowSpeed;

  if ((ep_type == EP_TYPE_INTR) || (ep_type == EP_TYPE_ISOC))
 8004f64:	f008 01fd 	and.w	r1, r8, #253	@ 0xfd
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8004f68:	f8cc 3418 	str.w	r3, [ip, #1048]	@ 0x418
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 8004f6c:	f8dc 3018 	ldr.w	r3, [ip, #24]
 8004f70:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 8004f74:	f8cc 3018 	str.w	r3, [ip, #24]
  __IO uint32_t hprt0 = 0U;
 8004f78:	f8cd 9004 	str.w	r9, [sp, #4]
  hprt0 = USBx_HPRT0;
 8004f7c:	f8dc 3440 	ldr.w	r3, [ip, #1088]	@ 0x440
 8004f80:	9301      	str	r3, [sp, #4]
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 8004f82:	ea4f 4388 	mov.w	r3, r8, lsl #18
 8004f86:	f403 2340 	and.w	r3, r3, #786432	@ 0xc0000
                                      USB_OTG_HCCHAR_MC_0 | HCcharEpDir | HCcharLowSpeed;
 8004f8a:	433b      	orrs	r3, r7
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
 8004f8c:	9f01      	ldr	r7, [sp, #4]
  if ((speed == HPRT0_PRTSPD_LOW_SPEED) && (HostCoreSpeed != HPRT0_PRTSPD_LOW_SPEED))
 8004f8e:	f407 2cc0 	and.w	ip, r7, #393216	@ 0x60000
                                      USB_OTG_HCCHAR_MC_0 | HCcharEpDir | HCcharLowSpeed;
 8004f92:	ea43 030e 	orr.w	r3, r3, lr
  if ((speed == HPRT0_PRTSPD_LOW_SPEED) && (HostCoreSpeed != HPRT0_PRTSPD_LOW_SPEED))
 8004f96:	f5bc 2c80 	subs.w	ip, ip, #262144	@ 0x40000
 8004f9a:	bf18      	it	ne
 8004f9c:	f04f 0c01 	movne.w	ip, #1
 8004fa0:	2e02      	cmp	r6, #2
 8004fa2:	bf18      	it	ne
 8004fa4:	f04f 0c00 	movne.w	ip, #0
  if ((ep_type == EP_TYPE_INTR) || (ep_type == EP_TYPE_ISOC))
 8004fa8:	2901      	cmp	r1, #1
                                      USB_OTG_HCCHAR_MC_0 | HCcharEpDir | HCcharLowSpeed;
 8004faa:	ea43 434c 	orr.w	r3, r3, ip, lsl #17
 8004fae:	ea43 0302 	orr.w	r3, r3, r2
 8004fb2:	ea43 33c5 	orr.w	r3, r3, r5, lsl #15
 8004fb6:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 8004fba:	f8c4 3500 	str.w	r3, [r4, #1280]	@ 0x500
  if ((ep_type == EP_TYPE_INTR) || (ep_type == EP_TYPE_ISOC))
 8004fbe:	d105      	bne.n	8004fcc <USB_HC_Init+0xec>
  {
    USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 8004fc0:	f8d4 3500 	ldr.w	r3, [r4, #1280]	@ 0x500
 8004fc4:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8004fc8:	f8c4 3500 	str.w	r3, [r4, #1280]	@ 0x500
  }

  return ret;
}
 8004fcc:	b002      	add	sp, #8
 8004fce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 8004fd2:	f240 609d 	movw	r0, #1693	@ 0x69d
      if ((epnum & 0x80U) == 0x80U)
 8004fd6:	2d00      	cmp	r5, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 8004fd8:	f8ca 000c 	str.w	r0, [sl, #12]
      if ((epnum & 0x80U) == 0x80U)
 8004fdc:	da05      	bge.n	8004fea <USB_HC_Init+0x10a>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
 8004fde:	f8da 000c 	ldr.w	r0, [sl, #12]
 8004fe2:	f440 7080 	orr.w	r0, r0, #256	@ 0x100
 8004fe6:	f8ca 000c 	str.w	r0, [sl, #12]
  HAL_StatusTypeDef ret = HAL_OK;
 8004fea:	2000      	movs	r0, #0
 8004fec:	e79f      	b.n	8004f2e <USB_HC_Init+0x4e>
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 8004fee:	f240 2025 	movw	r0, #549	@ 0x225
      if ((epnum & 0x80U) == 0x80U)
 8004ff2:	2d00      	cmp	r5, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 8004ff4:	f8ca 000c 	str.w	r0, [sl, #12]
      if ((epnum & 0x80U) == 0x80U)
 8004ff8:	daf7      	bge.n	8004fea <USB_HC_Init+0x10a>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);
 8004ffa:	f8da 000c 	ldr.w	r0, [sl, #12]
 8004ffe:	f440 70c0 	orr.w	r0, r0, #384	@ 0x180
 8005002:	f8ca 000c 	str.w	r0, [sl, #12]
 8005006:	e7f0      	b.n	8004fea <USB_HC_Init+0x10a>
  switch (ep_type)
 8005008:	2001      	movs	r0, #1
 800500a:	e790      	b.n	8004f2e <USB_HC_Init+0x4e>

0800500c <USB_HC_StartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
{
 800500c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t ch_num = (uint32_t)hc->ch_num;
 8005010:	784c      	ldrb	r4, [r1, #1]
  uint16_t len_words;
  uint16_t num_packets;
  uint16_t max_hc_pkt_count = HC_MAX_PKT_CNT;

  /* in DMA mode host Core automatically issues ping in case of NYET/NAK */
  if (dma == 1U)
 8005012:	2a01      	cmp	r2, #1
{
 8005014:	b082      	sub	sp, #8
  {
    if ((hc->ep_type == EP_TYPE_CTRL) || (hc->ep_type == EP_TYPE_BULK))
    {

      USBx_HC((uint32_t)ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET |
 8005016:	eb00 1c44 	add.w	ip, r0, r4, lsl #5
 800501a:	f50c 6ea0 	add.w	lr, ip, #1280	@ 0x500
  if (dma == 1U)
 800501e:	f000 80b0 	beq.w	8005182 <USB_HC_StartXfer+0x176>
                                               USB_OTG_HCINTMSK_NAKM);
    }
  }
  else
  {
    if ((hc->speed == USBH_HS_SPEED) && (hc->do_ping == 1U))
 8005022:	888b      	ldrh	r3, [r1, #4]
 8005024:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8005028:	f000 80ec 	beq.w	8005204 <USB_HC_StartXfer+0x1f8>
      (void)USB_DoPing(USBx, hc->ch_num);
      return HAL_OK;
    }
  }

  if (hc->do_ssplit == 1U)
 800502c:	798e      	ldrb	r6, [r1, #6]
  {
    /* Set number of packet to 1 for Split transaction */
    num_packets = 1U;

    if (hc->ep_is_in != 0U)
 800502e:	78cd      	ldrb	r5, [r1, #3]
  if (hc->do_ssplit == 1U)
 8005030:	2e01      	cmp	r6, #1
 8005032:	f000 80b6 	beq.w	80051a2 <USB_HC_StartXfer+0x196>
    }
  }
  else
  {
    /* Compute the expected number of packets associated to the transfer */
    if (hc->xfer_len > 0U)
 8005036:	6a0f      	ldr	r7, [r1, #32]
 8005038:	2f00      	cmp	r7, #0
 800503a:	d053      	beq.n	80050e4 <USB_HC_StartXfer+0xd8>
    {
      num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
 800503c:	f8b1 8014 	ldrh.w	r8, [r1, #20]
 8005040:	1e7b      	subs	r3, r7, #1
 8005042:	4443      	add	r3, r8
 8005044:	fbb3 f3f8 	udiv	r3, r3, r8

      if (num_packets > max_hc_pkt_count)
 8005048:	b29b      	uxth	r3, r3
    * For IN channel HCTSIZ.XferSize is expected to be an integer multiple of
    * max_packet size.
    */
    if (hc->ep_is_in != 0U)
    {
      hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 800504a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800504e:	bf28      	it	cs
 8005050:	f44f 7380 	movcs.w	r3, #256	@ 0x100
    if (hc->ep_is_in != 0U)
 8005054:	2d00      	cmp	r5, #0
 8005056:	d048      	beq.n	80050ea <USB_HC_StartXfer+0xde>
      hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 8005058:	8a8f      	ldrh	r7, [r1, #20]
 800505a:	fb03 f707 	mul.w	r7, r3, r7
    }
  }

  /* Initialize the HCTSIZn register */
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 800505e:	04db      	lsls	r3, r3, #19
      hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 8005060:	61cf      	str	r7, [r1, #28]
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 8005062:	f3c7 0712 	ubfx	r7, r7, #0, #19
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8005066:	433b      	orrs	r3, r7
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
 8005068:	7d8f      	ldrb	r7, [r1, #22]
 800506a:	077f      	lsls	r7, r7, #29
 800506c:	f007 47c0 	and.w	r7, r7, #1610612736	@ 0x60000000
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8005070:	433b      	orrs	r3, r7
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 8005072:	f8ce 3010 	str.w	r3, [lr, #16]

  if (dma != 0U)
 8005076:	b112      	cbz	r2, 800507e <USB_HC_StartXfer+0x72>
  {
    /* xfer_buff MUST be 32-bits aligned */
    USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
 8005078:	698b      	ldr	r3, [r1, #24]
 800507a:	f8ce 3014 	str.w	r3, [lr, #20]
  }

  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
 800507e:	f8d0 3408 	ldr.w	r3, [r0, #1032]	@ 0x408
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;

  if (hc->do_ssplit == 1U)
 8005082:	2e01      	cmp	r6, #1
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 8005084:	f8dc 7500 	ldr.w	r7, [ip, #1280]	@ 0x500
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 8005088:	ea6f 0303 	mvn.w	r3, r3
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 800508c:	f027 5700 	bic.w	r7, r7, #536870912	@ 0x20000000
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 8005090:	ea4f 7343 	mov.w	r3, r3, lsl #29
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 8005094:	f8cc 7500 	str.w	r7, [ip, #1280]	@ 0x500
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 8005098:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800509c:	f8dc 7500 	ldr.w	r7, [ip, #1280]	@ 0x500
 80050a0:	ea43 0307 	orr.w	r3, r3, r7
  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
 80050a4:	f500 6780 	add.w	r7, r0, #1024	@ 0x400
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 80050a8:	f8cc 3500 	str.w	r3, [ip, #1280]	@ 0x500
  if (hc->do_ssplit == 1U)
 80050ac:	d022      	beq.n	80050f4 <USB_HC_StartXfer+0xe8>
    }
  }
  else
  {
    /* Clear Hub Start Split transaction */
    USBx_HC((uint32_t)ch_num)->HCSPLT = 0U;
 80050ae:	2300      	movs	r3, #0
 80050b0:	f8ce 3004 	str.w	r3, [lr, #4]
  }

  /* Set host channel enable */
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 80050b4:	f8dc 3500 	ldr.w	r3, [ip, #1280]	@ 0x500
 80050b8:	9301      	str	r3, [sp, #4]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 80050ba:	9b01      	ldr	r3, [sp, #4]
 80050bc:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 80050c0:	9301      	str	r3, [sp, #4]

  /* make sure to set the correct ep direction */
  if (hc->ep_is_in != 0U)
 80050c2:	2d00      	cmp	r5, #0
 80050c4:	d043      	beq.n	800514e <USB_HC_StartXfer+0x142>
  {
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
 80050c6:	9b01      	ldr	r3, [sp, #4]
 80050c8:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80050cc:	9301      	str	r3, [sp, #4]
  }
  else
  {
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
  }
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 80050ce:	9b01      	ldr	r3, [sp, #4]
 80050d0:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80050d4:	9301      	str	r3, [sp, #4]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
 80050d6:	9b01      	ldr	r3, [sp, #4]
 80050d8:	f8cc 3500 	str.w	r3, [ip, #1280]	@ 0x500
    /* Write packet into the Tx FIFO. */
    (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
  }

  return HAL_OK;
}
 80050dc:	2000      	movs	r0, #0
 80050de:	b002      	add	sp, #8
 80050e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80050e4:	2301      	movs	r3, #1
    if (hc->ep_is_in != 0U)
 80050e6:	2d00      	cmp	r5, #0
 80050e8:	d1b6      	bne.n	8005058 <USB_HC_StartXfer+0x4c>
      hc->XferSize = hc->xfer_len;
 80050ea:	61cf      	str	r7, [r1, #28]
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 80050ec:	04db      	lsls	r3, r3, #19
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 80050ee:	f3c7 0712 	ubfx	r7, r7, #0, #19
 80050f2:	e7b8      	b.n	8005066 <USB_HC_StartXfer+0x5a>
    USBx_HC((uint32_t)ch_num)->HCSPLT = ((uint32_t)hc->hub_addr << USB_OTG_HCSPLT_HUBADDR_Pos) |
 80050f4:	7c4e      	ldrb	r6, [r1, #17]
                                        (uint32_t)hc->hub_port_nbr | USB_OTG_HCSPLT_SPLITEN;
 80050f6:	7c0b      	ldrb	r3, [r1, #16]
    USBx_HC((uint32_t)ch_num)->HCSPLT = ((uint32_t)hc->hub_addr << USB_OTG_HCSPLT_HUBADDR_Pos) |
 80050f8:	ea43 13c6 	orr.w	r3, r3, r6, lsl #7
                                        (uint32_t)hc->hub_port_nbr | USB_OTG_HCSPLT_SPLITEN;
 80050fc:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
    USBx_HC((uint32_t)ch_num)->HCSPLT = ((uint32_t)hc->hub_addr << USB_OTG_HCSPLT_HUBADDR_Pos) |
 8005100:	f8ce 3004 	str.w	r3, [lr, #4]
    USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_ACKM |
 8005104:	f8de 300c 	ldr.w	r3, [lr, #12]
 8005108:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
 800510c:	f8ce 300c 	str.w	r3, [lr, #12]
    if ((hc->do_csplit == 1U) && (hc->ep_is_in == 0U))
 8005110:	79ce      	ldrb	r6, [r1, #7]
    if ((hc->ep_type == EP_TYPE_CTRL) || (hc->ep_type == EP_TYPE_BULK))
 8005112:	7c8b      	ldrb	r3, [r1, #18]
    if ((hc->do_csplit == 1U) && (hc->ep_is_in == 0U))
 8005114:	2e01      	cmp	r6, #1
 8005116:	d152      	bne.n	80051be <USB_HC_StartXfer+0x1b2>
    if (((hc->ep_type == EP_TYPE_ISOC) || (hc->ep_type == EP_TYPE_INTR)) &&
 8005118:	f003 06fd 	and.w	r6, r3, #253	@ 0xfd
    if ((hc->do_csplit == 1U) && (hc->ep_is_in == 0U))
 800511c:	2d00      	cmp	r5, #0
 800511e:	d15f      	bne.n	80051e0 <USB_HC_StartXfer+0x1d4>
      USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_COMPLSPLT;
 8005120:	f8de 5004 	ldr.w	r5, [lr, #4]
    if (((hc->ep_type == EP_TYPE_ISOC) || (hc->ep_type == EP_TYPE_INTR)) &&
 8005124:	2e01      	cmp	r6, #1
      USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_COMPLSPLT;
 8005126:	f445 3580 	orr.w	r5, r5, #65536	@ 0x10000
 800512a:	f8ce 5004 	str.w	r5, [lr, #4]
      USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET;
 800512e:	f8de 500c 	ldr.w	r5, [lr, #12]
 8005132:	f045 0540 	orr.w	r5, r5, #64	@ 0x40
 8005136:	f8ce 500c 	str.w	r5, [lr, #12]
    if (((hc->ep_type == EP_TYPE_ISOC) || (hc->ep_type == EP_TYPE_INTR)) &&
 800513a:	d101      	bne.n	8005140 <USB_HC_StartXfer+0x134>
    if ((hc->ep_type == EP_TYPE_ISOC) && (hc->ep_is_in == 0U))
 800513c:	2b01      	cmp	r3, #1
 800513e:	d042      	beq.n	80051c6 <USB_HC_StartXfer+0x1ba>
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 8005140:	f8dc 3500 	ldr.w	r3, [ip, #1280]	@ 0x500
 8005144:	9301      	str	r3, [sp, #4]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8005146:	9b01      	ldr	r3, [sp, #4]
 8005148:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 800514c:	9301      	str	r3, [sp, #4]
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
 800514e:	9b01      	ldr	r3, [sp, #4]
 8005150:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8005154:	9301      	str	r3, [sp, #4]
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 8005156:	9b01      	ldr	r3, [sp, #4]
 8005158:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 800515c:	9301      	str	r3, [sp, #4]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
 800515e:	9b01      	ldr	r3, [sp, #4]
 8005160:	f8cc 3500 	str.w	r3, [ip, #1280]	@ 0x500
  if (dma != 0U) /* dma mode */
 8005164:	2a00      	cmp	r2, #0
 8005166:	d1b9      	bne.n	80050dc <USB_HC_StartXfer+0xd0>
  if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U) && (hc->do_csplit == 0U))
 8005168:	6a0a      	ldr	r2, [r1, #32]
 800516a:	2a00      	cmp	r2, #0
 800516c:	d0b6      	beq.n	80050dc <USB_HC_StartXfer+0xd0>
 800516e:	79cb      	ldrb	r3, [r1, #7]
 8005170:	2b00      	cmp	r3, #0
 8005172:	d1b3      	bne.n	80050dc <USB_HC_StartXfer+0xd0>
    switch (hc->ep_type)
 8005174:	7c8b      	ldrb	r3, [r1, #18]
 8005176:	2b03      	cmp	r3, #3
 8005178:	d85e      	bhi.n	8005238 <USB_HC_StartXfer+0x22c>
 800517a:	e8df f003 	tbb	[pc, r3]
 800517e:	6f52      	.short	0x6f52
 8005180:	6f52      	.short	0x6f52
    if ((hc->ep_type == EP_TYPE_CTRL) || (hc->ep_type == EP_TYPE_BULK))
 8005182:	7c8b      	ldrb	r3, [r1, #18]
 8005184:	f013 0ffd 	tst.w	r3, #253	@ 0xfd
 8005188:	f47f af50 	bne.w	800502c <USB_HC_StartXfer+0x20>
      USBx_HC((uint32_t)ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET |
 800518c:	f8de 300c 	ldr.w	r3, [lr, #12]
 8005190:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8005194:	f8ce 300c 	str.w	r3, [lr, #12]
  if (hc->do_ssplit == 1U)
 8005198:	798e      	ldrb	r6, [r1, #6]
    if (hc->ep_is_in != 0U)
 800519a:	78cd      	ldrb	r5, [r1, #3]
  if (hc->do_ssplit == 1U)
 800519c:	2e01      	cmp	r6, #1
 800519e:	f47f af4a 	bne.w	8005036 <USB_HC_StartXfer+0x2a>
    if (hc->ep_is_in != 0U)
 80051a2:	b9c5      	cbnz	r5, 80051d6 <USB_HC_StartXfer+0x1ca>
      if (hc->ep_type == EP_TYPE_ISOC)
 80051a4:	7c8b      	ldrb	r3, [r1, #18]
        if (hc->xfer_len > ISO_SPLT_MPS)
 80051a6:	6a0f      	ldr	r7, [r1, #32]
      if (hc->ep_type == EP_TYPE_ISOC)
 80051a8:	2b01      	cmp	r3, #1
 80051aa:	d07f      	beq.n	80052ac <USB_HC_StartXfer+0x2a0>
        if ((dma == 1U) && (hc->xfer_len > hc->max_packet))
 80051ac:	2a01      	cmp	r2, #1
 80051ae:	f000 808d 	beq.w	80052cc <USB_HC_StartXfer+0x2c0>
          hc->XferSize = hc->xfer_len;
 80051b2:	61cf      	str	r7, [r1, #28]
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 80051b4:	f3c7 0712 	ubfx	r7, r7, #0, #19
 80051b8:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80051bc:	e753      	b.n	8005066 <USB_HC_StartXfer+0x5a>
    if ((hc->ep_type == EP_TYPE_ISOC) && (hc->ep_is_in == 0U))
 80051be:	2b01      	cmp	r3, #1
 80051c0:	f47f af78 	bne.w	80050b4 <USB_HC_StartXfer+0xa8>
 80051c4:	b9b5      	cbnz	r5, 80051f4 <USB_HC_StartXfer+0x1e8>
      switch (hc->iso_splt_xactPos)
 80051c6:	68cb      	ldr	r3, [r1, #12]
 80051c8:	3b01      	subs	r3, #1
 80051ca:	2b03      	cmp	r3, #3
 80051cc:	d8b8      	bhi.n	8005140 <USB_HC_StartXfer+0x134>
 80051ce:	e8df f003 	tbb	[pc, r3]
 80051d2:	5f66      	.short	0x5f66
 80051d4:	5158      	.short	0x5158
      hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 80051d6:	8a8f      	ldrh	r7, [r1, #20]
 80051d8:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80051dc:	61cf      	str	r7, [r1, #28]
 80051de:	e742      	b.n	8005066 <USB_HC_StartXfer+0x5a>
    if (((hc->ep_type == EP_TYPE_ISOC) || (hc->ep_type == EP_TYPE_INTR)) &&
 80051e0:	2e01      	cmp	r6, #1
 80051e2:	d107      	bne.n	80051f4 <USB_HC_StartXfer+0x1e8>
        (hc->do_csplit == 1U) && (hc->ep_is_in == 1U))
 80051e4:	2d01      	cmp	r5, #1
 80051e6:	d105      	bne.n	80051f4 <USB_HC_StartXfer+0x1e8>
      USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_COMPLSPLT;
 80051e8:	f8de 3004 	ldr.w	r3, [lr, #4]
 80051ec:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80051f0:	f8ce 3004 	str.w	r3, [lr, #4]
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 80051f4:	f8dc 3500 	ldr.w	r3, [ip, #1280]	@ 0x500
 80051f8:	9301      	str	r3, [sp, #4]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 80051fa:	9b01      	ldr	r3, [sp, #4]
 80051fc:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8005200:	9301      	str	r3, [sp, #4]
  if (hc->ep_is_in != 0U)
 8005202:	e760      	b.n	80050c6 <USB_HC_StartXfer+0xba>
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t chnum = (uint32_t)ch_num;
  uint32_t num_packets = 1U;
  uint32_t tmpreg;

  USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8005204:	4b3c      	ldr	r3, [pc, #240]	@ (80052f8 <USB_HC_StartXfer+0x2ec>)
}
 8005206:	2000      	movs	r0, #0
  USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8005208:	f8ce 3010 	str.w	r3, [lr, #16]
                           USB_OTG_HCTSIZ_DOPING;

  /* Set host channel enable */
  tmpreg = USBx_HC(chnum)->HCCHAR;
 800520c:	f8dc 3500 	ldr.w	r3, [ip, #1280]	@ 0x500
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8005210:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 8005214:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
  USBx_HC(chnum)->HCCHAR = tmpreg;
 8005218:	f8cc 3500 	str.w	r3, [ip, #1280]	@ 0x500
}
 800521c:	b002      	add	sp, #8
 800521e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
 8005222:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
        len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 8005224:	1cd5      	adds	r5, r2, #3
        if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
 8005226:	b29b      	uxth	r3, r3
 8005228:	f3c5 058f 	ubfx	r5, r5, #2, #16
 800522c:	429d      	cmp	r5, r3
 800522e:	d903      	bls.n	8005238 <USB_HC_StartXfer+0x22c>
          USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
 8005230:	6983      	ldr	r3, [r0, #24]
 8005232:	f043 0320 	orr.w	r3, r3, #32
 8005236:	6183      	str	r3, [r0, #24]
    count32b = ((uint32_t)len + 3U) / 4U;
 8005238:	b292      	uxth	r2, r2
    (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
 800523a:	698b      	ldr	r3, [r1, #24]
    count32b = ((uint32_t)len + 3U) / 4U;
 800523c:	3203      	adds	r2, #3
    for (i = 0U; i < count32b; i++)
 800523e:	0892      	lsrs	r2, r2, #2
 8005240:	f43f af4c 	beq.w	80050dc <USB_HC_StartXfer+0xd0>
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8005244:	eb00 3404 	add.w	r4, r0, r4, lsl #12
 8005248:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 800524c:	f504 5480 	add.w	r4, r4, #4096	@ 0x1000
 8005250:	f853 1b04 	ldr.w	r1, [r3], #4
    for (i = 0U; i < count32b; i++)
 8005254:	429a      	cmp	r2, r3
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8005256:	6021      	str	r1, [r4, #0]
    for (i = 0U; i < count32b; i++)
 8005258:	d1fa      	bne.n	8005250 <USB_HC_StartXfer+0x244>
 800525a:	e73f      	b.n	80050dc <USB_HC_StartXfer+0xd0>
        if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
 800525c:	693d      	ldr	r5, [r7, #16]
        len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 800525e:	1cd3      	adds	r3, r2, #3
        if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
 8005260:	b2ad      	uxth	r5, r5
 8005262:	f3c3 038f 	ubfx	r3, r3, #2, #16
 8005266:	429d      	cmp	r5, r3
 8005268:	d2e6      	bcs.n	8005238 <USB_HC_StartXfer+0x22c>
          USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;
 800526a:	6983      	ldr	r3, [r0, #24]
 800526c:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 8005270:	6183      	str	r3, [r0, #24]
 8005272:	e7e1      	b.n	8005238 <USB_HC_StartXfer+0x22c>
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS;
 8005274:	f8de 3004 	ldr.w	r3, [lr, #4]
 8005278:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
 800527c:	f8ce 3004 	str.w	r3, [lr, #4]
          break;
 8005280:	e75e      	b.n	8005140 <USB_HC_StartXfer+0x134>
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS_0;
 8005282:	f8de 3004 	ldr.w	r3, [lr, #4]
 8005286:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 800528a:	f8ce 3004 	str.w	r3, [lr, #4]
          break;
 800528e:	e757      	b.n	8005140 <USB_HC_StartXfer+0x134>
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS_Pos;
 8005290:	f8de 3004 	ldr.w	r3, [lr, #4]
 8005294:	f043 030e 	orr.w	r3, r3, #14
 8005298:	f8ce 3004 	str.w	r3, [lr, #4]
          break;
 800529c:	e750      	b.n	8005140 <USB_HC_StartXfer+0x134>
          USBx_HC((uint32_t)ch_num)->HCSPLT |= USB_OTG_HCSPLT_XACTPOS_1;
 800529e:	f8de 3004 	ldr.w	r3, [lr, #4]
 80052a2:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80052a6:	f8ce 3004 	str.w	r3, [lr, #4]
          break;
 80052aa:	e749      	b.n	8005140 <USB_HC_StartXfer+0x134>
          if ((hc->iso_splt_xactPos == HCSPLT_BEGIN) || (hc->iso_splt_xactPos == HCSPLT_MIDDLE))
 80052ac:	68cb      	ldr	r3, [r1, #12]
        if (hc->xfer_len > ISO_SPLT_MPS)
 80052ae:	2fbc      	cmp	r7, #188	@ 0xbc
          if ((hc->iso_splt_xactPos == HCSPLT_BEGIN) || (hc->iso_splt_xactPos == HCSPLT_MIDDLE))
 80052b0:	f103 33ff 	add.w	r3, r3, #4294967295
        if (hc->xfer_len > ISO_SPLT_MPS)
 80052b4:	d919      	bls.n	80052ea <USB_HC_StartXfer+0x2de>
          if ((hc->iso_splt_xactPos == HCSPLT_BEGIN) || (hc->iso_splt_xactPos == HCSPLT_MIDDLE))
 80052b6:	2b01      	cmp	r3, #1
          hc->XferSize = hc->max_packet;
 80052b8:	8a8f      	ldrh	r7, [r1, #20]
          if ((hc->iso_splt_xactPos == HCSPLT_BEGIN) || (hc->iso_splt_xactPos == HCSPLT_MIDDLE))
 80052ba:	bf8c      	ite	hi
 80052bc:	2301      	movhi	r3, #1
 80052be:	2302      	movls	r3, #2
          hc->XferSize = hc->max_packet;
 80052c0:	e9c1 7707 	strd	r7, r7, [r1, #28]
            hc->iso_splt_xactPos = HCSPLT_BEGIN;
 80052c4:	60cb      	str	r3, [r1, #12]
 80052c6:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80052ca:	e6cc      	b.n	8005066 <USB_HC_StartXfer+0x5a>
        if ((dma == 1U) && (hc->xfer_len > hc->max_packet))
 80052cc:	8a8b      	ldrh	r3, [r1, #20]
 80052ce:	42bb      	cmp	r3, r7
 80052d0:	f4bf af6f 	bcs.w	80051b2 <USB_HC_StartXfer+0x1a6>
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 80052d4:	f443 2700 	orr.w	r7, r3, #524288	@ 0x80000
          hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 80052d8:	61cb      	str	r3, [r1, #28]
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
 80052da:	7d8b      	ldrb	r3, [r1, #22]
 80052dc:	075b      	lsls	r3, r3, #29
 80052de:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 80052e2:	433b      	orrs	r3, r7
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 80052e4:	f8ce 3010 	str.w	r3, [lr, #16]
  if (dma != 0U)
 80052e8:	e6c6      	b.n	8005078 <USB_HC_StartXfer+0x6c>
          if ((hc->iso_splt_xactPos != HCSPLT_BEGIN) && (hc->iso_splt_xactPos != HCSPLT_MIDDLE))
 80052ea:	2b01      	cmp	r3, #1
          hc->XferSize = hc->xfer_len;
 80052ec:	61cf      	str	r7, [r1, #28]
            hc->iso_splt_xactPos = HCSPLT_FULL;
 80052ee:	bf8c      	ite	hi
 80052f0:	2304      	movhi	r3, #4
            hc->iso_splt_xactPos = HCSPLT_END;
 80052f2:	2303      	movls	r3, #3
 80052f4:	60cb      	str	r3, [r1, #12]
 80052f6:	e75f      	b.n	80051b8 <USB_HC_StartXfer+0x1ac>
 80052f8:	80080000 	.word	0x80080000

080052fc <USB_HC_ReadInterrupt>:
  return ((USBx_HOST->HAINT) & 0xFFFFU);
 80052fc:	f8d0 0414 	ldr.w	r0, [r0, #1044]	@ 0x414
}
 8005300:	b280      	uxth	r0, r0
 8005302:	4770      	bx	lr

08005304 <USB_HC_Halt>:
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 8005304:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  __IO uint32_t count = 0U;
 8005308:	2300      	movs	r3, #0
{
 800530a:	b430      	push	{r4, r5}
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 800530c:	f501 6ca0 	add.w	ip, r1, #1280	@ 0x500
{
 8005310:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 8005312:	9301      	str	r3, [sp, #4]
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 8005314:	f8d1 3500 	ldr.w	r3, [r1, #1280]	@ 0x500
  uint32_t ChannelEna = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) >> 31;
 8005318:	f8d1 5500 	ldr.w	r5, [r1, #1280]	@ 0x500
  uint32_t SplitEna = (USBx_HC(hcnum)->HCSPLT & USB_OTG_HCSPLT_SPLITEN) >> 31;
 800531c:	f8dc 2004 	ldr.w	r2, [ip, #4]
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 8005320:	0c9b      	lsrs	r3, r3, #18
  if ((((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == USB_OTG_GAHBCFG_DMAEN) && (SplitEna == 0U)) &&
 8005322:	6884      	ldr	r4, [r0, #8]
 8005324:	2a00      	cmp	r2, #0
 8005326:	db01      	blt.n	800532c <USB_HC_Halt+0x28>
 8005328:	06a2      	lsls	r2, r4, #26
 800532a:	d428      	bmi.n	800537e <USB_HC_Halt+0x7a>
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
 800532c:	07dc      	lsls	r4, r3, #31
 800532e:	d52a      	bpl.n	8005386 <USB_HC_Halt+0x82>
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 8005330:	f8d1 3500 	ldr.w	r3, [r1, #1280]	@ 0x500
 8005334:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8005338:	f8c1 3500 	str.w	r3, [r1, #1280]	@ 0x500
    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
 800533c:	f8d0 3410 	ldr.w	r3, [r0, #1040]	@ 0x410
 8005340:	f413 0f7f 	tst.w	r3, #16711680	@ 0xff0000
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8005344:	f8d1 3500 	ldr.w	r3, [r1, #1280]	@ 0x500
    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
 8005348:	d143      	bne.n	80053d2 <USB_HC_Halt+0xce>
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 800534a:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 800534e:	f8c1 3500 	str.w	r3, [r1, #1280]	@ 0x500
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8005352:	f8d1 3500 	ldr.w	r3, [r1, #1280]	@ 0x500
 8005356:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 800535a:	f8c1 3500 	str.w	r3, [r1, #1280]	@ 0x500
 800535e:	e003      	b.n	8005368 <USB_HC_Halt+0x64>
      } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8005360:	f8dc 3000 	ldr.w	r3, [ip]
 8005364:	2b00      	cmp	r3, #0
 8005366:	da06      	bge.n	8005376 <USB_HC_Halt+0x72>
        count++;
 8005368:	9b01      	ldr	r3, [sp, #4]
 800536a:	3301      	adds	r3, #1
 800536c:	9301      	str	r3, [sp, #4]
        if (count > 1000U)
 800536e:	9b01      	ldr	r3, [sp, #4]
 8005370:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8005374:	d9f4      	bls.n	8005360 <USB_HC_Halt+0x5c>
}
 8005376:	2000      	movs	r0, #0
 8005378:	b002      	add	sp, #8
 800537a:	bc30      	pop	{r4, r5}
 800537c:	4770      	bx	lr
  if ((((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == USB_OTG_GAHBCFG_DMAEN) && (SplitEna == 0U)) &&
 800537e:	2d00      	cmp	r5, #0
 8005380:	daf9      	bge.n	8005376 <USB_HC_Halt+0x72>
      ((ChannelEna == 0U) || (((HcEpType == HCCHAR_ISOC) || (HcEpType == HCCHAR_INTR)))))
 8005382:	07da      	lsls	r2, r3, #31
 8005384:	d4f7      	bmi.n	8005376 <USB_HC_Halt+0x72>
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 8005386:	f8d1 3500 	ldr.w	r3, [r1, #1280]	@ 0x500
 800538a:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 800538e:	f8c1 3500 	str.w	r3, [r1, #1280]	@ 0x500
    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8005392:	6883      	ldr	r3, [r0, #8]
 8005394:	069b      	lsls	r3, r3, #26
 8005396:	d424      	bmi.n	80053e2 <USB_HC_Halt+0xde>
      if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 8005398:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
 800539a:	f413 0f7f 	tst.w	r3, #16711680	@ 0xff0000
        USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 800539e:	f8d1 3500 	ldr.w	r3, [r1, #1280]	@ 0x500
      if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 80053a2:	d116      	bne.n	80053d2 <USB_HC_Halt+0xce>
        USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 80053a4:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 80053a8:	f8c1 3500 	str.w	r3, [r1, #1280]	@ 0x500
        USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 80053ac:	f8d1 3500 	ldr.w	r3, [r1, #1280]	@ 0x500
 80053b0:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80053b4:	f8c1 3500 	str.w	r3, [r1, #1280]	@ 0x500
 80053b8:	e003      	b.n	80053c2 <USB_HC_Halt+0xbe>
        } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 80053ba:	f8dc 3000 	ldr.w	r3, [ip]
 80053be:	2b00      	cmp	r3, #0
 80053c0:	dad9      	bge.n	8005376 <USB_HC_Halt+0x72>
          count++;
 80053c2:	9b01      	ldr	r3, [sp, #4]
 80053c4:	3301      	adds	r3, #1
 80053c6:	9301      	str	r3, [sp, #4]
          if (count > 1000U)
 80053c8:	9b01      	ldr	r3, [sp, #4]
 80053ca:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 80053ce:	d9f4      	bls.n	80053ba <USB_HC_Halt+0xb6>
 80053d0:	e7d1      	b.n	8005376 <USB_HC_Halt+0x72>
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 80053d2:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
}
 80053d6:	2000      	movs	r0, #0
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 80053d8:	f8c1 3500 	str.w	r3, [r1, #1280]	@ 0x500
}
 80053dc:	b002      	add	sp, #8
 80053de:	bc30      	pop	{r4, r5}
 80053e0:	4770      	bx	lr
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 80053e2:	f8d1 3500 	ldr.w	r3, [r1, #1280]	@ 0x500
}
 80053e6:	2000      	movs	r0, #0
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 80053e8:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80053ec:	f8c1 3500 	str.w	r3, [r1, #1280]	@ 0x500
}
 80053f0:	b002      	add	sp, #8
 80053f2:	bc30      	pop	{r4, r5}
 80053f4:	4770      	bx	lr
 80053f6:	bf00      	nop

080053f8 <USB_StopHost>:
  * @brief  Stop Host Core
  * @param  USBx  Selected device
  * @retval HAL state
  */
HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
{
 80053f8:	b530      	push	{r4, r5, lr}
  HAL_StatusTypeDef ret = HAL_OK;
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t count = 0U;
 80053fa:	2300      	movs	r3, #0
{
 80053fc:	b083      	sub	sp, #12
 80053fe:	4604      	mov	r4, r0
  uint32_t i;

  (void)USB_DisableGlobalInt(USBx);

  /* Flush USB FIFO */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 8005400:	2110      	movs	r1, #16
  __IO uint32_t count = 0U;
 8005402:	9301      	str	r3, [sp, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8005404:	6883      	ldr	r3, [r0, #8]
 8005406:	f023 0301 	bic.w	r3, r3, #1
 800540a:	6083      	str	r3, [r0, #8]
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 800540c:	f7ff f9c6 	bl	800479c <USB_FlushTxFifo>
 8005410:	4605      	mov	r5, r0
  {
    ret = HAL_ERROR;
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 8005412:	4620      	mov	r0, r4
 8005414:	f504 61e0 	add.w	r1, r4, #1792	@ 0x700
 8005418:	f7ff f9e8 	bl	80047ec <USB_FlushRxFifo>
 800541c:	4328      	orrs	r0, r5
 800541e:	f504 62a0 	add.w	r2, r4, #1280	@ 0x500
 8005422:	b2c0      	uxtb	r0, r0
 8005424:	4694      	mov	ip, r2
 8005426:	3800      	subs	r0, #0
 8005428:	bf18      	it	ne
 800542a:	2001      	movne	r0, #1
  }

  /* Flush out any leftover queued requests. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
 800542c:	f8dc 3000 	ldr.w	r3, [ip]
    value |=  USB_OTG_HCCHAR_CHDIS;
    value &= ~USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8005430:	f023 2380 	bic.w	r3, r3, #2147516416	@ 0x80008000
 8005434:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8005438:	f84c 3b20 	str.w	r3, [ip], #32
  for (i = 0U; i <= 15U; i++)
 800543c:	458c      	cmp	ip, r1
 800543e:	d1f5      	bne.n	800542c <USB_StopHost+0x34>
  }

  /* Halt all channels to put them into a known state. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
 8005440:	6813      	ldr	r3, [r2, #0]
    value |= USB_OTG_HCCHAR_CHDIS;
    value |= USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8005442:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8005446:	f043 4340 	orr.w	r3, r3, #3221225472	@ 0xc0000000
    USBx_HC(i)->HCCHAR = value;
 800544a:	6013      	str	r3, [r2, #0]
 800544c:	e002      	b.n	8005454 <USB_StopHost+0x5c>

      if (count > 1000U)
      {
        break;
      }
    } while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 800544e:	6813      	ldr	r3, [r2, #0]
 8005450:	2b00      	cmp	r3, #0
 8005452:	da06      	bge.n	8005462 <USB_StopHost+0x6a>
      count++;
 8005454:	9b01      	ldr	r3, [sp, #4]
 8005456:	3301      	adds	r3, #1
 8005458:	9301      	str	r3, [sp, #4]
      if (count > 1000U)
 800545a:	9b01      	ldr	r3, [sp, #4]
 800545c:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8005460:	d9f5      	bls.n	800544e <USB_StopHost+0x56>
  for (i = 0U; i <= 15U; i++)
 8005462:	3220      	adds	r2, #32
 8005464:	428a      	cmp	r2, r1
 8005466:	d1eb      	bne.n	8005440 <USB_StopHost+0x48>
  }

  /* Clear any pending Host interrupts */
  USBx_HOST->HAINT = CLEAR_INTERRUPT_MASK;
 8005468:	f04f 33ff 	mov.w	r3, #4294967295
 800546c:	f8c4 3414 	str.w	r3, [r4, #1044]	@ 0x414
  USBx->GINTSTS = CLEAR_INTERRUPT_MASK;
 8005470:	6163      	str	r3, [r4, #20]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8005472:	68a3      	ldr	r3, [r4, #8]
 8005474:	f043 0301 	orr.w	r3, r3, #1
 8005478:	60a3      	str	r3, [r4, #8]

  (void)USB_EnableGlobalInt(USBx);

  return ret;
}
 800547a:	b003      	add	sp, #12
 800547c:	bd30      	pop	{r4, r5, pc}
 800547e:	bf00      	nop

08005480 <LL_SetSystemCoreClock>:
  */
#endif /* DUAL_CORE */
void LL_SetSystemCoreClock(uint32_t CPU_Frequency)
{
  /* HCLK clock frequency */
  SystemCoreClock = CPU_Frequency;
 8005480:	4b01      	ldr	r3, [pc, #4]	@ (8005488 <LL_SetSystemCoreClock+0x8>)
 8005482:	6018      	str	r0, [r3, #0]
}
 8005484:	4770      	bx	lr
 8005486:	bf00      	nop
 8005488:	24000028 	.word	0x24000028

0800548c <USBD_SetClassConfig>:
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 800548c:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
 8005490:	b10b      	cbz	r3, 8005496 <USBD_SetClassConfig+0xa>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
 8005492:	681b      	ldr	r3, [r3, #0]
 8005494:	4718      	bx	r3
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 8005496:	4618      	mov	r0, r3
 8005498:	4770      	bx	lr
 800549a:	bf00      	nop

0800549c <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 800549c:	b508      	push	{r3, lr}
      }
    }
  }
#else
  /* Clear configuration  and De-initialize the Class process */
  if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
 800549e:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
 80054a2:	685b      	ldr	r3, [r3, #4]
 80054a4:	4798      	blx	r3
  {
    ret = USBD_FAIL;
 80054a6:	2800      	cmp	r0, #0
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 80054a8:	bf18      	it	ne
 80054aa:	2003      	movne	r0, #3
 80054ac:	bd08      	pop	{r3, pc}
 80054ae:	bf00      	nop

080054b0 <USBD_LL_SetupStage>:
  * @param  pdev: device instance
  * @param  psetup: setup packet buffer pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 80054b0:	b538      	push	{r3, r4, r5, lr}
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 80054b2:	f200 25aa 	addw	r5, r0, #682	@ 0x2aa
{
 80054b6:	4604      	mov	r4, r0
  USBD_ParseSetupRequest(&pdev->request, psetup);
 80054b8:	4628      	mov	r0, r5
 80054ba:	f000 fbfb 	bl	8005cb4 <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;

  pdev->ep0_data_len = pdev->request.wLength;
 80054be:	f8b4 32b0 	ldrh.w	r3, [r4, #688]	@ 0x2b0

  switch (pdev->request.bmRequest & 0x1FU)
 80054c2:	f894 12aa 	ldrb.w	r1, [r4, #682]	@ 0x2aa
  pdev->ep0_state = USBD_EP0_SETUP;
 80054c6:	2201      	movs	r2, #1
  pdev->ep0_data_len = pdev->request.wLength;
 80054c8:	f8c4 3298 	str.w	r3, [r4, #664]	@ 0x298
 80054cc:	f001 031f 	and.w	r3, r1, #31
  pdev->ep0_state = USBD_EP0_SETUP;
 80054d0:	f8c4 2294 	str.w	r2, [r4, #660]	@ 0x294
  switch (pdev->request.bmRequest & 0x1FU)
 80054d4:	4293      	cmp	r3, r2
 80054d6:	d00e      	beq.n	80054f6 <USBD_LL_SetupStage+0x46>
 80054d8:	2b02      	cmp	r3, #2
 80054da:	d006      	beq.n	80054ea <USBD_LL_SetupStage+0x3a>
 80054dc:	b98b      	cbnz	r3, 8005502 <USBD_LL_SetupStage+0x52>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      ret = USBD_StdDevReq(pdev, &pdev->request);
 80054de:	4629      	mov	r1, r5
 80054e0:	4620      	mov	r0, r4
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
      break;
  }

  return ret;
}
 80054e2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdDevReq(pdev, &pdev->request);
 80054e6:	f000 b94f 	b.w	8005788 <USBD_StdDevReq>
      ret = USBD_StdEPReq(pdev, &pdev->request);
 80054ea:	4629      	mov	r1, r5
 80054ec:	4620      	mov	r0, r4
}
 80054ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdEPReq(pdev, &pdev->request);
 80054f2:	f000 bb31 	b.w	8005b58 <USBD_StdEPReq>
      ret = USBD_StdItfReq(pdev, &pdev->request);
 80054f6:	4629      	mov	r1, r5
 80054f8:	4620      	mov	r0, r4
}
 80054fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdItfReq(pdev, &pdev->request);
 80054fe:	f000 baeb 	b.w	8005ad8 <USBD_StdItfReq>
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 8005502:	4620      	mov	r0, r4
 8005504:	f001 0180 	and.w	r1, r1, #128	@ 0x80
}
 8005508:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 800550c:	f001 bc12 	b.w	8006d34 <USBD_LL_StallEP>

08005510 <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 8005510:	b570      	push	{r4, r5, r6, lr}
 8005512:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret = USBD_OK;
  uint8_t idx;

  if (epnum == 0U)
 8005514:	b931      	cbnz	r1, 8005524 <USBD_LL_DataOutStage+0x14>
 8005516:	460b      	mov	r3, r1
  {
    pep = &pdev->ep_out[0];

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 8005518:	f8d0 1294 	ldr.w	r1, [r0, #660]	@ 0x294
 800551c:	2903      	cmp	r1, #3
 800551e:	d010      	beq.n	8005542 <USBD_LL_DataOutStage+0x32>
      }
    }
  }

  return USBD_OK;
}
 8005520:	2000      	movs	r0, #0
 8005522:	bd70      	pop	{r4, r5, r6, pc}
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8005524:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 8005528:	2b03      	cmp	r3, #3
 800552a:	d1f9      	bne.n	8005520 <USBD_LL_DataOutStage+0x10>
        if (pdev->pClass[idx]->DataOut != NULL)
 800552c:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
 8005530:	699b      	ldr	r3, [r3, #24]
 8005532:	2b00      	cmp	r3, #0
 8005534:	d0f4      	beq.n	8005520 <USBD_LL_DataOutStage+0x10>
          pdev->classId = idx;
 8005536:	2200      	movs	r2, #0
}
 8005538:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          pdev->classId = idx;
 800553c:	f8c0 22d4 	str.w	r2, [r0, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
 8005540:	4718      	bx	r3
      if (pep->rem_length > pep->maxpacket)
 8005542:	e9d0 1557 	ldrd	r1, r5, [r0, #348]	@ 0x15c
 8005546:	42a9      	cmp	r1, r5
 8005548:	d808      	bhi.n	800555c <USBD_LL_DataOutStage+0x4c>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800554a:	f890 229c 	ldrb.w	r2, [r0, #668]	@ 0x29c
 800554e:	2a03      	cmp	r2, #3
 8005550:	d00f      	beq.n	8005572 <USBD_LL_DataOutStage+0x62>
        (void)USBD_CtlSendStatus(pdev);
 8005552:	4620      	mov	r0, r4
 8005554:	f000 fbdc 	bl	8005d10 <USBD_CtlSendStatus>
}
 8005558:	2000      	movs	r0, #0
 800555a:	bd70      	pop	{r4, r5, r6, pc}
        pep->rem_length -= pep->maxpacket;
 800555c:	1b4b      	subs	r3, r1, r5
        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 800555e:	4611      	mov	r1, r2
 8005560:	462a      	mov	r2, r5
 8005562:	429d      	cmp	r5, r3
        pep->rem_length -= pep->maxpacket;
 8005564:	f8c0 315c 	str.w	r3, [r0, #348]	@ 0x15c
        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 8005568:	bf28      	it	cs
 800556a:	461a      	movcs	r2, r3
 800556c:	f000 fbc6 	bl	8005cfc <USBD_CtlContinueRx>
 8005570:	e7d6      	b.n	8005520 <USBD_LL_DataOutStage+0x10>
            if (pdev->pClass[idx]->EP0_RxReady != NULL)
 8005572:	f8d0 22b8 	ldr.w	r2, [r0, #696]	@ 0x2b8
 8005576:	6912      	ldr	r2, [r2, #16]
 8005578:	2a00      	cmp	r2, #0
 800557a:	d0ea      	beq.n	8005552 <USBD_LL_DataOutStage+0x42>
              pdev->classId = idx;
 800557c:	f8c0 32d4 	str.w	r3, [r0, #724]	@ 0x2d4
              pdev->pClass[idx]->EP0_RxReady(pdev);
 8005580:	4790      	blx	r2
 8005582:	e7e6      	b.n	8005552 <USBD_LL_DataOutStage+0x42>

08005584 <USBD_LL_DataInStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 8005584:	b570      	push	{r4, r5, r6, lr}
 8005586:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;
  uint8_t idx;

  if (epnum == 0U)
 8005588:	b959      	cbnz	r1, 80055a2 <USBD_LL_DataInStage+0x1e>
  {
    pep = &pdev->ep_in[0];

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 800558a:	f8d0 3294 	ldr.w	r3, [r0, #660]	@ 0x294
 800558e:	2b02      	cmp	r3, #2
 8005590:	d016      	beq.n	80055c0 <USBD_LL_DataInStage+0x3c>
          (void)USBD_CtlReceiveStatus(pdev);
        }
      }
    }

    if (pdev->dev_test_mode != 0U)
 8005592:	f894 32a0 	ldrb.w	r3, [r4, #672]	@ 0x2a0
 8005596:	b113      	cbz	r3, 800559e <USBD_LL_DataInStage+0x1a>
    {
      (void)USBD_RunTestMode(pdev);
      pdev->dev_test_mode = 0U;
 8005598:	2300      	movs	r3, #0
 800559a:	f884 32a0 	strb.w	r3, [r4, #672]	@ 0x2a0
      }
    }
  }

  return USBD_OK;
}
 800559e:	2000      	movs	r0, #0
 80055a0:	bd70      	pop	{r4, r5, r6, pc}
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80055a2:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 80055a6:	2b03      	cmp	r3, #3
 80055a8:	d1f9      	bne.n	800559e <USBD_LL_DataInStage+0x1a>
        if (pdev->pClass[idx]->DataIn != NULL)
 80055aa:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
 80055ae:	695b      	ldr	r3, [r3, #20]
 80055b0:	2b00      	cmp	r3, #0
 80055b2:	d0f4      	beq.n	800559e <USBD_LL_DataInStage+0x1a>
          pdev->classId = idx;
 80055b4:	2200      	movs	r2, #0
}
 80055b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          pdev->classId = idx;
 80055ba:	f8c0 22d4 	str.w	r2, [r0, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
 80055be:	4718      	bx	r3
      if (pep->rem_length > pep->maxpacket)
 80055c0:	e9d0 3607 	ldrd	r3, r6, [r0, #28]
 80055c4:	460d      	mov	r5, r1
 80055c6:	42b3      	cmp	r3, r6
 80055c8:	d810      	bhi.n	80055ec <USBD_LL_DataInStage+0x68>
        if ((pep->maxpacket == pep->rem_length) &&
 80055ca:	d01c      	beq.n	8005606 <USBD_LL_DataInStage+0x82>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80055cc:	f894 329c 	ldrb.w	r3, [r4, #668]	@ 0x29c
 80055d0:	2b03      	cmp	r3, #3
 80055d2:	d02b      	beq.n	800562c <USBD_LL_DataInStage+0xa8>
          (void)USBD_LL_StallEP(pdev, 0x80U);
 80055d4:	2180      	movs	r1, #128	@ 0x80
 80055d6:	4620      	mov	r0, r4
 80055d8:	f001 fbac 	bl	8006d34 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 80055dc:	4620      	mov	r0, r4
 80055de:	f000 fba3 	bl	8005d28 <USBD_CtlReceiveStatus>
    if (pdev->dev_test_mode != 0U)
 80055e2:	f894 32a0 	ldrb.w	r3, [r4, #672]	@ 0x2a0
 80055e6:	2b00      	cmp	r3, #0
 80055e8:	d0d9      	beq.n	800559e <USBD_LL_DataInStage+0x1a>
 80055ea:	e7d5      	b.n	8005598 <USBD_LL_DataInStage+0x14>
        pep->rem_length -= pep->maxpacket;
 80055ec:	1b9b      	subs	r3, r3, r6
        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 80055ee:	4611      	mov	r1, r2
        pep->rem_length -= pep->maxpacket;
 80055f0:	61c3      	str	r3, [r0, #28]
        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 80055f2:	461a      	mov	r2, r3
 80055f4:	f000 fb78 	bl	8005ce8 <USBD_CtlContinueSendData>
        (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80055f8:	462b      	mov	r3, r5
 80055fa:	462a      	mov	r2, r5
 80055fc:	4629      	mov	r1, r5
 80055fe:	4620      	mov	r0, r4
 8005600:	f001 fbdc 	bl	8006dbc <USBD_LL_PrepareReceive>
 8005604:	e7c5      	b.n	8005592 <USBD_LL_DataInStage+0xe>
            (pep->total_length >= pep->maxpacket) &&
 8005606:	6982      	ldr	r2, [r0, #24]
        if ((pep->maxpacket == pep->rem_length) &&
 8005608:	4293      	cmp	r3, r2
 800560a:	d8df      	bhi.n	80055cc <USBD_LL_DataInStage+0x48>
            (pep->total_length >= pep->maxpacket) &&
 800560c:	f8d0 3298 	ldr.w	r3, [r0, #664]	@ 0x298
 8005610:	429a      	cmp	r2, r3
 8005612:	d2db      	bcs.n	80055cc <USBD_LL_DataInStage+0x48>
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 8005614:	460a      	mov	r2, r1
 8005616:	f000 fb67 	bl	8005ce8 <USBD_CtlContinueSendData>
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 800561a:	462b      	mov	r3, r5
 800561c:	462a      	mov	r2, r5
 800561e:	4629      	mov	r1, r5
 8005620:	4620      	mov	r0, r4
          pdev->ep0_data_len = 0U;
 8005622:	f8c4 5298 	str.w	r5, [r4, #664]	@ 0x298
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8005626:	f001 fbc9 	bl	8006dbc <USBD_LL_PrepareReceive>
 800562a:	e7b2      	b.n	8005592 <USBD_LL_DataInStage+0xe>
            if (pdev->pClass[0]->EP0_TxSent != NULL)
 800562c:	f8d4 32b8 	ldr.w	r3, [r4, #696]	@ 0x2b8
 8005630:	68db      	ldr	r3, [r3, #12]
 8005632:	2b00      	cmp	r3, #0
 8005634:	d0ce      	beq.n	80055d4 <USBD_LL_DataInStage+0x50>
              pdev->classId = 0U;
 8005636:	2200      	movs	r2, #0
              pdev->pClass[0]->EP0_TxSent(pdev);
 8005638:	4620      	mov	r0, r4
              pdev->classId = 0U;
 800563a:	f8c4 22d4 	str.w	r2, [r4, #724]	@ 0x2d4
              pdev->pClass[0]->EP0_TxSent(pdev);
 800563e:	4798      	blx	r3
 8005640:	e7c8      	b.n	80055d4 <USBD_LL_DataInStage+0x50>
 8005642:	bf00      	nop

08005644 <USBD_LL_Reset>:
  *         Handle Reset event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 8005644:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USBD_StatusTypeDef ret = USBD_OK;

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
  pdev->ep0_state = USBD_EP0_IDLE;
 8005646:	2100      	movs	r1, #0
  pdev->dev_state = USBD_STATE_DEFAULT;
 8005648:	2201      	movs	r2, #1
      }
    }
  }
#else

  if (pdev->pClass[0] != NULL)
 800564a:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
{
 800564e:	4604      	mov	r4, r0
  pdev->dev_state = USBD_STATE_DEFAULT;
 8005650:	f880 229c 	strb.w	r2, [r0, #668]	@ 0x29c
  pdev->dev_config = 0U;
 8005654:	6041      	str	r1, [r0, #4]
  pdev->ep0_state = USBD_EP0_IDLE;
 8005656:	f8c0 1294 	str.w	r1, [r0, #660]	@ 0x294
  pdev->dev_remote_wakeup = 0U;
 800565a:	f8c0 12a4 	str.w	r1, [r0, #676]	@ 0x2a4
  pdev->dev_test_mode = 0U;
 800565e:	f880 12a0 	strb.w	r1, [r0, #672]	@ 0x2a0
  if (pdev->pClass[0] != NULL)
 8005662:	b11b      	cbz	r3, 800566c <USBD_LL_Reset+0x28>
  {
    if (pdev->pClass[0]->DeInit != NULL)
 8005664:	685b      	ldr	r3, [r3, #4]
 8005666:	b10b      	cbz	r3, 800566c <USBD_LL_Reset+0x28>
    {
      if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
 8005668:	4798      	blx	r3
 800566a:	b9b0      	cbnz	r0, 800569a <USBD_LL_Reset+0x56>
  USBD_StatusTypeDef ret = USBD_OK;
 800566c:	2700      	movs	r7, #0
    }
  }
#endif /* USE_USBD_COMPOSITE */

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800566e:	2200      	movs	r2, #0
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8005670:	2540      	movs	r5, #64	@ 0x40
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 8005672:	2601      	movs	r6, #1
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8005674:	2340      	movs	r3, #64	@ 0x40
 8005676:	4611      	mov	r1, r2
 8005678:	4620      	mov	r0, r4
 800567a:	f001 fb4d 	bl	8006d18 <USBD_LL_OpenEP>

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800567e:	462b      	mov	r3, r5
 8005680:	2200      	movs	r2, #0
 8005682:	2180      	movs	r1, #128	@ 0x80
 8005684:	4620      	mov	r0, r4
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8005686:	f8c4 5160 	str.w	r5, [r4, #352]	@ 0x160
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 800568a:	f8a4 6164 	strh.w	r6, [r4, #356]	@ 0x164
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800568e:	f001 fb43 	bl	8006d18 <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;

  return ret;
}
 8005692:	4638      	mov	r0, r7
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 8005694:	84a6      	strh	r6, [r4, #36]	@ 0x24
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8005696:	6225      	str	r5, [r4, #32]
}
 8005698:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ret = USBD_FAIL;
 800569a:	2703      	movs	r7, #3
 800569c:	e7e7      	b.n	800566e <USBD_LL_Reset+0x2a>
 800569e:	bf00      	nop

080056a0 <USBD_LL_SetSpeed>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 80056a0:	4603      	mov	r3, r0
  pdev->dev_speed = speed;

  return USBD_OK;
}
 80056a2:	2000      	movs	r0, #0
  pdev->dev_speed = speed;
 80056a4:	7419      	strb	r1, [r3, #16]
}
 80056a6:	4770      	bx	lr

080056a8 <USBD_LL_Suspend>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state != USBD_STATE_SUSPENDED)
 80056a8:	f890 229c 	ldrb.w	r2, [r0, #668]	@ 0x29c
{
 80056ac:	4603      	mov	r3, r0
  if (pdev->dev_state != USBD_STATE_SUSPENDED)
 80056ae:	2a04      	cmp	r2, #4
 80056b0:	d004      	beq.n	80056bc <USBD_LL_Suspend+0x14>
  {
    pdev->dev_old_state = pdev->dev_state;
 80056b2:	f890 229c 	ldrb.w	r2, [r0, #668]	@ 0x29c
 80056b6:	b2d2      	uxtb	r2, r2
 80056b8:	f880 229d 	strb.w	r2, [r0, #669]	@ 0x29d
  }

  pdev->dev_state = USBD_STATE_SUSPENDED;
 80056bc:	2204      	movs	r2, #4

  return USBD_OK;
}
 80056be:	2000      	movs	r0, #0
  pdev->dev_state = USBD_STATE_SUSPENDED;
 80056c0:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
}
 80056c4:	4770      	bx	lr
 80056c6:	bf00      	nop

080056c8 <USBD_LL_Resume>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 80056c8:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 80056cc:	2b04      	cmp	r3, #4
 80056ce:	d104      	bne.n	80056da <USBD_LL_Resume+0x12>
  {
    pdev->dev_state = pdev->dev_old_state;
 80056d0:	f890 329d 	ldrb.w	r3, [r0, #669]	@ 0x29d
 80056d4:	b2db      	uxtb	r3, r3
 80056d6:	f880 329c 	strb.w	r3, [r0, #668]	@ 0x29c
  }

  return USBD_OK;
}
 80056da:	2000      	movs	r0, #0
 80056dc:	4770      	bx	lr
 80056de:	bf00      	nop

080056e0 <USBD_LL_SOF>:
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
  /* The SOF event can be distributed for all classes that support it */
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80056e0:	f890 229c 	ldrb.w	r2, [r0, #668]	@ 0x29c
 80056e4:	2a03      	cmp	r2, #3
 80056e6:	d001      	beq.n	80056ec <USBD_LL_SOF+0xc>
    }
#endif /* USE_USBD_COMPOSITE */
  }

  return USBD_OK;
}
 80056e8:	2000      	movs	r0, #0
 80056ea:	4770      	bx	lr
{
 80056ec:	b508      	push	{r3, lr}
    if (pdev->pClass[0] != NULL)
 80056ee:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
 80056f2:	b113      	cbz	r3, 80056fa <USBD_LL_SOF+0x1a>
      if (pdev->pClass[0]->SOF != NULL)
 80056f4:	69db      	ldr	r3, [r3, #28]
 80056f6:	b103      	cbz	r3, 80056fa <USBD_LL_SOF+0x1a>
        (void)pdev->pClass[0]->SOF(pdev);
 80056f8:	4798      	blx	r3
}
 80056fa:	2000      	movs	r0, #0
 80056fc:	bd08      	pop	{r3, pc}
 80056fe:	bf00      	nop

08005700 <USBD_LL_IsoINIncomplete>:
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
                                           uint8_t epnum)
{
  if (pdev->pClass[pdev->classId] == NULL)
 8005700:	f8d0 22d4 	ldr.w	r2, [r0, #724]	@ 0x2d4
 8005704:	32ae      	adds	r2, #174	@ 0xae
 8005706:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 800570a:	b162      	cbz	r2, 8005726 <USBD_LL_IsoINIncomplete+0x26>
{
 800570c:	b508      	push	{r3, lr}
  {
    return USBD_FAIL;
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800570e:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 8005712:	2b03      	cmp	r3, #3
 8005714:	d001      	beq.n	800571a <USBD_LL_IsoINIncomplete+0x1a>
    {
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
    }
  }

  return USBD_OK;
 8005716:	2000      	movs	r0, #0
}
 8005718:	bd08      	pop	{r3, pc}
    if (pdev->pClass[pdev->classId]->IsoINIncomplete != NULL)
 800571a:	6a13      	ldr	r3, [r2, #32]
 800571c:	2b00      	cmp	r3, #0
 800571e:	d0fa      	beq.n	8005716 <USBD_LL_IsoINIncomplete+0x16>
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
 8005720:	4798      	blx	r3
  return USBD_OK;
 8005722:	2000      	movs	r0, #0
}
 8005724:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 8005726:	2003      	movs	r0, #3
}
 8005728:	4770      	bx	lr
 800572a:	bf00      	nop

0800572c <USBD_LL_IsoOUTIncomplete>:
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
                                            uint8_t epnum)
{
  if (pdev->pClass[pdev->classId] == NULL)
 800572c:	f8d0 22d4 	ldr.w	r2, [r0, #724]	@ 0x2d4
 8005730:	32ae      	adds	r2, #174	@ 0xae
 8005732:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 8005736:	b162      	cbz	r2, 8005752 <USBD_LL_IsoOUTIncomplete+0x26>
{
 8005738:	b508      	push	{r3, lr}
  {
    return USBD_FAIL;
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800573a:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 800573e:	2b03      	cmp	r3, #3
 8005740:	d001      	beq.n	8005746 <USBD_LL_IsoOUTIncomplete+0x1a>
    {
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
    }
  }

  return USBD_OK;
 8005742:	2000      	movs	r0, #0
}
 8005744:	bd08      	pop	{r3, pc}
    if (pdev->pClass[pdev->classId]->IsoOUTIncomplete != NULL)
 8005746:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 8005748:	2b00      	cmp	r3, #0
 800574a:	d0fa      	beq.n	8005742 <USBD_LL_IsoOUTIncomplete+0x16>
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
 800574c:	4798      	blx	r3
  return USBD_OK;
 800574e:	2000      	movs	r0, #0
}
 8005750:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 8005752:	2003      	movs	r0, #3
}
 8005754:	4770      	bx	lr
 8005756:	bf00      	nop

08005758 <USBD_LL_DevConnected>:
  * @brief  USBD_LL_DevConnected
  *         Handle device connection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef *pdev)
 8005758:	2000      	movs	r0, #0
 800575a:	4770      	bx	lr

0800575c <USBD_LL_DevDisconnected>:
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
  USBD_StatusTypeDef   ret = USBD_OK;

  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800575c:	2101      	movs	r1, #1
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 800575e:	f8d0 22b8 	ldr.w	r2, [r0, #696]	@ 0x2b8
  pdev->dev_state = USBD_STATE_DEFAULT;
 8005762:	f880 129c 	strb.w	r1, [r0, #668]	@ 0x29c
  if (pdev->pClass[0] != NULL)
 8005766:	b142      	cbz	r2, 800577a <USBD_LL_DevDisconnected+0x1e>
  {
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 8005768:	6852      	ldr	r2, [r2, #4]
 800576a:	7901      	ldrb	r1, [r0, #4]
{
 800576c:	b508      	push	{r3, lr}
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 800576e:	4790      	blx	r2
 8005770:	b908      	cbnz	r0, 8005776 <USBD_LL_DevDisconnected+0x1a>
  USBD_StatusTypeDef   ret = USBD_OK;
 8005772:	2000      	movs	r0, #0
    }
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 8005774:	bd08      	pop	{r3, pc}
      ret = USBD_FAIL;
 8005776:	2003      	movs	r0, #3
}
 8005778:	bd08      	pop	{r3, pc}
  USBD_StatusTypeDef   ret = USBD_OK;
 800577a:	2000      	movs	r0, #0
}
 800577c:	4770      	bx	lr
 800577e:	bf00      	nop

08005780 <USBD_CoreFindIF>:
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
#endif /* USE_USBD_COMPOSITE */
}
 8005780:	2000      	movs	r0, #0
 8005782:	4770      	bx	lr

08005784 <USBD_CoreFindEP>:
  *         return the class index relative to the selected endpoint
  * @param  pdev: device instance
  * @param  index : selected endpoint number
  * @retval index of the class using the selected endpoint number. 0xFF if no class found.
  */
uint8_t USBD_CoreFindEP(USBD_HandleTypeDef *pdev, uint8_t index)
 8005784:	2000      	movs	r0, #0
 8005786:	4770      	bx	lr

08005788 <USBD_StdDevReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8005788:	b570      	push	{r4, r5, r6, lr}
 800578a:	780b      	ldrb	r3, [r1, #0]
 800578c:	b082      	sub	sp, #8
 800578e:	460d      	mov	r5, r1
 8005790:	4604      	mov	r4, r0
  USBD_StatusTypeDef ret = USBD_OK;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8005792:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8005796:	2b20      	cmp	r3, #32
 8005798:	d028      	beq.n	80057ec <USBD_StdDevReq+0x64>
 800579a:	2b40      	cmp	r3, #64	@ 0x40
 800579c:	d026      	beq.n	80057ec <USBD_StdDevReq+0x64>
 800579e:	b15b      	cbz	r3, 80057b8 <USBD_StdDevReq+0x30>
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 80057a0:	2180      	movs	r1, #128	@ 0x80
 80057a2:	4620      	mov	r0, r4
 80057a4:	f001 fac6 	bl	8006d34 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 80057a8:	2100      	movs	r1, #0
 80057aa:	4620      	mov	r0, r4
 80057ac:	f001 fac2 	bl	8006d34 <USBD_LL_StallEP>
  USBD_StatusTypeDef ret = USBD_OK;
 80057b0:	2500      	movs	r5, #0
}
 80057b2:	4628      	mov	r0, r5
 80057b4:	b002      	add	sp, #8
 80057b6:	bd70      	pop	{r4, r5, r6, pc}
      switch (req->bRequest)
 80057b8:	784b      	ldrb	r3, [r1, #1]
 80057ba:	2b09      	cmp	r3, #9
 80057bc:	d8f0      	bhi.n	80057a0 <USBD_StdDevReq+0x18>
 80057be:	a201      	add	r2, pc, #4	@ (adr r2, 80057c4 <USBD_StdDevReq+0x3c>)
 80057c0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80057c4:	0800583d 	.word	0x0800583d
 80057c8:	08005865 	.word	0x08005865
 80057cc:	080057a1 	.word	0x080057a1
 80057d0:	08005883 	.word	0x08005883
 80057d4:	080057a1 	.word	0x080057a1
 80057d8:	0800589b 	.word	0x0800589b
 80057dc:	080058dd 	.word	0x080058dd
 80057e0:	080057a1 	.word	0x080057a1
 80057e4:	08005911 	.word	0x08005911
 80057e8:	08005805 	.word	0x08005805
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 80057ec:	f8d4 32d4 	ldr.w	r3, [r4, #724]	@ 0x2d4
 80057f0:	4629      	mov	r1, r5
 80057f2:	4620      	mov	r0, r4
 80057f4:	33ae      	adds	r3, #174	@ 0xae
 80057f6:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 80057fa:	689b      	ldr	r3, [r3, #8]
}
 80057fc:	b002      	add	sp, #8
 80057fe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 8005802:	4718      	bx	r3
  cfgidx = (uint8_t)(req->wValue);
 8005804:	7889      	ldrb	r1, [r1, #2]
 8005806:	4db3      	ldr	r5, [pc, #716]	@ (8005ad4 <USBD_StdDevReq+0x34c>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8005808:	2901      	cmp	r1, #1
  cfgidx = (uint8_t)(req->wValue);
 800580a:	7029      	strb	r1, [r5, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 800580c:	f200 8148 	bhi.w	8005aa0 <USBD_StdDevReq+0x318>
  switch (pdev->dev_state)
 8005810:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 8005814:	2b02      	cmp	r3, #2
 8005816:	b2de      	uxtb	r6, r3
 8005818:	f000 8128 	beq.w	8005a6c <USBD_StdDevReq+0x2e4>
 800581c:	2e03      	cmp	r6, #3
 800581e:	f000 8105 	beq.w	8005a2c <USBD_StdDevReq+0x2a4>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8005822:	2180      	movs	r1, #128	@ 0x80
 8005824:	f001 fa86 	bl	8006d34 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8005828:	2100      	movs	r1, #0
 800582a:	4620      	mov	r0, r4
 800582c:	f001 fa82 	bl	8006d34 <USBD_LL_StallEP>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 8005830:	7829      	ldrb	r1, [r5, #0]
 8005832:	4620      	mov	r0, r4
 8005834:	f7ff fe32 	bl	800549c <USBD_ClrClassConfig>
    return USBD_FAIL;
 8005838:	2503      	movs	r5, #3
 800583a:	e7ba      	b.n	80057b2 <USBD_StdDevReq+0x2a>
  switch (pdev->dev_state)
 800583c:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 8005840:	3b01      	subs	r3, #1
 8005842:	2b02      	cmp	r3, #2
 8005844:	d8ac      	bhi.n	80057a0 <USBD_StdDevReq+0x18>
      if (req->wLength != 0x2U)
 8005846:	88ca      	ldrh	r2, [r1, #6]
 8005848:	2a02      	cmp	r2, #2
 800584a:	d1a9      	bne.n	80057a0 <USBD_StdDevReq+0x18>
      if (pdev->dev_remote_wakeup != 0U)
 800584c:	f8d0 32a4 	ldr.w	r3, [r0, #676]	@ 0x2a4
 8005850:	4601      	mov	r1, r0
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 8005852:	2b00      	cmp	r3, #0
 8005854:	bf0c      	ite	eq
 8005856:	2301      	moveq	r3, #1
 8005858:	2303      	movne	r3, #3
 800585a:	f841 3f0c 	str.w	r3, [r1, #12]!
      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 800585e:	f000 fa35 	bl	8005ccc <USBD_CtlSendData>
      break;
 8005862:	e7a5      	b.n	80057b0 <USBD_StdDevReq+0x28>
  switch (pdev->dev_state)
 8005864:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 8005868:	3b01      	subs	r3, #1
 800586a:	2b02      	cmp	r3, #2
 800586c:	d898      	bhi.n	80057a0 <USBD_StdDevReq+0x18>
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 800586e:	884b      	ldrh	r3, [r1, #2]
 8005870:	2b01      	cmp	r3, #1
 8005872:	d19d      	bne.n	80057b0 <USBD_StdDevReq+0x28>
        pdev->dev_remote_wakeup = 0U;
 8005874:	2300      	movs	r3, #0
        (void)USBD_CtlSendStatus(pdev);
 8005876:	4620      	mov	r0, r4
        pdev->dev_remote_wakeup = 0U;
 8005878:	f8c4 32a4 	str.w	r3, [r4, #676]	@ 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 800587c:	f000 fa48 	bl	8005d10 <USBD_CtlSendStatus>
 8005880:	e796      	b.n	80057b0 <USBD_StdDevReq+0x28>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8005882:	884b      	ldrh	r3, [r1, #2]
 8005884:	2b01      	cmp	r3, #1
 8005886:	d0f6      	beq.n	8005876 <USBD_StdDevReq+0xee>
  else if (req->wValue == USB_FEATURE_TEST_MODE)
 8005888:	2b02      	cmp	r3, #2
 800588a:	d189      	bne.n	80057a0 <USBD_StdDevReq+0x18>
    pdev->dev_test_mode = (uint8_t)(req->wIndex >> 8);
 800588c:	888b      	ldrh	r3, [r1, #4]
 800588e:	0a1b      	lsrs	r3, r3, #8
 8005890:	f880 32a0 	strb.w	r3, [r0, #672]	@ 0x2a0
    (void)USBD_CtlSendStatus(pdev);
 8005894:	f000 fa3c 	bl	8005d10 <USBD_CtlSendStatus>
 8005898:	e78a      	b.n	80057b0 <USBD_StdDevReq+0x28>
  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 800589a:	888b      	ldrh	r3, [r1, #4]
 800589c:	2b00      	cmp	r3, #0
 800589e:	f47f af7f 	bne.w	80057a0 <USBD_StdDevReq+0x18>
 80058a2:	88cb      	ldrh	r3, [r1, #6]
 80058a4:	2b00      	cmp	r3, #0
 80058a6:	f47f af7b 	bne.w	80057a0 <USBD_StdDevReq+0x18>
 80058aa:	884b      	ldrh	r3, [r1, #2]
 80058ac:	2b7f      	cmp	r3, #127	@ 0x7f
 80058ae:	f63f af77 	bhi.w	80057a0 <USBD_StdDevReq+0x18>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80058b2:	f890 229c 	ldrb.w	r2, [r0, #668]	@ 0x29c
 80058b6:	2a03      	cmp	r2, #3
 80058b8:	f43f af72 	beq.w	80057a0 <USBD_StdDevReq+0x18>
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 80058bc:	b2dd      	uxtb	r5, r3
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 80058be:	4629      	mov	r1, r5
      pdev->dev_address = dev_addr;
 80058c0:	f880 529e 	strb.w	r5, [r0, #670]	@ 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 80058c4:	f001 fa62 	bl	8006d8c <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 80058c8:	4620      	mov	r0, r4
 80058ca:	f000 fa21 	bl	8005d10 <USBD_CtlSendStatus>
      if (dev_addr != 0U)
 80058ce:	2d00      	cmp	r5, #0
 80058d0:	f000 80fc 	beq.w	8005acc <USBD_StdDevReq+0x344>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 80058d4:	2302      	movs	r3, #2
 80058d6:	f884 329c 	strb.w	r3, [r4, #668]	@ 0x29c
 80058da:	e769      	b.n	80057b0 <USBD_StdDevReq+0x28>
  switch (req->wValue >> 8)
 80058dc:	884a      	ldrh	r2, [r1, #2]
  uint16_t len = 0U;
 80058de:	2100      	movs	r1, #0
  switch (req->wValue >> 8)
 80058e0:	0a13      	lsrs	r3, r2, #8
  uint16_t len = 0U;
 80058e2:	f8ad 1006 	strh.w	r1, [sp, #6]
  switch (req->wValue >> 8)
 80058e6:	3b01      	subs	r3, #1
 80058e8:	2b06      	cmp	r3, #6
 80058ea:	f63f af59 	bhi.w	80057a0 <USBD_StdDevReq+0x18>
 80058ee:	a101      	add	r1, pc, #4	@ (adr r1, 80058f4 <USBD_StdDevReq+0x16c>)
 80058f0:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 80058f4:	080059a5 	.word	0x080059a5
 80058f8:	0800598b 	.word	0x0800598b
 80058fc:	080059b5 	.word	0x080059b5
 8005900:	080057a1 	.word	0x080057a1
 8005904:	080057a1 	.word	0x080057a1
 8005908:	08005975 	.word	0x08005975
 800590c:	08005939 	.word	0x08005939
  if (req->wLength != 1U)
 8005910:	88ca      	ldrh	r2, [r1, #6]
 8005912:	2a01      	cmp	r2, #1
 8005914:	f47f af44 	bne.w	80057a0 <USBD_StdDevReq+0x18>
    switch (pdev->dev_state)
 8005918:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 800591c:	2b02      	cmp	r3, #2
 800591e:	b2d9      	uxtb	r1, r3
 8005920:	f200 80b7 	bhi.w	8005a92 <USBD_StdDevReq+0x30a>
 8005924:	2900      	cmp	r1, #0
 8005926:	f43f af3b 	beq.w	80057a0 <USBD_StdDevReq+0x18>
        pdev->dev_default_config = 0U;
 800592a:	4601      	mov	r1, r0
 800592c:	2300      	movs	r3, #0
 800592e:	f841 3f08 	str.w	r3, [r1, #8]!
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 8005932:	f000 f9cb 	bl	8005ccc <USBD_CtlSendData>
        break;
 8005936:	e73b      	b.n	80057b0 <USBD_StdDevReq+0x28>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8005938:	7c03      	ldrb	r3, [r0, #16]
 800593a:	2b00      	cmp	r3, #0
 800593c:	f47f af30 	bne.w	80057a0 <USBD_StdDevReq+0x18>
          pbuf = (uint8_t *)pdev->pClass[0]->GetOtherSpeedConfigDescriptor(&len);
 8005940:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
 8005944:	f10d 0006 	add.w	r0, sp, #6
 8005948:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800594a:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 800594c:	2307      	movs	r3, #7
 800594e:	7043      	strb	r3, [r0, #1]
  if (req->wLength != 0U)
 8005950:	88eb      	ldrh	r3, [r5, #6]
 8005952:	2b00      	cmp	r3, #0
 8005954:	d066      	beq.n	8005a24 <USBD_StdDevReq+0x29c>
    if (len != 0U)
 8005956:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 800595a:	2a00      	cmp	r2, #0
 800595c:	f43f af20 	beq.w	80057a0 <USBD_StdDevReq+0x18>
      len = MIN(len, req->wLength);
 8005960:	429a      	cmp	r2, r3
      (void)USBD_CtlSendData(pdev, pbuf, len);
 8005962:	4601      	mov	r1, r0
 8005964:	4620      	mov	r0, r4
      len = MIN(len, req->wLength);
 8005966:	bf28      	it	cs
 8005968:	461a      	movcs	r2, r3
 800596a:	f8ad 2006 	strh.w	r2, [sp, #6]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 800596e:	f000 f9ad 	bl	8005ccc <USBD_CtlSendData>
 8005972:	e71d      	b.n	80057b0 <USBD_StdDevReq+0x28>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8005974:	7c03      	ldrb	r3, [r0, #16]
 8005976:	2b00      	cmp	r3, #0
 8005978:	f47f af12 	bne.w	80057a0 <USBD_StdDevReq+0x18>
          pbuf = (uint8_t *)pdev->pClass[0]->GetDeviceQualifierDescriptor(&len);
 800597c:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
 8005980:	f10d 0006 	add.w	r0, sp, #6
 8005984:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005986:	4798      	blx	r3
  if (err != 0U)
 8005988:	e7e2      	b.n	8005950 <USBD_StdDevReq+0x1c8>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 800598a:	7c02      	ldrb	r2, [r0, #16]
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 800598c:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8005990:	2a00      	cmp	r2, #0
 8005992:	f040 808d 	bne.w	8005ab0 <USBD_StdDevReq+0x328>
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 8005996:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8005998:	f10d 0006 	add.w	r0, sp, #6
 800599c:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 800599e:	2302      	movs	r3, #2
 80059a0:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 80059a2:	e7d5      	b.n	8005950 <USBD_StdDevReq+0x1c8>
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 80059a4:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 80059a8:	f10d 0106 	add.w	r1, sp, #6
 80059ac:	7c00      	ldrb	r0, [r0, #16]
 80059ae:	681b      	ldr	r3, [r3, #0]
 80059b0:	4798      	blx	r3
  if (err != 0U)
 80059b2:	e7cd      	b.n	8005950 <USBD_StdDevReq+0x1c8>
      switch ((uint8_t)(req->wValue))
 80059b4:	b2d2      	uxtb	r2, r2
 80059b6:	2a05      	cmp	r2, #5
 80059b8:	f63f aef2 	bhi.w	80057a0 <USBD_StdDevReq+0x18>
 80059bc:	e8df f002 	tbb	[pc, r2]
 80059c0:	141a2026 	.word	0x141a2026
 80059c4:	030e      	.short	0x030e
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 80059c6:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 80059ca:	699b      	ldr	r3, [r3, #24]
 80059cc:	2b00      	cmp	r3, #0
 80059ce:	f43f aee7 	beq.w	80057a0 <USBD_StdDevReq+0x18>
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 80059d2:	f10d 0106 	add.w	r1, sp, #6
 80059d6:	7c20      	ldrb	r0, [r4, #16]
 80059d8:	4798      	blx	r3
  if (err != 0U)
 80059da:	e7b9      	b.n	8005950 <USBD_StdDevReq+0x1c8>
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 80059dc:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 80059e0:	695b      	ldr	r3, [r3, #20]
 80059e2:	2b00      	cmp	r3, #0
 80059e4:	d1f5      	bne.n	80059d2 <USBD_StdDevReq+0x24a>
 80059e6:	e6db      	b.n	80057a0 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 80059e8:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 80059ec:	691b      	ldr	r3, [r3, #16]
 80059ee:	2b00      	cmp	r3, #0
 80059f0:	d1ef      	bne.n	80059d2 <USBD_StdDevReq+0x24a>
 80059f2:	e6d5      	b.n	80057a0 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 80059f4:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 80059f8:	68db      	ldr	r3, [r3, #12]
 80059fa:	2b00      	cmp	r3, #0
 80059fc:	d1e9      	bne.n	80059d2 <USBD_StdDevReq+0x24a>
 80059fe:	e6cf      	b.n	80057a0 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 8005a00:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 8005a04:	689b      	ldr	r3, [r3, #8]
 8005a06:	2b00      	cmp	r3, #0
 8005a08:	d1e3      	bne.n	80059d2 <USBD_StdDevReq+0x24a>
 8005a0a:	e6c9      	b.n	80057a0 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 8005a0c:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 8005a10:	685b      	ldr	r3, [r3, #4]
 8005a12:	2b00      	cmp	r3, #0
 8005a14:	d1dd      	bne.n	80059d2 <USBD_StdDevReq+0x24a>
 8005a16:	e6c3      	b.n	80057a0 <USBD_StdDevReq+0x18>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8005a18:	2302      	movs	r3, #2
        pdev->dev_config = cfgidx;
 8005a1a:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8005a1c:	f880 329c 	strb.w	r3, [r0, #668]	@ 0x29c
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 8005a20:	f7ff fd3c 	bl	800549c <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
 8005a24:	4620      	mov	r0, r4
 8005a26:	f000 f973 	bl	8005d10 <USBD_CtlSendStatus>
 8005a2a:	e6c1      	b.n	80057b0 <USBD_StdDevReq+0x28>
      if (cfgidx == 0U)
 8005a2c:	2900      	cmp	r1, #0
 8005a2e:	d0f3      	beq.n	8005a18 <USBD_StdDevReq+0x290>
      else if (cfgidx != pdev->dev_config)
 8005a30:	6841      	ldr	r1, [r0, #4]
 8005a32:	2901      	cmp	r1, #1
 8005a34:	d0f6      	beq.n	8005a24 <USBD_StdDevReq+0x29c>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 8005a36:	b2c9      	uxtb	r1, r1
 8005a38:	f7ff fd30 	bl	800549c <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 8005a3c:	7829      	ldrb	r1, [r5, #0]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 8005a3e:	4620      	mov	r0, r4
        pdev->dev_config = cfgidx;
 8005a40:	6061      	str	r1, [r4, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 8005a42:	f7ff fd23 	bl	800548c <USBD_SetClassConfig>
        if (ret != USBD_OK)
 8005a46:	4605      	mov	r5, r0
 8005a48:	2800      	cmp	r0, #0
 8005a4a:	d0eb      	beq.n	8005a24 <USBD_StdDevReq+0x29c>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8005a4c:	2180      	movs	r1, #128	@ 0x80
 8005a4e:	4620      	mov	r0, r4
 8005a50:	f001 f970 	bl	8006d34 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8005a54:	2100      	movs	r1, #0
 8005a56:	4620      	mov	r0, r4
 8005a58:	f001 f96c 	bl	8006d34 <USBD_LL_StallEP>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 8005a5c:	7921      	ldrb	r1, [r4, #4]
 8005a5e:	4620      	mov	r0, r4
 8005a60:	f7ff fd1c 	bl	800549c <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8005a64:	2302      	movs	r3, #2
 8005a66:	f884 329c 	strb.w	r3, [r4, #668]	@ 0x29c
 8005a6a:	e6a2      	b.n	80057b2 <USBD_StdDevReq+0x2a>
      if (cfgidx != 0U)
 8005a6c:	2900      	cmp	r1, #0
 8005a6e:	d0d9      	beq.n	8005a24 <USBD_StdDevReq+0x29c>
        pdev->dev_config = cfgidx;
 8005a70:	2101      	movs	r1, #1
 8005a72:	6041      	str	r1, [r0, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 8005a74:	f7ff fd0a 	bl	800548c <USBD_SetClassConfig>
        if (ret != USBD_OK)
 8005a78:	4605      	mov	r5, r0
 8005a7a:	b300      	cbz	r0, 8005abe <USBD_StdDevReq+0x336>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8005a7c:	2180      	movs	r1, #128	@ 0x80
 8005a7e:	4620      	mov	r0, r4
 8005a80:	f001 f958 	bl	8006d34 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8005a84:	2100      	movs	r1, #0
 8005a86:	4620      	mov	r0, r4
 8005a88:	f001 f954 	bl	8006d34 <USBD_LL_StallEP>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8005a8c:	f884 629c 	strb.w	r6, [r4, #668]	@ 0x29c
 8005a90:	e68f      	b.n	80057b2 <USBD_StdDevReq+0x2a>
    switch (pdev->dev_state)
 8005a92:	2903      	cmp	r1, #3
 8005a94:	f47f ae84 	bne.w	80057a0 <USBD_StdDevReq+0x18>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 8005a98:	1d01      	adds	r1, r0, #4
 8005a9a:	f000 f917 	bl	8005ccc <USBD_CtlSendData>
        break;
 8005a9e:	e687      	b.n	80057b0 <USBD_StdDevReq+0x28>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8005aa0:	2180      	movs	r1, #128	@ 0x80
 8005aa2:	f001 f947 	bl	8006d34 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8005aa6:	2100      	movs	r1, #0
 8005aa8:	4620      	mov	r0, r4
 8005aaa:	f001 f943 	bl	8006d34 <USBD_LL_StallEP>
}
 8005aae:	e6c3      	b.n	8005838 <USBD_StdDevReq+0xb0>
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
 8005ab0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8005ab2:	f10d 0006 	add.w	r0, sp, #6
 8005ab6:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8005ab8:	2302      	movs	r3, #2
 8005aba:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 8005abc:	e748      	b.n	8005950 <USBD_StdDevReq+0x1c8>
          (void)USBD_CtlSendStatus(pdev);
 8005abe:	4620      	mov	r0, r4
 8005ac0:	f000 f926 	bl	8005d10 <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
 8005ac4:	2303      	movs	r3, #3
 8005ac6:	f884 329c 	strb.w	r3, [r4, #668]	@ 0x29c
 8005aca:	e671      	b.n	80057b0 <USBD_StdDevReq+0x28>
        pdev->dev_state = USBD_STATE_DEFAULT;
 8005acc:	2301      	movs	r3, #1
 8005ace:	f884 329c 	strb.w	r3, [r4, #668]	@ 0x29c
 8005ad2:	e66d      	b.n	80057b0 <USBD_StdDevReq+0x28>
 8005ad4:	24000358 	.word	0x24000358

08005ad8 <USBD_StdItfReq>:
{
 8005ad8:	b538      	push	{r3, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8005ada:	780b      	ldrb	r3, [r1, #0]
{
 8005adc:	460d      	mov	r5, r1
 8005ade:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8005ae0:	065a      	lsls	r2, r3, #25
 8005ae2:	d50d      	bpl.n	8005b00 <USBD_StdItfReq+0x28>
 8005ae4:	f003 0260 	and.w	r2, r3, #96	@ 0x60
 8005ae8:	2a40      	cmp	r2, #64	@ 0x40
 8005aea:	d009      	beq.n	8005b00 <USBD_StdItfReq+0x28>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8005aec:	2180      	movs	r1, #128	@ 0x80
 8005aee:	f001 f921 	bl	8006d34 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8005af2:	2100      	movs	r1, #0
 8005af4:	4620      	mov	r0, r4
 8005af6:	f001 f91d 	bl	8006d34 <USBD_LL_StallEP>
  USBD_StatusTypeDef ret = USBD_OK;
 8005afa:	2500      	movs	r5, #0
}
 8005afc:	4628      	mov	r0, r5
 8005afe:	bd38      	pop	{r3, r4, r5, pc}
      switch (pdev->dev_state)
 8005b00:	f894 329c 	ldrb.w	r3, [r4, #668]	@ 0x29c
 8005b04:	3b01      	subs	r3, #1
 8005b06:	2b02      	cmp	r3, #2
 8005b08:	d802      	bhi.n	8005b10 <USBD_StdItfReq+0x38>
          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8005b0a:	7929      	ldrb	r1, [r5, #4]
 8005b0c:	2901      	cmp	r1, #1
 8005b0e:	d908      	bls.n	8005b22 <USBD_StdItfReq+0x4a>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8005b10:	2180      	movs	r1, #128	@ 0x80
 8005b12:	4620      	mov	r0, r4
 8005b14:	f001 f90e 	bl	8006d34 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8005b18:	2100      	movs	r1, #0
 8005b1a:	4620      	mov	r0, r4
 8005b1c:	f001 f90a 	bl	8006d34 <USBD_LL_StallEP>
}
 8005b20:	e7eb      	b.n	8005afa <USBD_StdItfReq+0x22>
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
 8005b22:	4620      	mov	r0, r4
 8005b24:	f7ff fe2c 	bl	8005780 <USBD_CoreFindIF>
            if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8005b28:	b990      	cbnz	r0, 8005b50 <USBD_StdItfReq+0x78>
              if (pdev->pClass[idx]->Setup != NULL)
 8005b2a:	f8d4 32b8 	ldr.w	r3, [r4, #696]	@ 0x2b8
 8005b2e:	689b      	ldr	r3, [r3, #8]
 8005b30:	b173      	cbz	r3, 8005b50 <USBD_StdItfReq+0x78>
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8005b32:	4629      	mov	r1, r5
                pdev->classId = idx;
 8005b34:	f8c4 02d4 	str.w	r0, [r4, #724]	@ 0x2d4
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8005b38:	4620      	mov	r0, r4
 8005b3a:	4798      	blx	r3
            if ((req->wLength == 0U) && (ret == USBD_OK))
 8005b3c:	88eb      	ldrh	r3, [r5, #6]
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8005b3e:	4605      	mov	r5, r0
            if ((req->wLength == 0U) && (ret == USBD_OK))
 8005b40:	2b00      	cmp	r3, #0
 8005b42:	d1db      	bne.n	8005afc <USBD_StdItfReq+0x24>
 8005b44:	2800      	cmp	r0, #0
 8005b46:	d1d9      	bne.n	8005afc <USBD_StdItfReq+0x24>
              (void)USBD_CtlSendStatus(pdev);
 8005b48:	4620      	mov	r0, r4
 8005b4a:	f000 f8e1 	bl	8005d10 <USBD_CtlSendStatus>
 8005b4e:	e7d5      	b.n	8005afc <USBD_StdItfReq+0x24>
                ret = USBD_FAIL;
 8005b50:	2503      	movs	r5, #3
}
 8005b52:	4628      	mov	r0, r5
 8005b54:	bd38      	pop	{r3, r4, r5, pc}
 8005b56:	bf00      	nop

08005b58 <USBD_StdEPReq>:
{
 8005b58:	b530      	push	{r4, r5, lr}
 8005b5a:	460c      	mov	r4, r1
  ep_addr = LOBYTE(req->wIndex);
 8005b5c:	888a      	ldrh	r2, [r1, #4]
{
 8005b5e:	b083      	sub	sp, #12
 8005b60:	4605      	mov	r5, r0
  ep_addr = LOBYTE(req->wIndex);
 8005b62:	7823      	ldrb	r3, [r4, #0]
 8005b64:	b2d1      	uxtb	r1, r2
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8005b66:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8005b6a:	2b20      	cmp	r3, #32
 8005b6c:	d047      	beq.n	8005bfe <USBD_StdEPReq+0xa6>
 8005b6e:	2b40      	cmp	r3, #64	@ 0x40
 8005b70:	d045      	beq.n	8005bfe <USBD_StdEPReq+0xa6>
 8005b72:	b153      	cbz	r3, 8005b8a <USBD_StdEPReq+0x32>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8005b74:	2180      	movs	r1, #128	@ 0x80
 8005b76:	4628      	mov	r0, r5
 8005b78:	f001 f8dc 	bl	8006d34 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8005b7c:	2100      	movs	r1, #0
 8005b7e:	4628      	mov	r0, r5
 8005b80:	f001 f8d8 	bl	8006d34 <USBD_LL_StallEP>
}
 8005b84:	2000      	movs	r0, #0
 8005b86:	b003      	add	sp, #12
 8005b88:	bd30      	pop	{r4, r5, pc}
      switch (req->bRequest)
 8005b8a:	7863      	ldrb	r3, [r4, #1]
 8005b8c:	2b01      	cmp	r3, #1
 8005b8e:	d025      	beq.n	8005bdc <USBD_StdEPReq+0x84>
 8005b90:	2b03      	cmp	r3, #3
 8005b92:	d046      	beq.n	8005c22 <USBD_StdEPReq+0xca>
 8005b94:	2b00      	cmp	r3, #0
 8005b96:	d1ed      	bne.n	8005b74 <USBD_StdEPReq+0x1c>
          switch (pdev->dev_state)
 8005b98:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 8005b9c:	2b02      	cmp	r3, #2
 8005b9e:	b2d8      	uxtb	r0, r3
 8005ba0:	d05a      	beq.n	8005c58 <USBD_StdEPReq+0x100>
 8005ba2:	2803      	cmp	r0, #3
 8005ba4:	d1e6      	bne.n	8005b74 <USBD_StdEPReq+0x1c>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8005ba6:	f001 030f 	and.w	r3, r1, #15
              if ((ep_addr & 0x80U) == 0x80U)
 8005baa:	0612      	lsls	r2, r2, #24
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8005bac:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8005bb0:	eb05 0383 	add.w	r3, r5, r3, lsl #2
              if ((ep_addr & 0x80U) == 0x80U)
 8005bb4:	d461      	bmi.n	8005c7a <USBD_StdEPReq+0x122>
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 8005bb6:	f8b3 3164 	ldrh.w	r3, [r3, #356]	@ 0x164
 8005bba:	2b00      	cmp	r3, #0
 8005bbc:	d0da      	beq.n	8005b74 <USBD_StdEPReq+0x1c>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8005bbe:	2414      	movs	r4, #20
 8005bc0:	460b      	mov	r3, r1
 8005bc2:	fb04 5401 	mla	r4, r4, r1, r5
 8005bc6:	f504 74aa 	add.w	r4, r4, #340	@ 0x154
              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8005bca:	2b00      	cmp	r3, #0
 8005bcc:	d161      	bne.n	8005c92 <USBD_StdEPReq+0x13a>
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8005bce:	2202      	movs	r2, #2
 8005bd0:	4621      	mov	r1, r4
 8005bd2:	4628      	mov	r0, r5
                pep->status = 0x0000U;
 8005bd4:	6023      	str	r3, [r4, #0]
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8005bd6:	f000 f879 	bl	8005ccc <USBD_CtlSendData>
              break;
 8005bda:	e7d3      	b.n	8005b84 <USBD_StdEPReq+0x2c>
          switch (pdev->dev_state)
 8005bdc:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 8005be0:	2b02      	cmp	r3, #2
 8005be2:	b2da      	uxtb	r2, r3
 8005be4:	d02f      	beq.n	8005c46 <USBD_StdEPReq+0xee>
 8005be6:	2a03      	cmp	r2, #3
 8005be8:	d1c4      	bne.n	8005b74 <USBD_StdEPReq+0x1c>
              if (req->wValue == USB_FEATURE_EP_HALT)
 8005bea:	8863      	ldrh	r3, [r4, #2]
 8005bec:	2b00      	cmp	r3, #0
 8005bee:	d1c9      	bne.n	8005b84 <USBD_StdEPReq+0x2c>
                if ((ep_addr & 0x7FU) != 0x00U)
 8005bf0:	064b      	lsls	r3, r1, #25
 8005bf2:	d155      	bne.n	8005ca0 <USBD_StdEPReq+0x148>
                (void)USBD_CtlSendStatus(pdev);
 8005bf4:	4628      	mov	r0, r5
 8005bf6:	9101      	str	r1, [sp, #4]
 8005bf8:	f000 f88a 	bl	8005d10 <USBD_CtlSendStatus>
                idx = USBD_CoreFindEP(pdev, ep_addr);
 8005bfc:	9901      	ldr	r1, [sp, #4]
 8005bfe:	4628      	mov	r0, r5
 8005c00:	f7ff fdc0 	bl	8005784 <USBD_CoreFindEP>
                if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8005c04:	2800      	cmp	r0, #0
 8005c06:	d1bd      	bne.n	8005b84 <USBD_StdEPReq+0x2c>
                  if (pdev->pClass[idx]->Setup != NULL)
 8005c08:	f8d5 32b8 	ldr.w	r3, [r5, #696]	@ 0x2b8
                  pdev->classId = idx;
 8005c0c:	f8c5 02d4 	str.w	r0, [r5, #724]	@ 0x2d4
                  if (pdev->pClass[idx]->Setup != NULL)
 8005c10:	689b      	ldr	r3, [r3, #8]
 8005c12:	2b00      	cmp	r3, #0
 8005c14:	d0b6      	beq.n	8005b84 <USBD_StdEPReq+0x2c>
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8005c16:	4621      	mov	r1, r4
 8005c18:	4628      	mov	r0, r5
}
 8005c1a:	b003      	add	sp, #12
 8005c1c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8005c20:	4718      	bx	r3
          switch (pdev->dev_state)
 8005c22:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 8005c26:	2b02      	cmp	r3, #2
 8005c28:	b2da      	uxtb	r2, r3
 8005c2a:	d00c      	beq.n	8005c46 <USBD_StdEPReq+0xee>
 8005c2c:	2a03      	cmp	r2, #3
 8005c2e:	d1a1      	bne.n	8005b74 <USBD_StdEPReq+0x1c>
              if (req->wValue == USB_FEATURE_EP_HALT)
 8005c30:	8863      	ldrh	r3, [r4, #2]
 8005c32:	b923      	cbnz	r3, 8005c3e <USBD_StdEPReq+0xe6>
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 8005c34:	0648      	lsls	r0, r1, #25
 8005c36:	d002      	beq.n	8005c3e <USBD_StdEPReq+0xe6>
 8005c38:	88e3      	ldrh	r3, [r4, #6]
 8005c3a:	2b00      	cmp	r3, #0
 8005c3c:	d035      	beq.n	8005caa <USBD_StdEPReq+0x152>
              (void)USBD_CtlSendStatus(pdev);
 8005c3e:	4628      	mov	r0, r5
 8005c40:	f000 f866 	bl	8005d10 <USBD_CtlSendStatus>
              break;
 8005c44:	e79e      	b.n	8005b84 <USBD_StdEPReq+0x2c>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8005c46:	064a      	lsls	r2, r1, #25
 8005c48:	d094      	beq.n	8005b74 <USBD_StdEPReq+0x1c>
                (void)USBD_LL_StallEP(pdev, ep_addr);
 8005c4a:	f001 f873 	bl	8006d34 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 8005c4e:	2180      	movs	r1, #128	@ 0x80
 8005c50:	4628      	mov	r0, r5
 8005c52:	f001 f86f 	bl	8006d34 <USBD_LL_StallEP>
 8005c56:	e795      	b.n	8005b84 <USBD_StdEPReq+0x2c>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8005c58:	0648      	lsls	r0, r1, #25
 8005c5a:	d18b      	bne.n	8005b74 <USBD_StdEPReq+0x1c>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8005c5c:	0611      	lsls	r1, r2, #24
              pep->status = 0x0000U;
 8005c5e:	f04f 0300 	mov.w	r3, #0
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8005c62:	f04f 0202 	mov.w	r2, #2
 8005c66:	4628      	mov	r0, r5
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8005c68:	bf4c      	ite	mi
 8005c6a:	f105 0114 	addmi.w	r1, r5, #20
 8005c6e:	f505 71aa 	addpl.w	r1, r5, #340	@ 0x154
              pep->status = 0x0000U;
 8005c72:	600b      	str	r3, [r1, #0]
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8005c74:	f000 f82a 	bl	8005ccc <USBD_CtlSendData>
              break;
 8005c78:	e784      	b.n	8005b84 <USBD_StdEPReq+0x2c>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8005c7a:	8c9b      	ldrh	r3, [r3, #36]	@ 0x24
 8005c7c:	2b00      	cmp	r3, #0
 8005c7e:	f43f af79 	beq.w	8005b74 <USBD_StdEPReq+0x1c>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8005c82:	f001 037f 	and.w	r3, r1, #127	@ 0x7f
 8005c86:	1c5c      	adds	r4, r3, #1
 8005c88:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8005c8c:	eb05 0484 	add.w	r4, r5, r4, lsl #2
 8005c90:	e79b      	b.n	8005bca <USBD_StdEPReq+0x72>
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 8005c92:	4628      	mov	r0, r5
 8005c94:	f001 f866 	bl	8006d64 <USBD_LL_IsStallEP>
 8005c98:	1e03      	subs	r3, r0, #0
 8005c9a:	bf18      	it	ne
 8005c9c:	2301      	movne	r3, #1
 8005c9e:	e796      	b.n	8005bce <USBD_StdEPReq+0x76>
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 8005ca0:	9101      	str	r1, [sp, #4]
 8005ca2:	f001 f853 	bl	8006d4c <USBD_LL_ClearStallEP>
 8005ca6:	9901      	ldr	r1, [sp, #4]
 8005ca8:	e7a4      	b.n	8005bf4 <USBD_StdEPReq+0x9c>
                  (void)USBD_LL_StallEP(pdev, ep_addr);
 8005caa:	4628      	mov	r0, r5
 8005cac:	f001 f842 	bl	8006d34 <USBD_LL_StallEP>
 8005cb0:	e7c5      	b.n	8005c3e <USBD_StdEPReq+0xe6>
 8005cb2:	bf00      	nop

08005cb4 <USBD_ParseSetupRequest>:
  req->bmRequest = *(uint8_t *)(pbuff);
 8005cb4:	780b      	ldrb	r3, [r1, #0]
 8005cb6:	7003      	strb	r3, [r0, #0]
  req->bRequest = *(uint8_t *)(pbuff);
 8005cb8:	784b      	ldrb	r3, [r1, #1]
 8005cba:	7043      	strb	r3, [r0, #1]
  req->wValue = SWAPBYTE(pbuff);
 8005cbc:	884b      	ldrh	r3, [r1, #2]
 8005cbe:	8043      	strh	r3, [r0, #2]
  req->wIndex = SWAPBYTE(pbuff);
 8005cc0:	888b      	ldrh	r3, [r1, #4]
 8005cc2:	8083      	strh	r3, [r0, #4]
  req->wLength = SWAPBYTE(pbuff);
 8005cc4:	88cb      	ldrh	r3, [r1, #6]
 8005cc6:	80c3      	strh	r3, [r0, #6]
}
 8005cc8:	4770      	bx	lr
 8005cca:	bf00      	nop

08005ccc <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 8005ccc:	b510      	push	{r4, lr}
 8005cce:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 8005cd0:	2402      	movs	r4, #2
{
 8005cd2:	460a      	mov	r2, r1
#else
  pdev->ep_in[0].rem_length = len;
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8005cd4:	2100      	movs	r1, #0
  pdev->ep0_state = USBD_EP0_DATA_IN;
 8005cd6:	f8c0 4294 	str.w	r4, [r0, #660]	@ 0x294
  pdev->ep_in[0].total_length = len;
 8005cda:	e9c0 3306 	strd	r3, r3, [r0, #24]
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8005cde:	f001 f861 	bl	8006da4 <USBD_LL_Transmit>

  return USBD_OK;
}
 8005ce2:	2000      	movs	r0, #0
 8005ce4:	bd10      	pop	{r4, pc}
 8005ce6:	bf00      	nop

08005ce8 <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 8005ce8:	468c      	mov	ip, r1
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8005cea:	2100      	movs	r1, #0
{
 8005cec:	b508      	push	{r3, lr}
 8005cee:	4613      	mov	r3, r2
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8005cf0:	4662      	mov	r2, ip
 8005cf2:	f001 f857 	bl	8006da4 <USBD_LL_Transmit>

  return USBD_OK;
}
 8005cf6:	2000      	movs	r0, #0
 8005cf8:	bd08      	pop	{r3, pc}
 8005cfa:	bf00      	nop

08005cfc <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 8005cfc:	468c      	mov	ip, r1
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8005cfe:	2100      	movs	r1, #0
{
 8005d00:	b508      	push	{r3, lr}
 8005d02:	4613      	mov	r3, r2
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8005d04:	4662      	mov	r2, ip
 8005d06:	f001 f859 	bl	8006dbc <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8005d0a:	2000      	movs	r0, #0
 8005d0c:	bd08      	pop	{r3, pc}
 8005d0e:	bf00      	nop

08005d10 <USBD_CtlSendStatus>:
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8005d10:	2300      	movs	r3, #0
{
 8005d12:	b510      	push	{r4, lr}
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8005d14:	2404      	movs	r4, #4
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8005d16:	461a      	mov	r2, r3
 8005d18:	4619      	mov	r1, r3
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8005d1a:	f8c0 4294 	str.w	r4, [r0, #660]	@ 0x294
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8005d1e:	f001 f841 	bl	8006da4 <USBD_LL_Transmit>

  return USBD_OK;
}
 8005d22:	2000      	movs	r0, #0
 8005d24:	bd10      	pop	{r4, pc}
 8005d26:	bf00      	nop

08005d28 <USBD_CtlReceiveStatus>:
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8005d28:	2300      	movs	r3, #0
{
 8005d2a:	b510      	push	{r4, lr}
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 8005d2c:	2405      	movs	r4, #5
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8005d2e:	461a      	mov	r2, r3
 8005d30:	4619      	mov	r1, r3
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 8005d32:	f8c0 4294 	str.w	r4, [r0, #660]	@ 0x294
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8005d36:	f001 f841 	bl	8006dbc <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8005d3a:	2000      	movs	r0, #0
 8005d3c:	bd10      	pop	{r4, pc}
 8005d3e:	bf00      	nop

08005d40 <DeInitStateMachine.isra.0>:
  * @brief  DeInitStateMachine
  *         De-Initialize the Host state machine.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef DeInitStateMachine(USBH_HandleTypeDef *phost)
 8005d40:	b570      	push	{r4, r5, r6, lr}
  uint32_t i = 0U;

  /* Clear Pipes flags*/
  for (i = 0U; i < USBH_MAX_PIPES_NBR; i++)
  {
    phost->Pipes[i] = 0U;
 8005d42:	2640      	movs	r6, #64	@ 0x40
static USBH_StatusTypeDef DeInitStateMachine(USBH_HandleTypeDef *phost)
 8005d44:	4604      	mov	r4, r0
    phost->Pipes[i] = 0U;
 8005d46:	2100      	movs	r1, #0
 8005d48:	f500 707e 	add.w	r0, r0, #1016	@ 0x3f8
 8005d4c:	4632      	mov	r2, r6
  for (i = 0U; i < USBH_MAX_DATA_BUFFER; i++)
  {
    phost->device.Data[i] = 0U;
  }

  phost->gState = HOST_IDLE;
 8005d4e:	2500      	movs	r5, #0
    phost->Pipes[i] = 0U;
 8005d50:	f001 faab 	bl	80072aa <memset>
  phost->EnumState = ENUM_IDLE;
 8005d54:	f44f 7380 	mov.w	r3, #256	@ 0x100
  phost->RequestState = CMD_SEND;
  phost->Timer = 0U;

  phost->Control.state = CTRL_SETUP;
 8005d58:	2201      	movs	r2, #1
  phost->device.speed = (uint8_t)USBH_SPEED_FULL;
  phost->device.RstCnt = 0U;
  phost->device.EnumCnt = 0U;

  /* Reset the device struct */
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 8005d5a:	4629      	mov	r1, r5
  phost->gState = HOST_IDLE;
 8005d5c:	7025      	strb	r5, [r4, #0]
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 8005d5e:	f104 001c 	add.w	r0, r4, #28
  phost->EnumState = ENUM_IDLE;
 8005d62:	f8a4 3001 	strh.w	r3, [r4, #1]
  phost->Control.state = CTRL_SETUP;
 8005d66:	8322      	strh	r2, [r4, #24]
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 8005d68:	461a      	mov	r2, r3
  phost->device.address = USBH_ADDRESS_DEFAULT;
 8005d6a:	f8c4 331c 	str.w	r3, [r4, #796]	@ 0x31c
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 8005d6e:	71a6      	strb	r6, [r4, #6]
  phost->Timer = 0U;
 8005d70:	f8c4 5438 	str.w	r5, [r4, #1080]	@ 0x438
  USBH_memset(&phost->device.CfgDesc_Raw, 0, sizeof(phost->device.CfgDesc_Raw));
 8005d74:	f001 fa99 	bl	80072aa <memset>
  USBH_memset(&phost->device.Data, 0, sizeof(phost->device.Data));
 8005d78:	4629      	mov	r1, r5
 8005d7a:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8005d7e:	f504 708e 	add.w	r0, r4, #284	@ 0x11c
 8005d82:	f001 fa92 	bl	80072aa <memset>
  USBH_memset(&phost->device.DevDesc, 0, sizeof(phost->device.DevDesc));
  USBH_memset(&phost->device.CfgDesc, 0, sizeof(phost->device.CfgDesc));
 8005d86:	4629      	mov	r1, r5
 8005d88:	f504 704e 	add.w	r0, r4, #824	@ 0x338
  USBH_memset(&phost->device.DevDesc, 0, sizeof(phost->device.DevDesc));
 8005d8c:	f8c4 5326 	str.w	r5, [r4, #806]	@ 0x326
 8005d90:	f8c4 532a 	str.w	r5, [r4, #810]	@ 0x32a
  USBH_memset(&phost->device.CfgDesc, 0, sizeof(phost->device.CfgDesc));
 8005d94:	22b2      	movs	r2, #178	@ 0xb2
  USBH_memset(&phost->device.DevDesc, 0, sizeof(phost->device.DevDesc));
 8005d96:	f8c4 532e 	str.w	r5, [r4, #814]	@ 0x32e
 8005d9a:	f8c4 5332 	str.w	r5, [r4, #818]	@ 0x332
 8005d9e:	f8a4 5336 	strh.w	r5, [r4, #822]	@ 0x336

  return USBH_OK;
}
 8005da2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USBH_memset(&phost->device.CfgDesc, 0, sizeof(phost->device.CfgDesc));
 8005da6:	f001 ba80 	b.w	80072aa <memset>
 8005daa:	bf00      	nop

08005dac <USBH_Process>:
  *         Background process of the USB Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Process(USBH_HandleTypeDef *phost)
{
 8005dac:	b530      	push	{r4, r5, lr}
  __IO USBH_StatusTypeDef status = USBH_FAIL;
 8005dae:	2302      	movs	r3, #2
{
 8005db0:	b087      	sub	sp, #28
 8005db2:	4604      	mov	r4, r0
  __IO USBH_StatusTypeDef status = USBH_FAIL;
 8005db4:	f88d 3017 	strb.w	r3, [sp, #23]
  uint8_t idx = 0U;

  /* check for Host pending port disconnect event */
  if (phost->device.is_disconnected == 1U)
 8005db8:	f890 3321 	ldrb.w	r3, [r0, #801]	@ 0x321
 8005dbc:	2b01      	cmp	r3, #1
 8005dbe:	d101      	bne.n	8005dc4 <USBH_Process+0x18>
  {
    phost->gState = HOST_DEV_DISCONNECTED;
 8005dc0:	2303      	movs	r3, #3
 8005dc2:	7003      	strb	r3, [r0, #0]
  }

  switch (phost->gState)
 8005dc4:	7823      	ldrb	r3, [r4, #0]
 8005dc6:	2b0b      	cmp	r3, #11
 8005dc8:	d844      	bhi.n	8005e54 <USBH_Process+0xa8>
 8005dca:	e8df f013 	tbh	[pc, r3, lsl #1]
 8005dce:	004e      	.short	0x004e
 8005dd0:	000c0066 	.word	0x000c0066
 8005dd4:	0043007d 	.word	0x0043007d
 8005dd8:	00af00a1 	.word	0x00af00a1
 8005ddc:	00d800cd 	.word	0x00d800cd
 8005de0:	00f100e9 	.word	0x00f100e9
 8005de4:	0046      	.short	0x0046
#endif
      break;

    case HOST_DEV_ATTACHED :

      if (phost->pUser != NULL)
 8005de6:	f8d4 3448 	ldr.w	r3, [r4, #1096]	@ 0x448
 8005dea:	b113      	cbz	r3, 8005df2 <USBH_Process+0x46>
      {
        phost->pUser(phost, HOST_USER_CONNECTION);
 8005dec:	2104      	movs	r1, #4
 8005dee:	4620      	mov	r0, r4
 8005df0:	4798      	blx	r3
      }

      /* Wait for 100 ms after Reset */
      USBH_Delay(100U);
 8005df2:	2064      	movs	r0, #100	@ 0x64

      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);

      /* Open Control pipes */
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 8005df4:	2500      	movs	r5, #0
      USBH_Delay(100U);
 8005df6:	f001 f87d 	bl	8006ef4 <USBH_Delay>
      phost->device.speed = (uint8_t)USBH_LL_GetSpeed(phost);
 8005dfa:	4620      	mov	r0, r4
 8005dfc:	f001 f81e 	bl	8006e3c <USBH_LL_GetSpeed>
      phost->gState = HOST_ENUMERATION;
 8005e00:	2305      	movs	r3, #5
      phost->device.speed = (uint8_t)USBH_LL_GetSpeed(phost);
 8005e02:	4602      	mov	r2, r0
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 8005e04:	2100      	movs	r1, #0
      phost->gState = HOST_ENUMERATION;
 8005e06:	7023      	strb	r3, [r4, #0]
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 8005e08:	4620      	mov	r0, r4
      phost->device.speed = (uint8_t)USBH_LL_GetSpeed(phost);
 8005e0a:	f884 231d 	strb.w	r2, [r4, #797]	@ 0x31d
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 8005e0e:	f000 fefd 	bl	8006c0c <USBH_AllocPipe>
 8005e12:	4603      	mov	r3, r0
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 8005e14:	2180      	movs	r1, #128	@ 0x80
 8005e16:	4620      	mov	r0, r4
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 8005e18:	7163      	strb	r3, [r4, #5]
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 8005e1a:	f000 fef7 	bl	8006c0c <USBH_AllocPipe>
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 8005e1e:	79a2      	ldrb	r2, [r4, #6]
 8005e20:	f894 331d 	ldrb.w	r3, [r4, #797]	@ 0x31d
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 8005e24:	4601      	mov	r1, r0
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 8005e26:	e9cd 5201 	strd	r5, r2, [sp, #4]
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 8005e2a:	7120      	strb	r0, [r4, #4]
      (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 8005e2c:	2280      	movs	r2, #128	@ 0x80
 8005e2e:	9300      	str	r3, [sp, #0]
 8005e30:	4620      	mov	r0, r4
 8005e32:	f894 331c 	ldrb.w	r3, [r4, #796]	@ 0x31c
 8005e36:	f000 fed9 	bl	8006bec <USBH_OpenPipe>
                          phost->device.address, phost->device.speed,
                          USBH_EP_CONTROL, (uint16_t)phost->Control.pipe_size);

      /* Open Control pipes */
      (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
 8005e3a:	79a2      	ldrb	r2, [r4, #6]
 8005e3c:	f894 131d 	ldrb.w	r1, [r4, #797]	@ 0x31d
 8005e40:	4620      	mov	r0, r4
 8005e42:	f894 331c 	ldrb.w	r3, [r4, #796]	@ 0x31c
 8005e46:	9100      	str	r1, [sp, #0]
 8005e48:	e9cd 5201 	strd	r5, r2, [sp, #4]
 8005e4c:	462a      	mov	r2, r5
 8005e4e:	7961      	ldrb	r1, [r4, #5]
 8005e50:	f000 fecc 	bl	8006bec <USBH_OpenPipe>
    case HOST_ABORT_STATE:
    default :
      break;
  }
  return USBH_OK;
}
 8005e54:	2000      	movs	r0, #0
 8005e56:	b007      	add	sp, #28
 8005e58:	bd30      	pop	{r4, r5, pc}
      if (phost->pActiveClass != NULL)
 8005e5a:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	@ 0x3f0
 8005e5e:	2b00      	cmp	r3, #0
 8005e60:	d0f8      	beq.n	8005e54 <USBH_Process+0xa8>
        phost->pActiveClass->BgndProcess(phost);
 8005e62:	695b      	ldr	r3, [r3, #20]
 8005e64:	4620      	mov	r0, r4
 8005e66:	4798      	blx	r3
 8005e68:	e7f4      	b.n	8005e54 <USBH_Process+0xa8>
      if ((phost->device.is_connected) != 0U)
 8005e6a:	f894 3320 	ldrb.w	r3, [r4, #800]	@ 0x320
 8005e6e:	2b00      	cmp	r3, #0
 8005e70:	d0f0      	beq.n	8005e54 <USBH_Process+0xa8>
        USBH_UsrLog("USB Device Connected");
 8005e72:	48b9      	ldr	r0, [pc, #740]	@ (8006158 <USBH_Process+0x3ac>)
 8005e74:	f001 f9bc 	bl	80071f0 <iprintf>
 8005e78:	200a      	movs	r0, #10
 8005e7a:	f001 f9cb 	bl	8007214 <putchar>
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
 8005e7e:	2301      	movs	r3, #1
        USBH_Delay(200U);
 8005e80:	20c8      	movs	r0, #200	@ 0xc8
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
 8005e82:	7023      	strb	r3, [r4, #0]
        USBH_Delay(200U);
 8005e84:	f001 f836 	bl	8006ef4 <USBH_Delay>
        (void)USBH_LL_ResetPort(phost);
 8005e88:	4620      	mov	r0, r4
 8005e8a:	f000 ffe3 	bl	8006e54 <USBH_LL_ResetPort>
        phost->device.address = USBH_ADDRESS_DEFAULT;
 8005e8e:	2300      	movs	r3, #0
 8005e90:	f884 331c 	strb.w	r3, [r4, #796]	@ 0x31c
        phost->Timeout = 0U;
 8005e94:	f8c4 343c 	str.w	r3, [r4, #1084]	@ 0x43c
 8005e98:	e7dc      	b.n	8005e54 <USBH_Process+0xa8>
      if (phost->device.PortEnabled == 1U)
 8005e9a:	f894 3323 	ldrb.w	r3, [r4, #803]	@ 0x323
 8005e9e:	2b01      	cmp	r3, #1
 8005ea0:	f000 81eb 	beq.w	800627a <USBH_Process+0x4ce>
        if (phost->Timeout > USBH_DEV_RESET_TIMEOUT)
 8005ea4:	f8d4 343c 	ldr.w	r3, [r4, #1084]	@ 0x43c
 8005ea8:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8005eac:	f240 80ab 	bls.w	8006006 <USBH_Process+0x25a>
          phost->device.RstCnt++;
 8005eb0:	f894 331f 	ldrb.w	r3, [r4, #799]	@ 0x31f
 8005eb4:	3301      	adds	r3, #1
 8005eb6:	b2db      	uxtb	r3, r3
          if (phost->device.RstCnt > 3U)
 8005eb8:	2b03      	cmp	r3, #3
          phost->device.RstCnt++;
 8005eba:	f884 331f 	strb.w	r3, [r4, #799]	@ 0x31f
          if (phost->device.RstCnt > 3U)
 8005ebe:	f200 81e8 	bhi.w	8006292 <USBH_Process+0x4e6>
            phost->gState = HOST_IDLE;
 8005ec2:	2300      	movs	r3, #0
 8005ec4:	7023      	strb	r3, [r4, #0]
 8005ec6:	e7c5      	b.n	8005e54 <USBH_Process+0xa8>
      phost->device.is_disconnected = 0U;
 8005ec8:	2500      	movs	r5, #0
      (void)DeInitStateMachine(phost);
 8005eca:	4620      	mov	r0, r4
      phost->device.is_disconnected = 0U;
 8005ecc:	f884 5321 	strb.w	r5, [r4, #801]	@ 0x321
      (void)DeInitStateMachine(phost);
 8005ed0:	f7ff ff36 	bl	8005d40 <DeInitStateMachine.isra.0>
      if (phost->pActiveClass != NULL)
 8005ed4:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	@ 0x3f0
 8005ed8:	b123      	cbz	r3, 8005ee4 <USBH_Process+0x138>
        phost->pActiveClass->DeInit(phost);
 8005eda:	68db      	ldr	r3, [r3, #12]
 8005edc:	4620      	mov	r0, r4
 8005ede:	4798      	blx	r3
        phost->pActiveClass = NULL;
 8005ee0:	f8c4 53f0 	str.w	r5, [r4, #1008]	@ 0x3f0
      if (phost->pUser != NULL)
 8005ee4:	f8d4 3448 	ldr.w	r3, [r4, #1096]	@ 0x448
 8005ee8:	b113      	cbz	r3, 8005ef0 <USBH_Process+0x144>
        phost->pUser(phost, HOST_USER_DISCONNECTION);
 8005eea:	2105      	movs	r1, #5
 8005eec:	4620      	mov	r0, r4
 8005eee:	4798      	blx	r3
      USBH_UsrLog("USB Device disconnected");
 8005ef0:	489a      	ldr	r0, [pc, #616]	@ (800615c <USBH_Process+0x3b0>)
 8005ef2:	f001 f97d 	bl	80071f0 <iprintf>
 8005ef6:	200a      	movs	r0, #10
 8005ef8:	f001 f98c 	bl	8007214 <putchar>
      if (phost->device.is_ReEnumerated == 1U)
 8005efc:	f894 3322 	ldrb.w	r3, [r4, #802]	@ 0x322
 8005f00:	2b01      	cmp	r3, #1
 8005f02:	b2dd      	uxtb	r5, r3
 8005f04:	f000 8185 	beq.w	8006212 <USBH_Process+0x466>
        (void)USBH_LL_Start(phost);
 8005f08:	4620      	mov	r0, r4
 8005f0a:	f000 ff7f 	bl	8006e0c <USBH_LL_Start>
 8005f0e:	e7a1      	b.n	8005e54 <USBH_Process+0xa8>
static USBH_StatusTypeDef USBH_HandleEnum(USBH_HandleTypeDef *phost)
{
  USBH_StatusTypeDef Status = USBH_BUSY;
  USBH_StatusTypeDef ReqStatus = USBH_BUSY;

  switch (phost->EnumState)
 8005f10:	7863      	ldrb	r3, [r4, #1]
 8005f12:	2b07      	cmp	r3, #7
 8005f14:	f200 8099 	bhi.w	800604a <USBH_Process+0x29e>
 8005f18:	e8df f013 	tbh	[pc, r3, lsl #1]
 8005f1c:	015300e1 	.word	0x015300e1
 8005f20:	01130134 	.word	0x01130134
 8005f24:	00c90108 	.word	0x00c90108
 8005f28:	008500b1 	.word	0x008500b1
      if (phost->pActiveClass != NULL)
 8005f2c:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	@ 0x3f0
 8005f30:	2b00      	cmp	r3, #0
 8005f32:	f000 81b7 	beq.w	80062a4 <USBH_Process+0x4f8>
        status = phost->pActiveClass->Requests(phost);
 8005f36:	691b      	ldr	r3, [r3, #16]
 8005f38:	4620      	mov	r0, r4
 8005f3a:	4798      	blx	r3
 8005f3c:	f88d 0017 	strb.w	r0, [sp, #23]
        if (status == USBH_OK)
 8005f40:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8005f44:	2b00      	cmp	r3, #0
 8005f46:	d05b      	beq.n	8006000 <USBH_Process+0x254>
        else if (status == USBH_FAIL)
 8005f48:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8005f4c:	2b02      	cmp	r3, #2
 8005f4e:	d181      	bne.n	8005e54 <USBH_Process+0xa8>
          phost->gState = HOST_ABORT_STATE;
 8005f50:	230d      	movs	r3, #13
          USBH_ErrLog("Device not responding Please Unplug.");
 8005f52:	4883      	ldr	r0, [pc, #524]	@ (8006160 <USBH_Process+0x3b4>)
          phost->gState = HOST_ABORT_STATE;
 8005f54:	7023      	strb	r3, [r4, #0]
          USBH_ErrLog("Device not responding Please Unplug.");
 8005f56:	f001 f94b 	bl	80071f0 <iprintf>
 8005f5a:	4882      	ldr	r0, [pc, #520]	@ (8006164 <USBH_Process+0x3b8>)
 8005f5c:	f001 f948 	bl	80071f0 <iprintf>
 8005f60:	200a      	movs	r0, #10
 8005f62:	f001 f957 	bl	8007214 <putchar>
 8005f66:	e775      	b.n	8005e54 <USBH_Process+0xa8>
      if (phost->pUser != NULL)
 8005f68:	f8d4 3448 	ldr.w	r3, [r4, #1096]	@ 0x448
 8005f6c:	2b00      	cmp	r3, #0
 8005f6e:	f43f af71 	beq.w	8005e54 <USBH_Process+0xa8>
        phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
 8005f72:	2101      	movs	r1, #1
 8005f74:	4620      	mov	r0, r4
 8005f76:	4798      	blx	r3
        phost->gState = HOST_SET_CONFIGURATION;
 8005f78:	2308      	movs	r3, #8
 8005f7a:	7023      	strb	r3, [r4, #0]
 8005f7c:	e76a      	b.n	8005e54 <USBH_Process+0xa8>
      if (USBH_SetCfg(phost, (uint16_t)phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
 8005f7e:	f894 133d 	ldrb.w	r1, [r4, #829]	@ 0x33d
 8005f82:	4620      	mov	r0, r4
 8005f84:	f000 fd4c 	bl	8006a20 <USBH_SetCfg>
 8005f88:	2800      	cmp	r0, #0
 8005f8a:	f47f af63 	bne.w	8005e54 <USBH_Process+0xa8>
        phost->gState = HOST_SET_WAKEUP_FEATURE;
 8005f8e:	2309      	movs	r3, #9
        USBH_UsrLog("Default configuration set.");
 8005f90:	4875      	ldr	r0, [pc, #468]	@ (8006168 <USBH_Process+0x3bc>)
        phost->gState = HOST_SET_WAKEUP_FEATURE;
 8005f92:	7023      	strb	r3, [r4, #0]
        USBH_UsrLog("Default configuration set.");
 8005f94:	f001 f92c 	bl	80071f0 <iprintf>
 8005f98:	200a      	movs	r0, #10
 8005f9a:	f001 f93b 	bl	8007214 <putchar>
 8005f9e:	e759      	b.n	8005e54 <USBH_Process+0xa8>
      if (((phost->device.CfgDesc.bmAttributes) & (1U << 5)) != 0U)
 8005fa0:	f894 333f 	ldrb.w	r3, [r4, #831]	@ 0x33f
 8005fa4:	069b      	lsls	r3, r3, #26
 8005fa6:	f100 8146 	bmi.w	8006236 <USBH_Process+0x48a>
          phost->gState = HOST_CHECK_CLASS;
 8005faa:	230a      	movs	r3, #10
 8005fac:	7023      	strb	r3, [r4, #0]
 8005fae:	e751      	b.n	8005e54 <USBH_Process+0xa8>
      if (phost->ClassNumber == 0U)
 8005fb0:	f8d4 33f4 	ldr.w	r3, [r4, #1012]	@ 0x3f4
 8005fb4:	2b00      	cmp	r3, #0
 8005fb6:	f000 8137 	beq.w	8006228 <USBH_Process+0x47c>
        phost->pActiveClass = NULL;
 8005fba:	2200      	movs	r2, #0
          if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass)
 8005fbc:	f8d4 33ec 	ldr.w	r3, [r4, #1004]	@ 0x3ec
 8005fc0:	f894 1347 	ldrb.w	r1, [r4, #839]	@ 0x347
        phost->pActiveClass = NULL;
 8005fc4:	f8c4 23f0 	str.w	r2, [r4, #1008]	@ 0x3f0
          if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass)
 8005fc8:	791a      	ldrb	r2, [r3, #4]
 8005fca:	4291      	cmp	r1, r2
 8005fcc:	d122      	bne.n	8006014 <USBH_Process+0x268>
          if (phost->pActiveClass->Init(phost) == USBH_OK)
 8005fce:	689a      	ldr	r2, [r3, #8]
 8005fd0:	4620      	mov	r0, r4
            phost->pActiveClass = phost->pClass[idx];
 8005fd2:	f8c4 33f0 	str.w	r3, [r4, #1008]	@ 0x3f0
          if (phost->pActiveClass->Init(phost) == USBH_OK)
 8005fd6:	4790      	blx	r2
 8005fd8:	2800      	cmp	r0, #0
 8005fda:	f040 8142 	bne.w	8006262 <USBH_Process+0x4b6>
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);
 8005fde:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	@ 0x3f0
            phost->gState = HOST_CLASS_REQUEST;
 8005fe2:	2206      	movs	r2, #6
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);
 8005fe4:	4861      	ldr	r0, [pc, #388]	@ (800616c <USBH_Process+0x3c0>)
            phost->gState = HOST_CLASS_REQUEST;
 8005fe6:	7022      	strb	r2, [r4, #0]
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);
 8005fe8:	6819      	ldr	r1, [r3, #0]
 8005fea:	f001 f901 	bl	80071f0 <iprintf>
 8005fee:	200a      	movs	r0, #10
 8005ff0:	f001 f910 	bl	8007214 <putchar>
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
 8005ff4:	2103      	movs	r1, #3
 8005ff6:	f8d4 3448 	ldr.w	r3, [r4, #1096]	@ 0x448
 8005ffa:	4620      	mov	r0, r4
 8005ffc:	4798      	blx	r3
 8005ffe:	e729      	b.n	8005e54 <USBH_Process+0xa8>
          phost->gState = HOST_CLASS;
 8006000:	230b      	movs	r3, #11
 8006002:	7023      	strb	r3, [r4, #0]
 8006004:	e726      	b.n	8005e54 <USBH_Process+0xa8>
          phost->Timeout += 10U;
 8006006:	330a      	adds	r3, #10
          USBH_Delay(10U);
 8006008:	200a      	movs	r0, #10
          phost->Timeout += 10U;
 800600a:	f8c4 343c 	str.w	r3, [r4, #1084]	@ 0x43c
          USBH_Delay(10U);
 800600e:	f000 ff71 	bl	8006ef4 <USBH_Delay>
 8006012:	e71f      	b.n	8005e54 <USBH_Process+0xa8>
          phost->gState = HOST_ABORT_STATE;
 8006014:	230d      	movs	r3, #13
          USBH_UsrLog("No registered class for this device.");
 8006016:	4856      	ldr	r0, [pc, #344]	@ (8006170 <USBH_Process+0x3c4>)
          phost->gState = HOST_ABORT_STATE;
 8006018:	7023      	strb	r3, [r4, #0]
          USBH_UsrLog("No registered class for this device.");
 800601a:	f001 f8e9 	bl	80071f0 <iprintf>
 800601e:	200a      	movs	r0, #10
 8006020:	f001 f8f8 	bl	8007214 <putchar>
 8006024:	e716      	b.n	8005e54 <USBH_Process+0xa8>
#endif
      }
      break;

    case ENUM_GET_SERIALNUM_STRING_DESC:
      if (phost->device.DevDesc.iSerialNumber != 0U)
 8006026:	f894 1336 	ldrb.w	r1, [r4, #822]	@ 0x336
 800602a:	2900      	cmp	r1, #0
 800602c:	f000 8159 	beq.w	80062e2 <USBH_Process+0x536>
      {
        /* Check that Serial number string is available */
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
                                        phost->device.Data, 0xFFU);
 8006030:	f504 758e 	add.w	r5, r4, #284	@ 0x11c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
 8006034:	23ff      	movs	r3, #255	@ 0xff
 8006036:	4620      	mov	r0, r4
 8006038:	462a      	mov	r2, r5
 800603a:	f000 fd57 	bl	8006aec <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
 800603e:	2800      	cmp	r0, #0
 8006040:	f000 81af 	beq.w	80063a2 <USBH_Process+0x5f6>
        {
          /* User callback for Serial number string */
          USBH_UsrLog("Serial Number : %s", (char *)(void *)phost->device.Data);
          Status = USBH_OK;
        }
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 8006044:	2803      	cmp	r0, #3
 8006046:	f000 814c 	beq.w	80062e2 <USBH_Process+0x536>
  USBH_StatusTypeDef Status = USBH_BUSY;
 800604a:	2301      	movs	r3, #1
      status = USBH_HandleEnum(phost);
 800604c:	f88d 3017 	strb.w	r3, [sp, #23]
      if (status == USBH_OK)
 8006050:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8006054:	f003 05ff 	and.w	r5, r3, #255	@ 0xff
 8006058:	2b00      	cmp	r3, #0
 800605a:	f47f aefb 	bne.w	8005e54 <USBH_Process+0xa8>
        USBH_UsrLog("Enumeration done.");
 800605e:	4845      	ldr	r0, [pc, #276]	@ (8006174 <USBH_Process+0x3c8>)
 8006060:	f001 f8c6 	bl	80071f0 <iprintf>
 8006064:	200a      	movs	r0, #10
 8006066:	f001 f8d5 	bl	8007214 <putchar>
        if (phost->device.DevDesc.bNumConfigurations == 1U)
 800606a:	f894 3337 	ldrb.w	r3, [r4, #823]	@ 0x337
        phost->device.current_interface = 0U;
 800606e:	f884 5324 	strb.w	r5, [r4, #804]	@ 0x324
        if (phost->device.DevDesc.bNumConfigurations == 1U)
 8006072:	2b01      	cmp	r3, #1
 8006074:	f000 812c 	beq.w	80062d0 <USBH_Process+0x524>
          phost->gState = HOST_INPUT;
 8006078:	2307      	movs	r3, #7
 800607a:	7023      	strb	r3, [r4, #0]
 800607c:	e6ea      	b.n	8005e54 <USBH_Process+0xa8>
      if (phost->device.DevDesc.iProduct != 0U)
 800607e:	f894 1335 	ldrb.w	r1, [r4, #821]	@ 0x335
 8006082:	b159      	cbz	r1, 800609c <USBH_Process+0x2f0>
                                        phost->device.Data, 0xFFU);
 8006084:	f504 758e 	add.w	r5, r4, #284	@ 0x11c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
 8006088:	23ff      	movs	r3, #255	@ 0xff
 800608a:	4620      	mov	r0, r4
 800608c:	462a      	mov	r2, r5
 800608e:	f000 fd2d 	bl	8006aec <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
 8006092:	2800      	cmp	r0, #0
 8006094:	f000 818d 	beq.w	80063b2 <USBH_Process+0x606>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 8006098:	2803      	cmp	r0, #3
 800609a:	d1d6      	bne.n	800604a <USBH_Process+0x29e>
          USBH_UsrLog("Product : N/A");
 800609c:	4836      	ldr	r0, [pc, #216]	@ (8006178 <USBH_Process+0x3cc>)
 800609e:	f001 f8a7 	bl	80071f0 <iprintf>
 80060a2:	200a      	movs	r0, #10
 80060a4:	f001 f8b6 	bl	8007214 <putchar>
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 80060a8:	2307      	movs	r3, #7
 80060aa:	7063      	strb	r3, [r4, #1]
 80060ac:	e7cd      	b.n	800604a <USBH_Process+0x29e>
      if (phost->device.DevDesc.iManufacturer != 0U)
 80060ae:	f894 1334 	ldrb.w	r1, [r4, #820]	@ 0x334
 80060b2:	b159      	cbz	r1, 80060cc <USBH_Process+0x320>
                                        phost->device.Data, 0xFFU);
 80060b4:	f504 758e 	add.w	r5, r4, #284	@ 0x11c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
 80060b8:	23ff      	movs	r3, #255	@ 0xff
 80060ba:	4620      	mov	r0, r4
 80060bc:	462a      	mov	r2, r5
 80060be:	f000 fd15 	bl	8006aec <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
 80060c2:	2800      	cmp	r0, #0
 80060c4:	f000 8163 	beq.w	800638e <USBH_Process+0x5e2>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 80060c8:	2803      	cmp	r0, #3
 80060ca:	d1be      	bne.n	800604a <USBH_Process+0x29e>
          USBH_UsrLog("Manufacturer : N/A");
 80060cc:	482b      	ldr	r0, [pc, #172]	@ (800617c <USBH_Process+0x3d0>)
 80060ce:	f001 f88f 	bl	80071f0 <iprintf>
 80060d2:	200a      	movs	r0, #10
 80060d4:	f001 f89e 	bl	8007214 <putchar>
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 80060d8:	2306      	movs	r3, #6
 80060da:	7063      	strb	r3, [r4, #1]
 80060dc:	e7b5      	b.n	800604a <USBH_Process+0x29e>
      ReqStatus = USBH_Get_DevDesc(phost, 8U);
 80060de:	2108      	movs	r1, #8
 80060e0:	4620      	mov	r0, r4
 80060e2:	f000 faa7 	bl	8006634 <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
 80060e6:	4605      	mov	r5, r0
 80060e8:	2800      	cmp	r0, #0
 80060ea:	f000 812b 	beq.w	8006344 <USBH_Process+0x598>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 80060ee:	2803      	cmp	r0, #3
 80060f0:	d1ab      	bne.n	800604a <USBH_Process+0x29e>
        USBH_ErrLog("Control error: Get Device Descriptor request failed");
 80060f2:	481b      	ldr	r0, [pc, #108]	@ (8006160 <USBH_Process+0x3b4>)
 80060f4:	f001 f87c 	bl	80071f0 <iprintf>
 80060f8:	4821      	ldr	r0, [pc, #132]	@ (8006180 <USBH_Process+0x3d4>)
 80060fa:	f001 f879 	bl	80071f0 <iprintf>
 80060fe:	200a      	movs	r0, #10
 8006100:	f001 f888 	bl	8007214 <putchar>
        phost->device.EnumCnt++;
 8006104:	f894 331e 	ldrb.w	r3, [r4, #798]	@ 0x31e
 8006108:	3301      	adds	r3, #1
 800610a:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
 800610c:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
 800610e:	f884 331e 	strb.w	r3, [r4, #798]	@ 0x31e
        if (phost->device.EnumCnt > 3U)
 8006112:	f200 8133 	bhi.w	800637c <USBH_Process+0x5d0>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 8006116:	7961      	ldrb	r1, [r4, #5]
 8006118:	4620      	mov	r0, r4
 800611a:	f000 fd91 	bl	8006c40 <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800611e:	7921      	ldrb	r1, [r4, #4]
 8006120:	4620      	mov	r0, r4
 8006122:	f000 fd8d 	bl	8006c40 <USBH_FreePipe>
          phost->gState = HOST_IDLE;
 8006126:	2300      	movs	r3, #0
 8006128:	7023      	strb	r3, [r4, #0]
 800612a:	e78e      	b.n	800604a <USBH_Process+0x29e>
      ReqStatus = USBH_Get_CfgDesc(phost, phost->device.CfgDesc.wTotalLength);
 800612c:	f8b4 133a 	ldrh.w	r1, [r4, #826]	@ 0x33a
 8006130:	4620      	mov	r0, r4
 8006132:	f000 faf5 	bl	8006720 <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
 8006136:	2800      	cmp	r0, #0
 8006138:	f040 80c0 	bne.w	80062bc <USBH_Process+0x510>
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 800613c:	2305      	movs	r3, #5
 800613e:	7063      	strb	r3, [r4, #1]
 8006140:	e783      	b.n	800604a <USBH_Process+0x29e>
      ReqStatus = USBH_Get_CfgDesc(phost, USB_CONFIGURATION_DESC_SIZE);
 8006142:	2109      	movs	r1, #9
 8006144:	4620      	mov	r0, r4
 8006146:	f000 faeb 	bl	8006720 <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
 800614a:	2800      	cmp	r0, #0
 800614c:	f040 80b6 	bne.w	80062bc <USBH_Process+0x510>
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 8006150:	2304      	movs	r3, #4
 8006152:	7063      	strb	r3, [r4, #1]
 8006154:	e779      	b.n	800604a <USBH_Process+0x29e>
 8006156:	bf00      	nop
 8006158:	08007e60 	.word	0x08007e60
 800615c:	080081e8 	.word	0x080081e8
 8006160:	08007e44 	.word	0x08007e44
 8006164:	080081a8 	.word	0x080081a8
 8006168:	080080c4 	.word	0x080080c4
 800616c:	08008174 	.word	0x08008174
 8006170:	0800814c 	.word	0x0800814c
 8006174:	08008088 	.word	0x08008088
 8006178:	08008050 	.word	0x08008050
 800617c:	0800802c 	.word	0x0800802c
 8006180:	08007ec0 	.word	0x08007ec0
      ReqStatus = USBH_SetAddress(phost, USBH_DEVICE_ADDRESS);
 8006184:	2101      	movs	r1, #1
 8006186:	4620      	mov	r0, r4
 8006188:	f000 fc26 	bl	80069d8 <USBH_SetAddress>
      if (ReqStatus == USBH_OK)
 800618c:	4605      	mov	r5, r0
 800618e:	2800      	cmp	r0, #0
 8006190:	f000 80af 	beq.w	80062f2 <USBH_Process+0x546>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 8006194:	2803      	cmp	r0, #3
 8006196:	f47f af58 	bne.w	800604a <USBH_Process+0x29e>
        USBH_ErrLog("Control error: Device Set Address request failed");
 800619a:	488b      	ldr	r0, [pc, #556]	@ (80063c8 <USBH_Process+0x61c>)
 800619c:	f001 f828 	bl	80071f0 <iprintf>
 80061a0:	488a      	ldr	r0, [pc, #552]	@ (80063cc <USBH_Process+0x620>)
 80061a2:	f001 f825 	bl	80071f0 <iprintf>
 80061a6:	200a      	movs	r0, #10
 80061a8:	f001 f834 	bl	8007214 <putchar>
        USBH_UsrLog("Control error, Device not Responding Please unplug the Device.");
 80061ac:	4888      	ldr	r0, [pc, #544]	@ (80063d0 <USBH_Process+0x624>)
 80061ae:	f001 f81f 	bl	80071f0 <iprintf>
 80061b2:	200a      	movs	r0, #10
 80061b4:	f001 f82e 	bl	8007214 <putchar>
        phost->gState = HOST_ABORT_STATE;
 80061b8:	220d      	movs	r2, #13
        phost->EnumState = ENUM_IDLE;
 80061ba:	2300      	movs	r3, #0
        phost->gState = HOST_ABORT_STATE;
 80061bc:	7022      	strb	r2, [r4, #0]
        phost->EnumState = ENUM_IDLE;
 80061be:	7063      	strb	r3, [r4, #1]
 80061c0:	e743      	b.n	800604a <USBH_Process+0x29e>
      ReqStatus = USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE);
 80061c2:	2112      	movs	r1, #18
 80061c4:	4620      	mov	r0, r4
 80061c6:	f000 fa35 	bl	8006634 <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
 80061ca:	2800      	cmp	r0, #0
 80061cc:	f000 80c3 	beq.w	8006356 <USBH_Process+0x5aa>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 80061d0:	2803      	cmp	r0, #3
 80061d2:	f47f af3a 	bne.w	800604a <USBH_Process+0x29e>
        USBH_ErrLog("Control error: Get Full Device Descriptor request failed");
 80061d6:	487c      	ldr	r0, [pc, #496]	@ (80063c8 <USBH_Process+0x61c>)
 80061d8:	f001 f80a 	bl	80071f0 <iprintf>
 80061dc:	487d      	ldr	r0, [pc, #500]	@ (80063d4 <USBH_Process+0x628>)
        USBH_ErrLog("Control error: Get Device configuration descriptor request failed");
 80061de:	f001 f807 	bl	80071f0 <iprintf>
 80061e2:	200a      	movs	r0, #10
 80061e4:	f001 f816 	bl	8007214 <putchar>
        phost->device.EnumCnt++;
 80061e8:	f894 331e 	ldrb.w	r3, [r4, #798]	@ 0x31e
 80061ec:	3301      	adds	r3, #1
 80061ee:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
 80061f0:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
 80061f2:	f884 331e 	strb.w	r3, [r4, #798]	@ 0x31e
        if (phost->device.EnumCnt > 3U)
 80061f6:	f200 80c1 	bhi.w	800637c <USBH_Process+0x5d0>
          (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 80061fa:	7961      	ldrb	r1, [r4, #5]
 80061fc:	4620      	mov	r0, r4
 80061fe:	f000 fd1f 	bl	8006c40 <USBH_FreePipe>
          (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 8006202:	7921      	ldrb	r1, [r4, #4]
 8006204:	4620      	mov	r0, r4
 8006206:	f000 fd1b 	bl	8006c40 <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 800620a:	2300      	movs	r3, #0
 800620c:	7063      	strb	r3, [r4, #1]
          phost->gState = HOST_IDLE;
 800620e:	7023      	strb	r3, [r4, #0]
 8006210:	e71b      	b.n	800604a <USBH_Process+0x29e>
        phost->device.is_ReEnumerated = 0U;
 8006212:	2300      	movs	r3, #0
  (void)USBH_LL_Start(phost);
 8006214:	4620      	mov	r0, r4
        phost->device.is_ReEnumerated = 0U;
 8006216:	f884 3322 	strb.w	r3, [r4, #802]	@ 0x322
  (void)USBH_LL_Start(phost);
 800621a:	f000 fdf7 	bl	8006e0c <USBH_LL_Start>
  (void)USBH_LL_DriverVBUS(phost, TRUE);
 800621e:	4629      	mov	r1, r5
 8006220:	4620      	mov	r0, r4
 8006222:	f000 fe55 	bl	8006ed0 <USBH_LL_DriverVBUS>
  return USBH_OK;
 8006226:	e615      	b.n	8005e54 <USBH_Process+0xa8>
        USBH_UsrLog("No Class has been registered.");
 8006228:	486b      	ldr	r0, [pc, #428]	@ (80063d8 <USBH_Process+0x62c>)
 800622a:	f000 ffe1 	bl	80071f0 <iprintf>
 800622e:	200a      	movs	r0, #10
 8006230:	f000 fff0 	bl	8007214 <putchar>
 8006234:	e60e      	b.n	8005e54 <USBH_Process+0xa8>
        status = USBH_SetFeature(phost, FEATURE_SELECTOR_REMOTEWAKEUP);
 8006236:	2101      	movs	r1, #1
 8006238:	4620      	mov	r0, r4
 800623a:	f000 fc15 	bl	8006a68 <USBH_SetFeature>
 800623e:	f88d 0017 	strb.w	r0, [sp, #23]
        if (status == USBH_OK)
 8006242:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8006246:	2b00      	cmp	r3, #0
 8006248:	d040      	beq.n	80062cc <USBH_Process+0x520>
        else if (status == USBH_NOT_SUPPORTED)
 800624a:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800624e:	2b03      	cmp	r3, #3
 8006250:	f47f ae00 	bne.w	8005e54 <USBH_Process+0xa8>
          USBH_UsrLog("Remote wakeup not supported by the device");
 8006254:	4861      	ldr	r0, [pc, #388]	@ (80063dc <USBH_Process+0x630>)
 8006256:	f000 ffcb 	bl	80071f0 <iprintf>
 800625a:	200a      	movs	r0, #10
 800625c:	f000 ffda 	bl	8007214 <putchar>
 8006260:	e6a3      	b.n	8005faa <USBH_Process+0x1fe>
            phost->gState = HOST_ABORT_STATE;
 8006262:	220d      	movs	r2, #13
            USBH_UsrLog("Device not supporting %s class.", phost->pActiveClass->Name);
 8006264:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	@ 0x3f0
 8006268:	485d      	ldr	r0, [pc, #372]	@ (80063e0 <USBH_Process+0x634>)
            phost->gState = HOST_ABORT_STATE;
 800626a:	7022      	strb	r2, [r4, #0]
            USBH_UsrLog("Device not supporting %s class.", phost->pActiveClass->Name);
 800626c:	6819      	ldr	r1, [r3, #0]
 800626e:	f000 ffbf 	bl	80071f0 <iprintf>
 8006272:	200a      	movs	r0, #10
 8006274:	f000 ffce 	bl	8007214 <putchar>
 8006278:	e5ec      	b.n	8005e54 <USBH_Process+0xa8>
        USBH_UsrLog("USB Device Reset Completed");
 800627a:	485a      	ldr	r0, [pc, #360]	@ (80063e4 <USBH_Process+0x638>)
 800627c:	f000 ffb8 	bl	80071f0 <iprintf>
 8006280:	200a      	movs	r0, #10
 8006282:	f000 ffc7 	bl	8007214 <putchar>
        phost->device.RstCnt = 0U;
 8006286:	2200      	movs	r2, #0
        phost->gState = HOST_DEV_ATTACHED;
 8006288:	2302      	movs	r3, #2
        phost->device.RstCnt = 0U;
 800628a:	f884 231f 	strb.w	r2, [r4, #799]	@ 0x31f
        phost->gState = HOST_DEV_ATTACHED;
 800628e:	7023      	strb	r3, [r4, #0]
 8006290:	e5e0      	b.n	8005e54 <USBH_Process+0xa8>
            USBH_UsrLog("USB Reset Failed, Please unplug the Device.");
 8006292:	4855      	ldr	r0, [pc, #340]	@ (80063e8 <USBH_Process+0x63c>)
 8006294:	f000 ffac 	bl	80071f0 <iprintf>
 8006298:	200a      	movs	r0, #10
 800629a:	f000 ffbb 	bl	8007214 <putchar>
            phost->gState = HOST_ABORT_STATE;
 800629e:	230d      	movs	r3, #13
 80062a0:	7023      	strb	r3, [r4, #0]
 80062a2:	e5d7      	b.n	8005e54 <USBH_Process+0xa8>
        phost->gState = HOST_ABORT_STATE;
 80062a4:	230d      	movs	r3, #13
        USBH_ErrLog("Invalid Class Driver.");
 80062a6:	4848      	ldr	r0, [pc, #288]	@ (80063c8 <USBH_Process+0x61c>)
        phost->gState = HOST_ABORT_STATE;
 80062a8:	7023      	strb	r3, [r4, #0]
        USBH_ErrLog("Invalid Class Driver.");
 80062aa:	f000 ffa1 	bl	80071f0 <iprintf>
 80062ae:	484f      	ldr	r0, [pc, #316]	@ (80063ec <USBH_Process+0x640>)
 80062b0:	f000 ff9e 	bl	80071f0 <iprintf>
 80062b4:	200a      	movs	r0, #10
 80062b6:	f000 ffad 	bl	8007214 <putchar>
 80062ba:	e5cb      	b.n	8005e54 <USBH_Process+0xa8>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 80062bc:	2803      	cmp	r0, #3
 80062be:	f47f aec4 	bne.w	800604a <USBH_Process+0x29e>
        USBH_ErrLog("Control error: Get Device configuration descriptor request failed");
 80062c2:	4841      	ldr	r0, [pc, #260]	@ (80063c8 <USBH_Process+0x61c>)
 80062c4:	f000 ff94 	bl	80071f0 <iprintf>
 80062c8:	4849      	ldr	r0, [pc, #292]	@ (80063f0 <USBH_Process+0x644>)
 80062ca:	e788      	b.n	80061de <USBH_Process+0x432>
          USBH_UsrLog("Device remote wakeup enabled");
 80062cc:	4849      	ldr	r0, [pc, #292]	@ (80063f4 <USBH_Process+0x648>)
 80062ce:	e7c2      	b.n	8006256 <USBH_Process+0x4aa>
          USBH_UsrLog("This device has only 1 configuration.");
 80062d0:	4849      	ldr	r0, [pc, #292]	@ (80063f8 <USBH_Process+0x64c>)
 80062d2:	f000 ff8d 	bl	80071f0 <iprintf>
 80062d6:	200a      	movs	r0, #10
 80062d8:	f000 ff9c 	bl	8007214 <putchar>
          phost->gState = HOST_SET_CONFIGURATION;
 80062dc:	2308      	movs	r3, #8
 80062de:	7023      	strb	r3, [r4, #0]
 80062e0:	e5b8      	b.n	8005e54 <USBH_Process+0xa8>
        {
          USBH_UsrLog("Serial Number : N/A");
 80062e2:	4846      	ldr	r0, [pc, #280]	@ (80063fc <USBH_Process+0x650>)
 80062e4:	f000 ff84 	bl	80071f0 <iprintf>
 80062e8:	200a      	movs	r0, #10
 80062ea:	f000 ff93 	bl	8007214 <putchar>
        }
      }
      else
      {
        USBH_UsrLog("Serial Number : N/A");
        Status = USBH_OK;
 80062ee:	2300      	movs	r3, #0
 80062f0:	e6ac      	b.n	800604c <USBH_Process+0x2a0>
        USBH_Delay(2U);
 80062f2:	2002      	movs	r0, #2
 80062f4:	f000 fdfe 	bl	8006ef4 <USBH_Delay>
        phost->device.address = USBH_DEVICE_ADDRESS;
 80062f8:	2101      	movs	r1, #1
        USBH_UsrLog("Address (#%d) assigned.", phost->device.address);
 80062fa:	4841      	ldr	r0, [pc, #260]	@ (8006400 <USBH_Process+0x654>)
        phost->device.address = USBH_DEVICE_ADDRESS;
 80062fc:	f884 131c 	strb.w	r1, [r4, #796]	@ 0x31c
        USBH_UsrLog("Address (#%d) assigned.", phost->device.address);
 8006300:	f000 ff76 	bl	80071f0 <iprintf>
 8006304:	200a      	movs	r0, #10
 8006306:	f000 ff85 	bl	8007214 <putchar>
        phost->EnumState = ENUM_GET_CFG_DESC;
 800630a:	2203      	movs	r2, #3
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 800630c:	79a3      	ldrb	r3, [r4, #6]
 800630e:	f894 131d 	ldrb.w	r1, [r4, #797]	@ 0x31d
        phost->EnumState = ENUM_GET_CFG_DESC;
 8006312:	7062      	strb	r2, [r4, #1]
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 8006314:	9501      	str	r5, [sp, #4]
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 8006316:	9302      	str	r3, [sp, #8]
 8006318:	2280      	movs	r2, #128	@ 0x80
 800631a:	f894 331c 	ldrb.w	r3, [r4, #796]	@ 0x31c
 800631e:	4620      	mov	r0, r4
 8006320:	9100      	str	r1, [sp, #0]
 8006322:	7921      	ldrb	r1, [r4, #4]
 8006324:	f000 fc62 	bl	8006bec <USBH_OpenPipe>
        (void)USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 8006328:	79a2      	ldrb	r2, [r4, #6]
 800632a:	f894 131d 	ldrb.w	r1, [r4, #797]	@ 0x31d
 800632e:	4620      	mov	r0, r4
 8006330:	f894 331c 	ldrb.w	r3, [r4, #796]	@ 0x31c
 8006334:	9100      	str	r1, [sp, #0]
 8006336:	e9cd 5201 	strd	r5, r2, [sp, #4]
 800633a:	462a      	mov	r2, r5
 800633c:	7961      	ldrb	r1, [r4, #5]
 800633e:	f000 fc55 	bl	8006bec <USBH_OpenPipe>
 8006342:	e682      	b.n	800604a <USBH_Process+0x29e>
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
 8006344:	f894 332d 	ldrb.w	r3, [r4, #813]	@ 0x32d
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 8006348:	2201      	movs	r2, #1
        (void)USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 800634a:	f894 131d 	ldrb.w	r1, [r4, #797]	@ 0x31d
 800634e:	9001      	str	r0, [sp, #4]
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
 8006350:	71a3      	strb	r3, [r4, #6]
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 8006352:	7062      	strb	r2, [r4, #1]
 8006354:	e7df      	b.n	8006316 <USBH_Process+0x56a>
        USBH_UsrLog("PID: %xh", phost->device.DevDesc.idProduct);
 8006356:	f8b4 1330 	ldrh.w	r1, [r4, #816]	@ 0x330
 800635a:	482a      	ldr	r0, [pc, #168]	@ (8006404 <USBH_Process+0x658>)
 800635c:	f000 ff48 	bl	80071f0 <iprintf>
 8006360:	200a      	movs	r0, #10
 8006362:	f000 ff57 	bl	8007214 <putchar>
        USBH_UsrLog("VID: %xh", phost->device.DevDesc.idVendor);
 8006366:	f8b4 132e 	ldrh.w	r1, [r4, #814]	@ 0x32e
 800636a:	4827      	ldr	r0, [pc, #156]	@ (8006408 <USBH_Process+0x65c>)
 800636c:	f000 ff40 	bl	80071f0 <iprintf>
 8006370:	200a      	movs	r0, #10
 8006372:	f000 ff4f 	bl	8007214 <putchar>
        phost->EnumState = ENUM_SET_ADDR;
 8006376:	2302      	movs	r3, #2
 8006378:	7063      	strb	r3, [r4, #1]
 800637a:	e666      	b.n	800604a <USBH_Process+0x29e>
          USBH_UsrLog("Control error, Device not Responding Please unplug the Device.");
 800637c:	4814      	ldr	r0, [pc, #80]	@ (80063d0 <USBH_Process+0x624>)
 800637e:	f000 ff37 	bl	80071f0 <iprintf>
 8006382:	200a      	movs	r0, #10
 8006384:	f000 ff46 	bl	8007214 <putchar>
          phost->gState = HOST_ABORT_STATE;
 8006388:	230d      	movs	r3, #13
 800638a:	7023      	strb	r3, [r4, #0]
 800638c:	e65d      	b.n	800604a <USBH_Process+0x29e>
          USBH_UsrLog("Manufacturer : %s", (char *)(void *)phost->device.Data);
 800638e:	4629      	mov	r1, r5
 8006390:	481e      	ldr	r0, [pc, #120]	@ (800640c <USBH_Process+0x660>)
 8006392:	f000 ff2d 	bl	80071f0 <iprintf>
 8006396:	200a      	movs	r0, #10
 8006398:	f000 ff3c 	bl	8007214 <putchar>
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800639c:	2306      	movs	r3, #6
 800639e:	7063      	strb	r3, [r4, #1]
 80063a0:	e653      	b.n	800604a <USBH_Process+0x29e>
          USBH_UsrLog("Serial Number : %s", (char *)(void *)phost->device.Data);
 80063a2:	4629      	mov	r1, r5
 80063a4:	481a      	ldr	r0, [pc, #104]	@ (8006410 <USBH_Process+0x664>)
 80063a6:	f000 ff23 	bl	80071f0 <iprintf>
 80063aa:	200a      	movs	r0, #10
 80063ac:	f000 ff32 	bl	8007214 <putchar>
          Status = USBH_OK;
 80063b0:	e79d      	b.n	80062ee <USBH_Process+0x542>
          USBH_UsrLog("Product : %s", (char *)(void *)phost->device.Data);
 80063b2:	4629      	mov	r1, r5
 80063b4:	4817      	ldr	r0, [pc, #92]	@ (8006414 <USBH_Process+0x668>)
 80063b6:	f000 ff1b 	bl	80071f0 <iprintf>
 80063ba:	200a      	movs	r0, #10
 80063bc:	f000 ff2a 	bl	8007214 <putchar>
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 80063c0:	2307      	movs	r3, #7
 80063c2:	7063      	strb	r3, [r4, #1]
 80063c4:	e641      	b.n	800604a <USBH_Process+0x29e>
 80063c6:	bf00      	nop
 80063c8:	08007e44 	.word	0x08007e44
 80063cc:	08007fa0 	.word	0x08007fa0
 80063d0:	08007ef4 	.word	0x08007ef4
 80063d4:	08007f4c 	.word	0x08007f4c
 80063d8:	0800812c 	.word	0x0800812c
 80063dc:	08008100 	.word	0x08008100
 80063e0:	08008188 	.word	0x08008188
 80063e4:	08007e78 	.word	0x08007e78
 80063e8:	08007e94 	.word	0x08007e94
 80063ec:	080081d0 	.word	0x080081d0
 80063f0:	08007fd4 	.word	0x08007fd4
 80063f4:	080080e0 	.word	0x080080e0
 80063f8:	0800809c 	.word	0x0800809c
 80063fc:	08008074 	.word	0x08008074
 8006400:	08007f88 	.word	0x08007f88
 8006404:	08007f34 	.word	0x08007f34
 8006408:	08007f40 	.word	0x08007f40
 800640c:	08008018 	.word	0x08008018
 8006410:	08008060 	.word	0x08008060
 8006414:	08008040 	.word	0x08008040

08006418 <USBH_LL_IncTimer>:
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_IncTimer(USBH_HandleTypeDef *phost)
{
  phost->Timer++;
 8006418:	f8d0 2438 	ldr.w	r2, [r0, #1080]	@ 0x438
 800641c:	3201      	adds	r2, #1
 800641e:	f8c0 2438 	str.w	r2, [r0, #1080]	@ 0x438
  * @param  phost: Host Handle
  * @retval None
  */
static void USBH_HandleSof(USBH_HandleTypeDef *phost)
{
  if ((phost->gState == HOST_CLASS) && (phost->pActiveClass != NULL))
 8006422:	7802      	ldrb	r2, [r0, #0]
 8006424:	2a0b      	cmp	r2, #11
 8006426:	d000      	beq.n	800642a <USBH_LL_IncTimer+0x12>
}
 8006428:	4770      	bx	lr
  if ((phost->gState == HOST_CLASS) && (phost->pActiveClass != NULL))
 800642a:	f8d0 33f0 	ldr.w	r3, [r0, #1008]	@ 0x3f0
 800642e:	2b00      	cmp	r3, #0
 8006430:	d0fa      	beq.n	8006428 <USBH_LL_IncTimer+0x10>
  {
    phost->pActiveClass->SOFProcess(phost);
 8006432:	699b      	ldr	r3, [r3, #24]
 8006434:	4718      	bx	r3
 8006436:	bf00      	nop

08006438 <USBH_LL_PortEnabled>:
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_PortEnabled(USBH_HandleTypeDef *phost)
{
  phost->device.PortEnabled = 1U;
 8006438:	2301      	movs	r3, #1
 800643a:	f880 3323 	strb.w	r3, [r0, #803]	@ 0x323
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif

  return;
}
 800643e:	4770      	bx	lr

08006440 <USBH_LL_PortDisabled>:
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_PortDisabled(USBH_HandleTypeDef *phost)
{
  phost->device.PortEnabled = 0U;
 8006440:	2300      	movs	r3, #0
 8006442:	f880 3323 	strb.w	r3, [r0, #803]	@ 0x323

  return;
}
 8006446:	4770      	bx	lr

08006448 <USBH_LL_Connect>:
  *         Handle USB Host connection event
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
USBH_StatusTypeDef USBH_LL_Connect(USBH_HandleTypeDef *phost)
{
 8006448:	4603      	mov	r3, r0
  phost->device.is_connected = 1U;
  phost->device.is_disconnected = 0U;
 800644a:	2200      	movs	r2, #0
  phost->device.is_connected = 1U;
 800644c:	2101      	movs	r1, #1
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif

  return USBH_OK;
}
 800644e:	4610      	mov	r0, r2
  phost->device.is_connected = 1U;
 8006450:	f883 1320 	strb.w	r1, [r3, #800]	@ 0x320
  phost->device.is_disconnected = 0U;
 8006454:	f883 2321 	strb.w	r2, [r3, #801]	@ 0x321
  phost->device.is_ReEnumerated = 0U;
 8006458:	f883 2322 	strb.w	r2, [r3, #802]	@ 0x322
}
 800645c:	4770      	bx	lr
 800645e:	bf00      	nop

08006460 <USBH_LL_Disconnect>:
  *         Handle USB Host disconnection event
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
USBH_StatusTypeDef USBH_LL_Disconnect(USBH_HandleTypeDef *phost)
{
 8006460:	b538      	push	{r3, r4, r5, lr}
  /* update device connection states */
  phost->device.is_disconnected = 1U;
 8006462:	2301      	movs	r3, #1
  phost->device.is_connected = 0U;
 8006464:	2500      	movs	r5, #0
{
 8006466:	4604      	mov	r4, r0
  phost->device.is_disconnected = 1U;
 8006468:	f880 3321 	strb.w	r3, [r0, #801]	@ 0x321
  phost->device.PortEnabled = 0U;
 800646c:	f880 5323 	strb.w	r5, [r0, #803]	@ 0x323
  phost->device.is_connected = 0U;
 8006470:	f880 5320 	strb.w	r5, [r0, #800]	@ 0x320

  /* Stop Host */
  (void)USBH_LL_Stop(phost);
 8006474:	f000 fcd6 	bl	8006e24 <USBH_LL_Stop>

  /* FRee Control Pipes */
  (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 8006478:	7921      	ldrb	r1, [r4, #4]
 800647a:	4620      	mov	r0, r4
 800647c:	f000 fbe0 	bl	8006c40 <USBH_FreePipe>
  (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 8006480:	7961      	ldrb	r1, [r4, #5]
 8006482:	4620      	mov	r0, r4
 8006484:	f000 fbdc 	bl	8006c40 <USBH_FreePipe>
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, 0U);
#endif
#endif

  return USBH_OK;
}
 8006488:	4628      	mov	r0, r5
 800648a:	bd38      	pop	{r3, r4, r5, pc}

0800648c <USBH_HandleControl>:
  *         Handles the USB control transfer state machine
  * @param  phost: Host Handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_HandleControl(USBH_HandleTypeDef *phost)
{
 800648c:	b530      	push	{r4, r5, lr}
  uint8_t direction;
  USBH_StatusTypeDef status = USBH_BUSY;
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;

  switch (phost->Control.state)
 800648e:	7e03      	ldrb	r3, [r0, #24]
{
 8006490:	b083      	sub	sp, #12
 8006492:	4604      	mov	r4, r0
  switch (phost->Control.state)
 8006494:	3b01      	subs	r3, #1
 8006496:	2b0a      	cmp	r3, #10
 8006498:	d811      	bhi.n	80064be <USBH_HandleControl+0x32>
 800649a:	e8df f003 	tbb	[pc, r3]
 800649e:	1b13      	.short	0x1b13
 80064a0:	7a627028 	.word	0x7a627028
 80064a4:	584a3f34 	.word	0x584a3f34
 80064a8:	06          	.byte	0x06
 80064a9:	00          	.byte	0x00
      PID; i.e., recovery actions via some other pipe are not required for control
      endpoints. For the Default Control Pipe, a device reset will ultimately be
      required to clear the halt or error condition if the next Setup PID is not
      accepted.
      */
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 80064aa:	7e43      	ldrb	r3, [r0, #25]
 80064ac:	3301      	adds	r3, #1
 80064ae:	b2db      	uxtb	r3, r3
 80064b0:	2b02      	cmp	r3, #2
 80064b2:	7643      	strb	r3, [r0, #25]
 80064b4:	f200 8096 	bhi.w	80065e4 <USBH_HandleControl+0x158>
      {
        /* Do the transmission again, starting from SETUP Packet */
        phost->Control.state = CTRL_SETUP;
 80064b8:	2301      	movs	r3, #1
 80064ba:	7603      	strb	r3, [r0, #24]
        phost->RequestState = CMD_SEND;
 80064bc:	7083      	strb	r3, [r0, #2]
  USBH_StatusTypeDef status = USBH_BUSY;
 80064be:	2001      	movs	r0, #1
    default:
      break;
  }

  return status;
}
 80064c0:	b003      	add	sp, #12
 80064c2:	bd30      	pop	{r4, r5, pc}
      (void)USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 80064c4:	7942      	ldrb	r2, [r0, #5]
 80064c6:	f100 0110 	add.w	r1, r0, #16
 80064ca:	f000 fb55 	bl	8006b78 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 80064ce:	2302      	movs	r3, #2
 80064d0:	7623      	strb	r3, [r4, #24]
      break;
 80064d2:	e7f4      	b.n	80064be <USBH_HandleControl+0x32>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 80064d4:	7941      	ldrb	r1, [r0, #5]
 80064d6:	f000 fcf7 	bl	8006ec8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80064da:	2801      	cmp	r0, #1
 80064dc:	f000 809b 	beq.w	8006616 <USBH_HandleControl+0x18a>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 80064e0:	2804      	cmp	r0, #4
 80064e2:	d001      	beq.n	80064e8 <USBH_HandleControl+0x5c>
 80064e4:	2802      	cmp	r0, #2
 80064e6:	d1ea      	bne.n	80064be <USBH_HandleControl+0x32>
          phost->Control.state = CTRL_ERROR;
 80064e8:	230b      	movs	r3, #11
 80064ea:	7623      	strb	r3, [r4, #24]
 80064ec:	e7e7      	b.n	80064be <USBH_HandleControl+0x32>
      phost->Control.timer = (uint16_t)phost->Timer;
 80064ee:	f8d0 0438 	ldr.w	r0, [r0, #1080]	@ 0x438
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 80064f2:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 80064f4:	81e0      	strh	r0, [r4, #14]
      (void)USBH_CtlReceiveData(phost, phost->Control.buff,
 80064f6:	4620      	mov	r0, r4
 80064f8:	89a2      	ldrh	r2, [r4, #12]
 80064fa:	68a1      	ldr	r1, [r4, #8]
 80064fc:	f000 fb66 	bl	8006bcc <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 8006500:	2304      	movs	r3, #4
 8006502:	7623      	strb	r3, [r4, #24]
      break;
 8006504:	e7db      	b.n	80064be <USBH_HandleControl+0x32>
      (void)USBH_CtlReceiveData(phost, NULL, 0U, phost->Control.pipe_in);
 8006506:	2200      	movs	r2, #0
 8006508:	7903      	ldrb	r3, [r0, #4]
 800650a:	4611      	mov	r1, r2
 800650c:	f000 fb5e 	bl	8006bcc <USBH_CtlReceiveData>
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8006510:	2208      	movs	r2, #8
      phost->Control.timer = (uint16_t)phost->Timer;
 8006512:	f8d4 3438 	ldr.w	r3, [r4, #1080]	@ 0x438
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8006516:	7622      	strb	r2, [r4, #24]
      phost->Control.timer = (uint16_t)phost->Timer;
 8006518:	81e3      	strh	r3, [r4, #14]
      break;
 800651a:	e7d0      	b.n	80064be <USBH_HandleControl+0x32>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800651c:	7901      	ldrb	r1, [r0, #4]
 800651e:	f000 fcd3 	bl	8006ec8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8006522:	2801      	cmp	r0, #1
 8006524:	d04d      	beq.n	80065c2 <USBH_HandleControl+0x136>
      else if (URB_Status == USBH_URB_ERROR)
 8006526:	2804      	cmp	r0, #4
 8006528:	d0de      	beq.n	80064e8 <USBH_HandleControl+0x5c>
        if (URB_Status == USBH_URB_STALL)
 800652a:	2805      	cmp	r0, #5
 800652c:	d1c7      	bne.n	80064be <USBH_HandleControl+0x32>
        status = USBH_NOT_SUPPORTED;
 800652e:	2003      	movs	r0, #3
 8006530:	e7c6      	b.n	80064c0 <USBH_HandleControl+0x34>
      (void)USBH_CtlSendData(phost, NULL, 0U, phost->Control.pipe_out, 1U);
 8006532:	2200      	movs	r2, #0
 8006534:	2001      	movs	r0, #1
 8006536:	7963      	ldrb	r3, [r4, #5]
 8006538:	4611      	mov	r1, r2
 800653a:	9000      	str	r0, [sp, #0]
 800653c:	4620      	mov	r0, r4
 800653e:	f000 fb2b 	bl	8006b98 <USBH_CtlSendData>
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8006542:	220a      	movs	r2, #10
      phost->Control.timer = (uint16_t)phost->Timer;
 8006544:	f8d4 3438 	ldr.w	r3, [r4, #1080]	@ 0x438
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8006548:	7622      	strb	r2, [r4, #24]
      phost->Control.timer = (uint16_t)phost->Timer;
 800654a:	81e3      	strh	r3, [r4, #14]
      break;
 800654c:	e7b7      	b.n	80064be <USBH_HandleControl+0x32>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 800654e:	7941      	ldrb	r1, [r0, #5]
 8006550:	f000 fcba 	bl	8006ec8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8006554:	2801      	cmp	r0, #1
 8006556:	d034      	beq.n	80065c2 <USBH_HandleControl+0x136>
      else if (URB_Status == USBH_URB_NOTREADY)
 8006558:	2802      	cmp	r0, #2
 800655a:	d02f      	beq.n	80065bc <USBH_HandleControl+0x130>
        if (URB_Status == USBH_URB_ERROR)
 800655c:	2804      	cmp	r0, #4
 800655e:	d1ae      	bne.n	80064be <USBH_HandleControl+0x32>
 8006560:	e7c2      	b.n	80064e8 <USBH_HandleControl+0x5c>
      (void)USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 8006562:	2001      	movs	r0, #1
 8006564:	7963      	ldrb	r3, [r4, #5]
 8006566:	89a2      	ldrh	r2, [r4, #12]
 8006568:	68a1      	ldr	r1, [r4, #8]
 800656a:	9000      	str	r0, [sp, #0]
 800656c:	4620      	mov	r0, r4
 800656e:	f000 fb13 	bl	8006b98 <USBH_CtlSendData>
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8006572:	2206      	movs	r2, #6
      phost->Control.timer = (uint16_t)phost->Timer;
 8006574:	f8d4 3438 	ldr.w	r3, [r4, #1080]	@ 0x438
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8006578:	7622      	strb	r2, [r4, #24]
      phost->Control.timer = (uint16_t)phost->Timer;
 800657a:	81e3      	strh	r3, [r4, #14]
      break;
 800657c:	e79f      	b.n	80064be <USBH_HandleControl+0x32>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800657e:	7901      	ldrb	r1, [r0, #4]
 8006580:	f000 fca2 	bl	8006ec8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8006584:	2801      	cmp	r0, #1
 8006586:	d019      	beq.n	80065bc <USBH_HandleControl+0x130>
      if (URB_Status == USBH_URB_STALL)
 8006588:	2805      	cmp	r0, #5
 800658a:	d0d0      	beq.n	800652e <USBH_HandleControl+0xa2>
        if (URB_Status == USBH_URB_ERROR)
 800658c:	2804      	cmp	r0, #4
 800658e:	d0ab      	beq.n	80064e8 <USBH_HandleControl+0x5c>
 8006590:	e795      	b.n	80064be <USBH_HandleControl+0x32>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8006592:	7941      	ldrb	r1, [r0, #5]
 8006594:	f000 fc98 	bl	8006ec8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8006598:	3801      	subs	r0, #1
 800659a:	2804      	cmp	r0, #4
 800659c:	d88f      	bhi.n	80064be <USBH_HandleControl+0x32>
 800659e:	a301      	add	r3, pc, #4	@ (adr r3, 80065a4 <USBH_HandleControl+0x118>)
 80065a0:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
 80065a4:	080065d1 	.word	0x080065d1
 80065a8:	080065cb 	.word	0x080065cb
 80065ac:	080064bf 	.word	0x080064bf
 80065b0:	080065dd 	.word	0x080065dd
 80065b4:	080065d7 	.word	0x080065d7
          if (direction == USB_D2H)
 80065b8:	2b00      	cmp	r3, #0
 80065ba:	da09      	bge.n	80065d0 <USBH_HandleControl+0x144>
            phost->Control.state = CTRL_STATUS_OUT;
 80065bc:	2309      	movs	r3, #9
 80065be:	7623      	strb	r3, [r4, #24]
 80065c0:	e77d      	b.n	80064be <USBH_HandleControl+0x32>
        phost->Control.state = CTRL_COMPLETE;
 80065c2:	230d      	movs	r3, #13
        status = USBH_OK;
 80065c4:	2000      	movs	r0, #0
        phost->Control.state = CTRL_COMPLETE;
 80065c6:	7623      	strb	r3, [r4, #24]
        status = USBH_OK;
 80065c8:	e77a      	b.n	80064c0 <USBH_HandleControl+0x34>
        phost->Control.state = CTRL_DATA_OUT;
 80065ca:	2305      	movs	r3, #5
 80065cc:	7623      	strb	r3, [r4, #24]
 80065ce:	e776      	b.n	80064be <USBH_HandleControl+0x32>
        phost->Control.state = CTRL_STATUS_IN;
 80065d0:	2307      	movs	r3, #7
 80065d2:	7623      	strb	r3, [r4, #24]
 80065d4:	e773      	b.n	80064be <USBH_HandleControl+0x32>
        phost->Control.state = CTRL_STALLED;
 80065d6:	230c      	movs	r3, #12
 80065d8:	7623      	strb	r3, [r4, #24]
        status = USBH_NOT_SUPPORTED;
 80065da:	e7a8      	b.n	800652e <USBH_HandleControl+0xa2>
          phost->Control.state = CTRL_ERROR;
 80065dc:	230b      	movs	r3, #11
 80065de:	7623      	strb	r3, [r4, #24]
        status = USBH_FAIL;
 80065e0:	2002      	movs	r0, #2
 80065e2:	e76d      	b.n	80064c0 <USBH_HandleControl+0x34>
        phost->Control.errorcount = 0U;
 80065e4:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 80065e6:	f8d0 3448 	ldr.w	r3, [r0, #1096]	@ 0x448
 80065ea:	2106      	movs	r1, #6
 80065ec:	4798      	blx	r3
        USBH_ErrLog("Control error: Device not responding");
 80065ee:	480f      	ldr	r0, [pc, #60]	@ (800662c <USBH_HandleControl+0x1a0>)
        phost->Control.errorcount = 0U;
 80065f0:	7665      	strb	r5, [r4, #25]
        USBH_ErrLog("Control error: Device not responding");
 80065f2:	f000 fdfd 	bl	80071f0 <iprintf>
 80065f6:	480e      	ldr	r0, [pc, #56]	@ (8006630 <USBH_HandleControl+0x1a4>)
 80065f8:	f000 fdfa 	bl	80071f0 <iprintf>
 80065fc:	200a      	movs	r0, #10
 80065fe:	f000 fe09 	bl	8007214 <putchar>
        (void)USBH_FreePipe(phost, phost->Control.pipe_out);
 8006602:	7961      	ldrb	r1, [r4, #5]
 8006604:	4620      	mov	r0, r4
 8006606:	f000 fb1b 	bl	8006c40 <USBH_FreePipe>
        (void)USBH_FreePipe(phost, phost->Control.pipe_in);
 800660a:	7921      	ldrb	r1, [r4, #4]
 800660c:	4620      	mov	r0, r4
 800660e:	f000 fb17 	bl	8006c40 <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 8006612:	7025      	strb	r5, [r4, #0]
        status = USBH_FAIL;
 8006614:	e7e4      	b.n	80065e0 <USBH_HandleControl+0x154>
        if (phost->Control.setup.b.wLength.w != 0U)
 8006616:	8ae2      	ldrh	r2, [r4, #22]
 8006618:	f994 3010 	ldrsb.w	r3, [r4, #16]
 800661c:	2a00      	cmp	r2, #0
 800661e:	d0cb      	beq.n	80065b8 <USBH_HandleControl+0x12c>
          if (direction == USB_D2H)
 8006620:	2b00      	cmp	r3, #0
 8006622:	dad2      	bge.n	80065ca <USBH_HandleControl+0x13e>
            phost->Control.state = CTRL_DATA_IN;
 8006624:	2303      	movs	r3, #3
 8006626:	7623      	strb	r3, [r4, #24]
 8006628:	e749      	b.n	80064be <USBH_HandleControl+0x32>
 800662a:	bf00      	nop
 800662c:	08007e44 	.word	0x08007e44
 8006630:	08008200 	.word	0x08008200

08006634 <USBH_Get_DevDesc>:
  if (length > sizeof(phost->device.Data))
 8006634:	f5b1 7f00 	cmp.w	r1, #512	@ 0x200
{
 8006638:	b538      	push	{r3, r4, r5, lr}
  if (length > sizeof(phost->device.Data))
 800663a:	d847      	bhi.n	80066cc <USBH_Get_DevDesc+0x98>
  if (phost->RequestState == CMD_SEND)
 800663c:	7883      	ldrb	r3, [r0, #2]
 800663e:	460d      	mov	r5, r1
 8006640:	4604      	mov	r4, r0
 8006642:	2b01      	cmp	r3, #1
 8006644:	d009      	beq.n	800665a <USBH_Get_DevDesc+0x26>
  switch (phost->RequestState)
 8006646:	2b02      	cmp	r3, #2
 8006648:	d116      	bne.n	8006678 <USBH_Get_DevDesc+0x44>
      status = USBH_HandleControl(phost);
 800664a:	f7ff ff1f 	bl	800648c <USBH_HandleControl>
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800664e:	b1a8      	cbz	r0, 800667c <USBH_Get_DevDesc+0x48>
 8006650:	2803      	cmp	r0, #3
 8006652:	d013      	beq.n	800667c <USBH_Get_DevDesc+0x48>
      else if (status == USBH_FAIL)
 8006654:	2802      	cmp	r0, #2
 8006656:	d056      	beq.n	8006706 <USBH_Get_DevDesc+0xd2>
}
 8006658:	bd38      	pop	{r3, r4, r5, pc}
    phost->Control.setup.b.wValue.w = value_idx;
 800665a:	f44f 7280 	mov.w	r2, #256	@ 0x100
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800665e:	f44f 60d0 	mov.w	r0, #1664	@ 0x680
    phost->Control.setup.b.wLength.w = length;
 8006662:	82e1      	strh	r1, [r4, #22]
      phost->Control.length = length;
 8006664:	81a1      	strh	r1, [r4, #12]
      phost->RequestState = CMD_WAIT;
 8006666:	2102      	movs	r1, #2
    phost->Control.setup.b.wValue.w = value_idx;
 8006668:	f8c4 2012 	str.w	r2, [r4, #18]
                              USB_DESC_DEVICE, phost->device.Data, length);
 800666c:	f504 728e 	add.w	r2, r4, #284	@ 0x11c
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8006670:	8220      	strh	r0, [r4, #16]
      phost->Control.state = CTRL_SETUP;
 8006672:	7623      	strb	r3, [r4, #24]
      phost->RequestState = CMD_WAIT;
 8006674:	70a1      	strb	r1, [r4, #2]
      phost->Control.buff = buff;
 8006676:	60a2      	str	r2, [r4, #8]
  status = USBH_GetDescriptor(phost,
 8006678:	2001      	movs	r0, #1
}
 800667a:	bd38      	pop	{r3, r4, r5, pc}
        phost->RequestState = CMD_SEND;
 800667c:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 800667e:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
 8006680:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8006682:	7623      	strb	r3, [r4, #24]
  if (status == USBH_OK)
 8006684:	bb58      	cbnz	r0, 80066de <USBH_Get_DevDesc+0xaa>
  dev_desc->bLength            = *(uint8_t *)(buf +  0U);
 8006686:	f8b4 211c 	ldrh.w	r2, [r4, #284]	@ 0x11c
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4U);
 800668a:	f8d4 3120 	ldr.w	r3, [r4, #288]	@ 0x120
  dev_desc->bLength            = *(uint8_t *)(buf +  0U);
 800668e:	f8a4 2326 	strh.w	r2, [r4, #806]	@ 0x326
  dev_desc->bcdUSB             = LE16(buf +  2U);
 8006692:	f8b4 211e 	ldrh.w	r2, [r4, #286]	@ 0x11e
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4U);
 8006696:	f8c4 332a 	str.w	r3, [r4, #810]	@ 0x32a
 800669a:	0e1b      	lsrs	r3, r3, #24
  dev_desc->bcdUSB             = LE16(buf +  2U);
 800669c:	f8a4 2328 	strh.w	r2, [r4, #808]	@ 0x328
  if ((phost->device.speed == (uint8_t)USBH_SPEED_HIGH) ||
 80066a0:	f894 231d 	ldrb.w	r2, [r4, #797]	@ 0x31d
 80066a4:	2a01      	cmp	r2, #1
 80066a6:	d91c      	bls.n	80066e2 <USBH_Get_DevDesc+0xae>
  else if (phost->device.speed == (uint8_t)USBH_SPEED_LOW)
 80066a8:	2a02      	cmp	r2, #2
 80066aa:	d029      	beq.n	8006700 <USBH_Get_DevDesc+0xcc>
    status = USBH_NOT_SUPPORTED;
 80066ac:	2003      	movs	r0, #3
  if (length > 8U)
 80066ae:	2d08      	cmp	r5, #8
 80066b0:	d9d2      	bls.n	8006658 <USBH_Get_DevDesc+0x24>
    dev_desc->idVendor           = LE16(buf +  8U);
 80066b2:	f8d4 1124 	ldr.w	r1, [r4, #292]	@ 0x124
    dev_desc->bcdDevice          = LE16(buf + 12U);
 80066b6:	f8b4 2128 	ldrh.w	r2, [r4, #296]	@ 0x128
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14U);
 80066ba:	f8d4 312a 	ldr.w	r3, [r4, #298]	@ 0x12a
    dev_desc->idVendor           = LE16(buf +  8U);
 80066be:	f8c4 132e 	str.w	r1, [r4, #814]	@ 0x32e
    dev_desc->bcdDevice          = LE16(buf + 12U);
 80066c2:	f8a4 2332 	strh.w	r2, [r4, #818]	@ 0x332
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14U);
 80066c6:	f8c4 3334 	str.w	r3, [r4, #820]	@ 0x334
}
 80066ca:	bd38      	pop	{r3, r4, r5, pc}
    USBH_ErrLog("Control error: Get Device Descriptor failed, data buffer size issue");
 80066cc:	4811      	ldr	r0, [pc, #68]	@ (8006714 <USBH_Get_DevDesc+0xe0>)
 80066ce:	f000 fd8f 	bl	80071f0 <iprintf>
 80066d2:	4811      	ldr	r0, [pc, #68]	@ (8006718 <USBH_Get_DevDesc+0xe4>)
 80066d4:	f000 fd8c 	bl	80071f0 <iprintf>
 80066d8:	200a      	movs	r0, #10
 80066da:	f000 fd9b 	bl	8007214 <putchar>
    return USBH_NOT_SUPPORTED;
 80066de:	2003      	movs	r0, #3
}
 80066e0:	bd38      	pop	{r3, r4, r5, pc}
    switch (dev_desc->bMaxPacketSize)
 80066e2:	2b20      	cmp	r3, #32
 80066e4:	d812      	bhi.n	800670c <USBH_Get_DevDesc+0xd8>
 80066e6:	2b07      	cmp	r3, #7
 80066e8:	d906      	bls.n	80066f8 <USBH_Get_DevDesc+0xc4>
 80066ea:	3b08      	subs	r3, #8
 80066ec:	4a0b      	ldr	r2, [pc, #44]	@ (800671c <USBH_Get_DevDesc+0xe8>)
 80066ee:	b2db      	uxtb	r3, r3
 80066f0:	fa22 f303 	lsr.w	r3, r2, r3
 80066f4:	07db      	lsls	r3, r3, #31
 80066f6:	d4da      	bmi.n	80066ae <USBH_Get_DevDesc+0x7a>
      dev_desc->bMaxPacketSize = 8U;
 80066f8:	2308      	movs	r3, #8
 80066fa:	f884 332d 	strb.w	r3, [r4, #813]	@ 0x32d
 80066fe:	e7d6      	b.n	80066ae <USBH_Get_DevDesc+0x7a>
    if (dev_desc->bMaxPacketSize != 8U)
 8006700:	2b08      	cmp	r3, #8
 8006702:	d1f9      	bne.n	80066f8 <USBH_Get_DevDesc+0xc4>
 8006704:	e7d3      	b.n	80066ae <USBH_Get_DevDesc+0x7a>
        phost->RequestState = CMD_SEND;
 8006706:	2301      	movs	r3, #1
 8006708:	70a3      	strb	r3, [r4, #2]
}
 800670a:	bd38      	pop	{r3, r4, r5, pc}
    switch (dev_desc->bMaxPacketSize)
 800670c:	2b40      	cmp	r3, #64	@ 0x40
 800670e:	d1f3      	bne.n	80066f8 <USBH_Get_DevDesc+0xc4>
 8006710:	e7cd      	b.n	80066ae <USBH_Get_DevDesc+0x7a>
 8006712:	bf00      	nop
 8006714:	08007e44 	.word	0x08007e44
 8006718:	08008228 	.word	0x08008228
 800671c:	01000101 	.word	0x01000101

08006720 <USBH_Get_CfgDesc>:
  if (length > sizeof(phost->device.CfgDesc_Raw))
 8006720:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
{
 8006724:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006728:	b085      	sub	sp, #20
  if (length > sizeof(phost->device.CfgDesc_Raw))
 800672a:	d867      	bhi.n	80067fc <USBH_Get_CfgDesc+0xdc>
  if (phost->RequestState == CMD_SEND)
 800672c:	7883      	ldrb	r3, [r0, #2]
 800672e:	4605      	mov	r5, r0
 8006730:	460e      	mov	r6, r1
 8006732:	f100 041c 	add.w	r4, r0, #28
 8006736:	2b01      	cmp	r3, #1
 8006738:	d00f      	beq.n	800675a <USBH_Get_CfgDesc+0x3a>
  switch (phost->RequestState)
 800673a:	2b02      	cmp	r3, #2
 800673c:	d003      	beq.n	8006746 <USBH_Get_CfgDesc+0x26>
  status = USBH_GetDescriptor(phost, (USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD),
 800673e:	2001      	movs	r0, #1
}
 8006740:	b005      	add	sp, #20
 8006742:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      status = USBH_HandleControl(phost);
 8006746:	f7ff fea1 	bl	800648c <USBH_HandleControl>
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800674a:	b1a0      	cbz	r0, 8006776 <USBH_Get_CfgDesc+0x56>
 800674c:	2803      	cmp	r0, #3
 800674e:	d012      	beq.n	8006776 <USBH_Get_CfgDesc+0x56>
      else if (status == USBH_FAIL)
 8006750:	2802      	cmp	r0, #2
 8006752:	d1f5      	bne.n	8006740 <USBH_Get_CfgDesc+0x20>
        phost->RequestState = CMD_SEND;
 8006754:	2301      	movs	r3, #1
 8006756:	70ab      	strb	r3, [r5, #2]
  if (status == USBH_OK)
 8006758:	e7f2      	b.n	8006740 <USBH_Get_CfgDesc+0x20>
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800675a:	f44f 61d0 	mov.w	r1, #1664	@ 0x680
      phost->RequestState = CMD_WAIT;
 800675e:	2202      	movs	r2, #2
    phost->Control.setup.b.wLength.w = length;
 8006760:	82c6      	strh	r6, [r0, #22]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8006762:	8201      	strh	r1, [r0, #16]
    phost->Control.setup.b.wValue.w = value_idx;
 8006764:	f44f 7100 	mov.w	r1, #512	@ 0x200
      phost->Control.buff = buff;
 8006768:	6084      	str	r4, [r0, #8]
      phost->Control.length = length;
 800676a:	8186      	strh	r6, [r0, #12]
      phost->Control.state = CTRL_SETUP;
 800676c:	7603      	strb	r3, [r0, #24]
    phost->Control.setup.b.wValue.w = value_idx;
 800676e:	f8c0 1012 	str.w	r1, [r0, #18]
      phost->RequestState = CMD_WAIT;
 8006772:	7082      	strb	r2, [r0, #2]
  if (status == USBH_OK)
 8006774:	e7e3      	b.n	800673e <USBH_Get_CfgDesc+0x1e>
        phost->RequestState = CMD_SEND;
 8006776:	2301      	movs	r3, #1
 8006778:	70ab      	strb	r3, [r5, #2]
        phost->Control.state = CTRL_IDLE;
 800677a:	2300      	movs	r3, #0
 800677c:	762b      	strb	r3, [r5, #24]
  if (status == USBH_OK)
 800677e:	2800      	cmp	r0, #0
 8006780:	d145      	bne.n	800680e <USBH_Get_CfgDesc+0xee>
  if (pdesc->bLength != USB_CONFIGURATION_DESC_SIZE)
 8006782:	7f2b      	ldrb	r3, [r5, #28]
 8006784:	2b09      	cmp	r3, #9
 8006786:	d001      	beq.n	800678c <USBH_Get_CfgDesc+0x6c>
    pdesc->bLength = USB_CONFIGURATION_DESC_SIZE;
 8006788:	2309      	movs	r3, #9
 800678a:	772b      	strb	r3, [r5, #28]
  cfg_desc->wTotalLength        = MIN(((uint16_t) LE16(buf + 2U)), ((uint16_t)USBH_MAX_SIZE_CONFIGURATION));
 800678c:	8bea      	ldrh	r2, [r5, #30]
  cfg_desc->bLength             = *(uint8_t *)(buf + 0U);
 800678e:	2309      	movs	r3, #9
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4U);
 8006790:	f8d5 c020 	ldr.w	ip, [r5, #32]
  cfg_desc->wTotalLength        = MIN(((uint16_t) LE16(buf + 2U)), ((uint16_t)USBH_MAX_SIZE_CONFIGURATION));
 8006794:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
  cfg_desc->bLength             = *(uint8_t *)(buf + 0U);
 8006798:	f885 3338 	strb.w	r3, [r5, #824]	@ 0x338
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4U);
 800679c:	f8c5 c33c 	str.w	ip, [r5, #828]	@ 0x33c
  cfg_desc->wTotalLength        = MIN(((uint16_t) LE16(buf + 2U)), ((uint16_t)USBH_MAX_SIZE_CONFIGURATION));
 80067a0:	bf28      	it	cs
 80067a2:	f44f 7280 	movcs.w	r2, #256	@ 0x100
  if (length > USB_CONFIGURATION_DESC_SIZE)
 80067a6:	429e      	cmp	r6, r3
  cfg_desc->wTotalLength        = MIN(((uint16_t) LE16(buf + 2U)), ((uint16_t)USBH_MAX_SIZE_CONFIGURATION));
 80067a8:	4692      	mov	sl, r2
 80067aa:	f8a5 233a 	strh.w	r2, [r5, #826]	@ 0x33a
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1U);
 80067ae:	7f6a      	ldrb	r2, [r5, #29]
 80067b0:	f885 2339 	strb.w	r2, [r5, #825]	@ 0x339
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8U);
 80067b4:	f895 2024 	ldrb.w	r2, [r5, #36]	@ 0x24
 80067b8:	f885 2340 	strb.w	r2, [r5, #832]	@ 0x340
  if (length > USB_CONFIGURATION_DESC_SIZE)
 80067bc:	d9c0      	bls.n	8006740 <USBH_Get_CfgDesc+0x20>
  USBH_StatusTypeDef           status = USBH_OK;
 80067be:	2700      	movs	r7, #0
    ptr = USB_LEN_CFG_DESC;
 80067c0:	469b      	mov	fp, r3
 80067c2:	4629      	mov	r1, r5
  if (length > USB_CONFIGURATION_DESC_SIZE)
 80067c4:	46b8      	mov	r8, r7
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 80067c6:	f1b8 0f04 	cmp.w	r8, #4
 80067ca:	d108      	bne.n	80067de <USBH_Get_CfgDesc+0xbe>
 80067cc:	e014      	b.n	80067f8 <USBH_Get_CfgDesc+0xd8>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 80067ce:	7823      	ldrb	r3, [r4, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
 80067d0:	441c      	add	r4, r3
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 80067d2:	449b      	add	fp, r3
      if (pdesc->bDescriptorType == USB_DESC_TYPE_INTERFACE)
 80067d4:	7863      	ldrb	r3, [r4, #1]
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 80067d6:	fa1f fb8b 	uxth.w	fp, fp
      if (pdesc->bDescriptorType == USB_DESC_TYPE_INTERFACE)
 80067da:	2b04      	cmp	r3, #4
 80067dc:	d01b      	beq.n	8006816 <USBH_Get_CfgDesc+0xf6>
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 80067de:	45da      	cmp	sl, fp
 80067e0:	d8f5      	bhi.n	80067ce <USBH_Get_CfgDesc+0xae>
    if (if_ix < MIN(cfg_desc->bNumInterfaces, (uint8_t)USBH_MAX_NUM_INTERFACES))
 80067e2:	fa5f fc8c 	uxtb.w	ip, ip
 80067e6:	fa5f f388 	uxtb.w	r3, r8
 80067ea:	f1bc 0f04 	cmp.w	ip, #4
 80067ee:	bf28      	it	cs
 80067f0:	f04f 0c04 	movcs.w	ip, #4
 80067f4:	459c      	cmp	ip, r3
 80067f6:	d80a      	bhi.n	800680e <USBH_Get_CfgDesc+0xee>
 80067f8:	4638      	mov	r0, r7
 80067fa:	e7a1      	b.n	8006740 <USBH_Get_CfgDesc+0x20>
    USBH_ErrLog("Control error: Get configuration Descriptor failed, data buffer size issue");
 80067fc:	4874      	ldr	r0, [pc, #464]	@ (80069d0 <USBH_Get_CfgDesc+0x2b0>)
 80067fe:	f000 fcf7 	bl	80071f0 <iprintf>
 8006802:	4874      	ldr	r0, [pc, #464]	@ (80069d4 <USBH_Get_CfgDesc+0x2b4>)
 8006804:	f000 fcf4 	bl	80071f0 <iprintf>
 8006808:	200a      	movs	r0, #10
 800680a:	f000 fd03 	bl	8007214 <putchar>
    return USBH_NOT_SUPPORTED;
 800680e:	2003      	movs	r0, #3
}
 8006810:	b005      	add	sp, #20
 8006812:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (pdesc->bLength != USB_INTERFACE_DESC_SIZE)
 8006816:	7823      	ldrb	r3, [r4, #0]
 8006818:	2b09      	cmp	r3, #9
 800681a:	d001      	beq.n	8006820 <USBH_Get_CfgDesc+0x100>
          pdesc->bLength = USB_INTERFACE_DESC_SIZE;
 800681c:	2309      	movs	r3, #9
 800681e:	7023      	strb	r3, [r4, #0]
  if_descriptor->bLength            = *(uint8_t *)(buf + 0U);
 8006820:	f04f 0309 	mov.w	r3, #9
 8006824:	f881 3342 	strb.w	r3, [r1, #834]	@ 0x342
  if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1U);
 8006828:	7862      	ldrb	r2, [r4, #1]
 800682a:	f881 2343 	strb.w	r2, [r1, #835]	@ 0x343
  if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2U);
 800682e:	78a2      	ldrb	r2, [r4, #2]
 8006830:	f881 2344 	strb.w	r2, [r1, #836]	@ 0x344
  if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3U);
 8006834:	78e2      	ldrb	r2, [r4, #3]
 8006836:	f881 2345 	strb.w	r2, [r1, #837]	@ 0x345
  if_descriptor->bNumEndpoints      = MIN(*(uint8_t *)(buf + 4U), USBH_MAX_NUM_ENDPOINTS);
 800683a:	7920      	ldrb	r0, [r4, #4]
 800683c:	2804      	cmp	r0, #4
 800683e:	4606      	mov	r6, r0
 8006840:	bf28      	it	cs
 8006842:	2604      	movcs	r6, #4
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 8006844:	45da      	cmp	sl, fp
  if_descriptor->bNumEndpoints      = MIN(*(uint8_t *)(buf + 4U), USBH_MAX_NUM_ENDPOINTS);
 8006846:	f881 6346 	strb.w	r6, [r1, #838]	@ 0x346
  if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5U);
 800684a:	f894 9005 	ldrb.w	r9, [r4, #5]
 800684e:	f881 9347 	strb.w	r9, [r1, #839]	@ 0x347
  if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6U);
 8006852:	79a2      	ldrb	r2, [r4, #6]
 8006854:	f881 2348 	strb.w	r2, [r1, #840]	@ 0x348
  if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7U);
 8006858:	79e3      	ldrb	r3, [r4, #7]
 800685a:	f881 3349 	strb.w	r3, [r1, #841]	@ 0x349
  if_descriptor->iInterface         = *(uint8_t *)(buf + 8U);
 800685e:	f894 e008 	ldrb.w	lr, [r4, #8]
  if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7U);
 8006862:	9303      	str	r3, [sp, #12]
  if_descriptor->iInterface         = *(uint8_t *)(buf + 8U);
 8006864:	f881 e34a 	strb.w	lr, [r1, #842]	@ 0x34a
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 8006868:	f240 80a5 	bls.w	80069b6 <USBH_Get_CfgDesc+0x296>
 800686c:	2800      	cmp	r0, #0
 800686e:	f000 80a2 	beq.w	80069b6 <USBH_Get_CfgDesc+0x296>
                ((pif->bInterfaceSubClass == 0x02U) || (pif->bInterfaceSubClass == 0x03U)))
 8006872:	3a02      	subs	r2, #2
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 8006874:	2309      	movs	r3, #9
              pdesc->bLength = USB_ENDPOINT_DESC_SIZE;
 8006876:	9102      	str	r1, [sp, #8]
            if ((pif->bInterfaceClass == 0x01U) &&
 8006878:	b2d2      	uxtb	r2, r2
 800687a:	9201      	str	r2, [sp, #4]
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0U);
 800687c:	222a      	movs	r2, #42	@ 0x2a
 800687e:	fb02 f208 	mul.w	r2, r2, r8
 8006882:	9200      	str	r2, [sp, #0]
        ep_ix = 0U;
 8006884:	2200      	movs	r2, #0
 8006886:	e004      	b.n	8006892 <USBH_Get_CfgDesc+0x172>
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 8006888:	4296      	cmp	r6, r2
 800688a:	d962      	bls.n	8006952 <USBH_Get_CfgDesc+0x232>
 800688c:	45da      	cmp	sl, fp
 800688e:	d960      	bls.n	8006952 <USBH_Get_CfgDesc+0x232>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 8006890:	7823      	ldrb	r3, [r4, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
 8006892:	441c      	add	r4, r3
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 8006894:	445b      	add	r3, fp
 8006896:	fa1f fb83 	uxth.w	fp, r3
          if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 800689a:	7863      	ldrb	r3, [r4, #1]
 800689c:	2b05      	cmp	r3, #5
 800689e:	d1f3      	bne.n	8006888 <USBH_Get_CfgDesc+0x168>
            if ((pif->bInterfaceClass == 0x01U) &&
 80068a0:	f1b9 0f01 	cmp.w	r9, #1
 80068a4:	d048      	beq.n	8006938 <USBH_Get_CfgDesc+0x218>
              pdesc->bLength = USB_ENDPOINT_DESC_SIZE;
 80068a6:	f04f 0307 	mov.w	r3, #7
 80068aa:	2107      	movs	r1, #7
 80068ac:	7023      	strb	r3, [r4, #0]
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0U);
 80068ae:	3201      	adds	r2, #1
 80068b0:	9b00      	ldr	r3, [sp, #0]
 80068b2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80068b6:	442b      	add	r3, r5
 80068b8:	f883 1344 	strb.w	r1, [r3, #836]	@ 0x344
  ep_descriptor->bDescriptorType  = *(uint8_t *)(buf + 1U);
 80068bc:	7861      	ldrb	r1, [r4, #1]
 80068be:	f883 1345 	strb.w	r1, [r3, #837]	@ 0x345
  ep_descriptor->bEndpointAddress = *(uint8_t *)(buf + 2U);
 80068c2:	78a1      	ldrb	r1, [r4, #2]
 80068c4:	f883 1346 	strb.w	r1, [r3, #838]	@ 0x346
  ep_descriptor->bmAttributes     = *(uint8_t *)(buf + 3U);
 80068c8:	78e1      	ldrb	r1, [r4, #3]
 80068ca:	f883 1347 	strb.w	r1, [r3, #839]	@ 0x347
  ep_descriptor->wMaxPacketSize   = LE16(buf + 4U);
 80068ce:	88a0      	ldrh	r0, [r4, #4]
  if ((ep_descriptor->wMaxPacketSize == 0x00U) ||
 80068d0:	1e47      	subs	r7, r0, #1
  ep_descriptor->wMaxPacketSize   = LE16(buf + 4U);
 80068d2:	f8a3 0348 	strh.w	r0, [r3, #840]	@ 0x348
  ep_descriptor->bInterval        = *(uint8_t *)(buf + 6U);
 80068d6:	f894 e006 	ldrb.w	lr, [r4, #6]
  if ((ep_descriptor->wMaxPacketSize == 0x00U) ||
 80068da:	f5b7 7f00 	cmp.w	r7, #512	@ 0x200
  ep_descriptor->bInterval        = *(uint8_t *)(buf + 6U);
 80068de:	f883 e34a 	strb.w	lr, [r3, #842]	@ 0x34a
  if ((ep_descriptor->wMaxPacketSize == 0x00U) ||
 80068e2:	d20e      	bcs.n	8006902 <USBH_Get_CfgDesc+0x1e2>
  if (phost->device.speed == (uint8_t)USBH_SPEED_HIGH)
 80068e4:	f895 731d 	ldrb.w	r7, [r5, #797]	@ 0x31d
 80068e8:	2f00      	cmp	r7, #0
 80068ea:	d03b      	beq.n	8006964 <USBH_Get_CfgDesc+0x244>
  else if (phost->device.speed == (uint8_t)USBH_SPEED_FULL)
 80068ec:	2f01      	cmp	r7, #1
 80068ee:	d05e      	beq.n	80069ae <USBH_Get_CfgDesc+0x28e>
  else if (phost->device.speed == (uint8_t)USBH_SPEED_LOW)
 80068f0:	2f02      	cmp	r7, #2
 80068f2:	d11e      	bne.n	8006932 <USBH_Get_CfgDesc+0x212>
    if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_CTRL)
 80068f4:	f011 0703 	ands.w	r7, r1, #3
 80068f8:	d15b      	bne.n	80069b2 <USBH_Get_CfgDesc+0x292>
        status = USBH_NOT_SUPPORTED;
 80068fa:	2808      	cmp	r0, #8
 80068fc:	bf18      	it	ne
 80068fe:	2703      	movne	r7, #3
 8006900:	e018      	b.n	8006934 <USBH_Get_CfgDesc+0x214>
  if (phost->device.speed == (uint8_t)USBH_SPEED_HIGH)
 8006902:	f895 331d 	ldrb.w	r3, [r5, #797]	@ 0x31d
 8006906:	2b00      	cmp	r3, #0
 8006908:	d036      	beq.n	8006978 <USBH_Get_CfgDesc+0x258>
  else if (phost->device.speed == (uint8_t)USBH_SPEED_FULL)
 800690a:	2b01      	cmp	r3, #1
 800690c:	d041      	beq.n	8006992 <USBH_Get_CfgDesc+0x272>
  else if (phost->device.speed == (uint8_t)USBH_SPEED_LOW)
 800690e:	2b02      	cmp	r3, #2
 8006910:	d10f      	bne.n	8006932 <USBH_Get_CfgDesc+0x212>
    if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_CTRL)
 8006912:	f011 0703 	ands.w	r7, r1, #3
 8006916:	d00c      	beq.n	8006932 <USBH_Get_CfgDesc+0x212>
 8006918:	2303      	movs	r3, #3
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->wMaxPacketSize > 8U))
 800691a:	2808      	cmp	r0, #8
 800691c:	bf94      	ite	ls
 800691e:	2000      	movls	r0, #0
 8006920:	2001      	movhi	r0, #1
 8006922:	f1be 0f00 	cmp.w	lr, #0
 8006926:	bf08      	it	eq
 8006928:	f040 0001 	orreq.w	r0, r0, #1
 800692c:	b908      	cbnz	r0, 8006932 <USBH_Get_CfgDesc+0x212>
 800692e:	2f03      	cmp	r7, #3
 8006930:	d04b      	beq.n	80069ca <USBH_Get_CfgDesc+0x2aa>
        status = USBH_NOT_SUPPORTED;
 8006932:	2703      	movs	r7, #3
            ep_ix++;
 8006934:	b2d2      	uxtb	r2, r2
 8006936:	e7a7      	b.n	8006888 <USBH_Get_CfgDesc+0x168>
            if ((pif->bInterfaceClass == 0x01U) &&
 8006938:	9b01      	ldr	r3, [sp, #4]
 800693a:	2b01      	cmp	r3, #1
 800693c:	d8b3      	bhi.n	80068a6 <USBH_Get_CfgDesc+0x186>
              if ((pif->bInterfaceProtocol == 0x00U) && (pdesc->bLength != 0x09U))
 800693e:	9b03      	ldr	r3, [sp, #12]
 8006940:	7821      	ldrb	r1, [r4, #0]
 8006942:	2b00      	cmp	r3, #0
 8006944:	d1b3      	bne.n	80068ae <USBH_Get_CfgDesc+0x18e>
 8006946:	2909      	cmp	r1, #9
 8006948:	d001      	beq.n	800694e <USBH_Get_CfgDesc+0x22e>
                pdesc->bLength = 0x09U;
 800694a:	2309      	movs	r3, #9
 800694c:	7023      	strb	r3, [r4, #0]
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 800694e:	2109      	movs	r1, #9
 8006950:	e7ad      	b.n	80068ae <USBH_Get_CfgDesc+0x18e>
 8006952:	9902      	ldr	r1, [sp, #8]
        if (ep_ix < pif->bNumEndpoints)
 8006954:	42b2      	cmp	r2, r6
 8006956:	f108 0801 	add.w	r8, r8, #1
 800695a:	f101 012a 	add.w	r1, r1, #42	@ 0x2a
 800695e:	f4bf af32 	bcs.w	80067c6 <USBH_Get_CfgDesc+0xa6>
 8006962:	e754      	b.n	800680e <USBH_Get_CfgDesc+0xee>
    if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_BULK)
 8006964:	f001 0103 	and.w	r1, r1, #3
 8006968:	2902      	cmp	r1, #2
 800696a:	d0e3      	beq.n	8006934 <USBH_Get_CfgDesc+0x214>
 800696c:	07c9      	lsls	r1, r1, #31
 800696e:	d409      	bmi.n	8006984 <USBH_Get_CfgDesc+0x264>
        status = USBH_NOT_SUPPORTED;
 8006970:	2841      	cmp	r0, #65	@ 0x41
 8006972:	bf28      	it	cs
 8006974:	2703      	movcs	r7, #3
 8006976:	e7dd      	b.n	8006934 <USBH_Get_CfgDesc+0x214>
    if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_BULK)
 8006978:	f001 0103 	and.w	r1, r1, #3
  if (phost->device.speed == (uint8_t)USBH_SPEED_HIGH)
 800697c:	2703      	movs	r7, #3
 800697e:	2902      	cmp	r1, #2
 8006980:	d1f4      	bne.n	800696c <USBH_Get_CfgDesc+0x24c>
 8006982:	e7d7      	b.n	8006934 <USBH_Get_CfgDesc+0x214>
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->bInterval > 0x10U))
 8006984:	f10e 3eff 	add.w	lr, lr, #4294967295
        status = USBH_NOT_SUPPORTED;
 8006988:	f1be 0f0f 	cmp.w	lr, #15
 800698c:	bf88      	it	hi
 800698e:	2703      	movhi	r7, #3
 8006990:	e7d0      	b.n	8006934 <USBH_Get_CfgDesc+0x214>
  else if (phost->device.speed == (uint8_t)USBH_SPEED_FULL)
 8006992:	2703      	movs	r7, #3
    if (((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_BULK) ||
 8006994:	07cb      	lsls	r3, r1, #31
 8006996:	d5eb      	bpl.n	8006970 <USBH_Get_CfgDesc+0x250>
    else if ((ep_descriptor->bmAttributes & EP_TYPE_MSK) == EP_TYPE_ISOC)
 8006998:	f001 0103 	and.w	r1, r1, #3
 800699c:	2901      	cmp	r1, #1
 800699e:	d00c      	beq.n	80069ba <USBH_Get_CfgDesc+0x29a>
      if ((ep_descriptor->bInterval == 0U) || (ep_descriptor->wMaxPacketSize > 1023U))
 80069a0:	f5b0 6f80 	cmp.w	r0, #1024	@ 0x400
 80069a4:	d2c5      	bcs.n	8006932 <USBH_Get_CfgDesc+0x212>
 80069a6:	f1be 0f00 	cmp.w	lr, #0
 80069aa:	d1c3      	bne.n	8006934 <USBH_Get_CfgDesc+0x214>
 80069ac:	e7c1      	b.n	8006932 <USBH_Get_CfgDesc+0x212>
 80069ae:	2700      	movs	r7, #0
 80069b0:	e7f0      	b.n	8006994 <USBH_Get_CfgDesc+0x274>
 80069b2:	2300      	movs	r3, #0
 80069b4:	e7b1      	b.n	800691a <USBH_Get_CfgDesc+0x1fa>
        ep_ix = 0U;
 80069b6:	2200      	movs	r2, #0
 80069b8:	e7cc      	b.n	8006954 <USBH_Get_CfgDesc+0x234>
      if ((ep_descriptor->bInterval == 0U) ||
 80069ba:	f10e 3eff 	add.w	lr, lr, #4294967295
          (ep_descriptor->bInterval > 0x10U) ||
 80069be:	f1be 0f0f 	cmp.w	lr, #15
 80069c2:	d8b6      	bhi.n	8006932 <USBH_Get_CfgDesc+0x212>
 80069c4:	2840      	cmp	r0, #64	@ 0x40
 80069c6:	d9b5      	bls.n	8006934 <USBH_Get_CfgDesc+0x214>
 80069c8:	e7b3      	b.n	8006932 <USBH_Get_CfgDesc+0x212>
 80069ca:	461f      	mov	r7, r3
 80069cc:	e7b2      	b.n	8006934 <USBH_Get_CfgDesc+0x214>
 80069ce:	bf00      	nop
 80069d0:	08007e44 	.word	0x08007e44
 80069d4:	0800826c 	.word	0x0800826c

080069d8 <USBH_SetAddress>:
{
 80069d8:	b510      	push	{r4, lr}
  if (phost->RequestState == CMD_SEND)
 80069da:	7883      	ldrb	r3, [r0, #2]
{
 80069dc:	4604      	mov	r4, r0
  if (phost->RequestState == CMD_SEND)
 80069de:	2b01      	cmp	r3, #1
 80069e0:	d009      	beq.n	80069f6 <USBH_SetAddress+0x1e>
  switch (phost->RequestState)
 80069e2:	2b02      	cmp	r3, #2
 80069e4:	d112      	bne.n	8006a0c <USBH_SetAddress+0x34>
      status = USBH_HandleControl(phost);
 80069e6:	f7ff fd51 	bl	800648c <USBH_HandleControl>
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 80069ea:	b188      	cbz	r0, 8006a10 <USBH_SetAddress+0x38>
 80069ec:	2803      	cmp	r0, #3
 80069ee:	d00f      	beq.n	8006a10 <USBH_SetAddress+0x38>
      else if (status == USBH_FAIL)
 80069f0:	2802      	cmp	r0, #2
 80069f2:	d012      	beq.n	8006a1a <USBH_SetAddress+0x42>
}
 80069f4:	bd10      	pop	{r4, pc}
      phost->Control.buff = buff;
 80069f6:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 80069f8:	f44f 60a0 	mov.w	r0, #1280	@ 0x500
    phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
 80069fc:	8261      	strh	r1, [r4, #18]
      phost->RequestState = CMD_WAIT;
 80069fe:	2102      	movs	r1, #2
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 8006a00:	8220      	strh	r0, [r4, #16]
      phost->Control.buff = buff;
 8006a02:	60a2      	str	r2, [r4, #8]
      phost->Control.length = length;
 8006a04:	81a2      	strh	r2, [r4, #12]
    phost->Control.setup.b.wIndex.w = 0U;
 8006a06:	6162      	str	r2, [r4, #20]
      phost->Control.state = CTRL_SETUP;
 8006a08:	7623      	strb	r3, [r4, #24]
      phost->RequestState = CMD_WAIT;
 8006a0a:	70a1      	strb	r1, [r4, #2]
      status = USBH_BUSY;
 8006a0c:	2001      	movs	r0, #1
}
 8006a0e:	bd10      	pop	{r4, pc}
        phost->RequestState = CMD_SEND;
 8006a10:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 8006a12:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
 8006a14:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8006a16:	7623      	strb	r3, [r4, #24]
}
 8006a18:	bd10      	pop	{r4, pc}
        phost->RequestState = CMD_SEND;
 8006a1a:	2301      	movs	r3, #1
 8006a1c:	70a3      	strb	r3, [r4, #2]
}
 8006a1e:	bd10      	pop	{r4, pc}

08006a20 <USBH_SetCfg>:
{
 8006a20:	b510      	push	{r4, lr}
  if (phost->RequestState == CMD_SEND)
 8006a22:	7883      	ldrb	r3, [r0, #2]
{
 8006a24:	4604      	mov	r4, r0
  if (phost->RequestState == CMD_SEND)
 8006a26:	2b01      	cmp	r3, #1
 8006a28:	d009      	beq.n	8006a3e <USBH_SetCfg+0x1e>
  switch (phost->RequestState)
 8006a2a:	2b02      	cmp	r3, #2
 8006a2c:	d112      	bne.n	8006a54 <USBH_SetCfg+0x34>
      status = USBH_HandleControl(phost);
 8006a2e:	f7ff fd2d 	bl	800648c <USBH_HandleControl>
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8006a32:	b188      	cbz	r0, 8006a58 <USBH_SetCfg+0x38>
 8006a34:	2803      	cmp	r0, #3
 8006a36:	d00f      	beq.n	8006a58 <USBH_SetCfg+0x38>
      else if (status == USBH_FAIL)
 8006a38:	2802      	cmp	r0, #2
 8006a3a:	d012      	beq.n	8006a62 <USBH_SetCfg+0x42>
}
 8006a3c:	bd10      	pop	{r4, pc}
      phost->Control.buff = buff;
 8006a3e:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 8006a40:	f44f 6010 	mov.w	r0, #2304	@ 0x900
    phost->Control.setup.b.wValue.w = cfg_idx;
 8006a44:	8261      	strh	r1, [r4, #18]
      phost->RequestState = CMD_WAIT;
 8006a46:	2102      	movs	r1, #2
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 8006a48:	8220      	strh	r0, [r4, #16]
      phost->Control.buff = buff;
 8006a4a:	60a2      	str	r2, [r4, #8]
      phost->Control.length = length;
 8006a4c:	81a2      	strh	r2, [r4, #12]
    phost->Control.setup.b.wIndex.w = 0U;
 8006a4e:	6162      	str	r2, [r4, #20]
      phost->Control.state = CTRL_SETUP;
 8006a50:	7623      	strb	r3, [r4, #24]
      phost->RequestState = CMD_WAIT;
 8006a52:	70a1      	strb	r1, [r4, #2]
      status = USBH_BUSY;
 8006a54:	2001      	movs	r0, #1
}
 8006a56:	bd10      	pop	{r4, pc}
        phost->RequestState = CMD_SEND;
 8006a58:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 8006a5a:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
 8006a5c:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8006a5e:	7623      	strb	r3, [r4, #24]
}
 8006a60:	bd10      	pop	{r4, pc}
        phost->RequestState = CMD_SEND;
 8006a62:	2301      	movs	r3, #1
 8006a64:	70a3      	strb	r3, [r4, #2]
}
 8006a66:	bd10      	pop	{r4, pc}

08006a68 <USBH_SetFeature>:
{
 8006a68:	b510      	push	{r4, lr}
  if (phost->RequestState == CMD_SEND)
 8006a6a:	7883      	ldrb	r3, [r0, #2]
{
 8006a6c:	4604      	mov	r4, r0
  if (phost->RequestState == CMD_SEND)
 8006a6e:	2b01      	cmp	r3, #1
 8006a70:	d009      	beq.n	8006a86 <USBH_SetFeature+0x1e>
  switch (phost->RequestState)
 8006a72:	2b02      	cmp	r3, #2
 8006a74:	d112      	bne.n	8006a9c <USBH_SetFeature+0x34>
      status = USBH_HandleControl(phost);
 8006a76:	f7ff fd09 	bl	800648c <USBH_HandleControl>
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8006a7a:	b188      	cbz	r0, 8006aa0 <USBH_SetFeature+0x38>
 8006a7c:	2803      	cmp	r0, #3
 8006a7e:	d00f      	beq.n	8006aa0 <USBH_SetFeature+0x38>
      else if (status == USBH_FAIL)
 8006a80:	2802      	cmp	r0, #2
 8006a82:	d012      	beq.n	8006aaa <USBH_SetFeature+0x42>
}
 8006a84:	bd10      	pop	{r4, pc}
      phost->Control.buff = buff;
 8006a86:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 8006a88:	f44f 7040 	mov.w	r0, #768	@ 0x300
    phost->Control.setup.b.wValue.w = wValue;
 8006a8c:	8261      	strh	r1, [r4, #18]
      phost->RequestState = CMD_WAIT;
 8006a8e:	2102      	movs	r1, #2
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 8006a90:	8220      	strh	r0, [r4, #16]
      phost->Control.buff = buff;
 8006a92:	60a2      	str	r2, [r4, #8]
      phost->Control.length = length;
 8006a94:	81a2      	strh	r2, [r4, #12]
    phost->Control.setup.b.wIndex.w = 0U;
 8006a96:	6162      	str	r2, [r4, #20]
      phost->Control.state = CTRL_SETUP;
 8006a98:	7623      	strb	r3, [r4, #24]
      phost->RequestState = CMD_WAIT;
 8006a9a:	70a1      	strb	r1, [r4, #2]
      status = USBH_BUSY;
 8006a9c:	2001      	movs	r0, #1
}
 8006a9e:	bd10      	pop	{r4, pc}
        phost->RequestState = CMD_SEND;
 8006aa0:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 8006aa2:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
 8006aa4:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8006aa6:	7623      	strb	r3, [r4, #24]
}
 8006aa8:	bd10      	pop	{r4, pc}
        phost->RequestState = CMD_SEND;
 8006aaa:	2301      	movs	r3, #1
 8006aac:	70a3      	strb	r3, [r4, #2]
}
 8006aae:	bd10      	pop	{r4, pc}

08006ab0 <USBH_CtlReq>:
{
 8006ab0:	b510      	push	{r4, lr}
  switch (phost->RequestState)
 8006ab2:	7883      	ldrb	r3, [r0, #2]
{
 8006ab4:	4604      	mov	r4, r0
  switch (phost->RequestState)
 8006ab6:	2b01      	cmp	r3, #1
 8006ab8:	d009      	beq.n	8006ace <USBH_CtlReq+0x1e>
 8006aba:	2b02      	cmp	r3, #2
 8006abc:	d10c      	bne.n	8006ad8 <USBH_CtlReq+0x28>
      status = USBH_HandleControl(phost);
 8006abe:	f7ff fce5 	bl	800648c <USBH_HandleControl>
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 8006ac2:	b158      	cbz	r0, 8006adc <USBH_CtlReq+0x2c>
 8006ac4:	2803      	cmp	r0, #3
 8006ac6:	d009      	beq.n	8006adc <USBH_CtlReq+0x2c>
      else if (status == USBH_FAIL)
 8006ac8:	2802      	cmp	r0, #2
 8006aca:	d00c      	beq.n	8006ae6 <USBH_CtlReq+0x36>
}
 8006acc:	bd10      	pop	{r4, pc}
      phost->RequestState = CMD_WAIT;
 8006ace:	2002      	movs	r0, #2
      phost->Control.buff = buff;
 8006ad0:	60a1      	str	r1, [r4, #8]
      phost->Control.length = length;
 8006ad2:	81a2      	strh	r2, [r4, #12]
      phost->Control.state = CTRL_SETUP;
 8006ad4:	7623      	strb	r3, [r4, #24]
      phost->RequestState = CMD_WAIT;
 8006ad6:	70a0      	strb	r0, [r4, #2]
{
 8006ad8:	2001      	movs	r0, #1
}
 8006ada:	bd10      	pop	{r4, pc}
        phost->RequestState = CMD_SEND;
 8006adc:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 8006ade:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
 8006ae0:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8006ae2:	7623      	strb	r3, [r4, #24]
}
 8006ae4:	bd10      	pop	{r4, pc}
        phost->RequestState = CMD_SEND;
 8006ae6:	2301      	movs	r3, #1
 8006ae8:	70a3      	strb	r3, [r4, #2]
}
 8006aea:	bd10      	pop	{r4, pc}

08006aec <USBH_Get_StringDesc>:
  if ((length > sizeof(phost->device.Data)) || (buff == NULL))
 8006aec:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
{
 8006af0:	b570      	push	{r4, r5, r6, lr}
  if ((length > sizeof(phost->device.Data)) || (buff == NULL))
 8006af2:	d832      	bhi.n	8006b5a <USBH_Get_StringDesc+0x6e>
 8006af4:	4615      	mov	r5, r2
 8006af6:	b382      	cbz	r2, 8006b5a <USBH_Get_StringDesc+0x6e>
 8006af8:	4604      	mov	r4, r0
 8006afa:	461e      	mov	r6, r3
 8006afc:	4608      	mov	r0, r1
  if (phost->RequestState == CMD_SEND)
 8006afe:	78a3      	ldrb	r3, [r4, #2]
                              phost->device.Data, length);
 8006b00:	f504 718e 	add.w	r1, r4, #284	@ 0x11c
  if (phost->RequestState == CMD_SEND)
 8006b04:	2b01      	cmp	r3, #1
 8006b06:	d109      	bne.n	8006b1c <USBH_Get_StringDesc+0x30>
      phost->Control.setup.b.wIndex.w = 0x0409U;
 8006b08:	f240 4309 	movw	r3, #1033	@ 0x409
  status = USBH_GetDescriptor(phost,
 8006b0c:	f440 7040 	orr.w	r0, r0, #768	@ 0x300
    phost->Control.setup.b.wLength.w = length;
 8006b10:	82e6      	strh	r6, [r4, #22]
      phost->Control.setup.b.wIndex.w = 0x0409U;
 8006b12:	82a3      	strh	r3, [r4, #20]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8006b14:	f44f 63d0 	mov.w	r3, #1664	@ 0x680
    phost->Control.setup.b.wValue.w = value_idx;
 8006b18:	8260      	strh	r0, [r4, #18]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8006b1a:	8223      	strh	r3, [r4, #16]
  return USBH_CtlReq(phost, buff, length);
 8006b1c:	4632      	mov	r2, r6
 8006b1e:	4620      	mov	r0, r4
 8006b20:	f7ff ffc6 	bl	8006ab0 <USBH_CtlReq>
  if (status == USBH_OK)
 8006b24:	b100      	cbz	r0, 8006b28 <USBH_Get_StringDesc+0x3c>
}
 8006b26:	bd70      	pop	{r4, r5, r6, pc}
  if (psrc[1] == USB_DESC_TYPE_STRING)
 8006b28:	f894 311d 	ldrb.w	r3, [r4, #285]	@ 0x11d
 8006b2c:	2b03      	cmp	r3, #3
 8006b2e:	d1fa      	bne.n	8006b26 <USBH_Get_StringDesc+0x3a>
    strlength = ((((uint16_t)psrc[0] - 2U) <= length) ? ((uint16_t)psrc[0] - 2U) : length);
 8006b30:	f894 311c 	ldrb.w	r3, [r4, #284]	@ 0x11c
 8006b34:	3b02      	subs	r3, #2
 8006b36:	42b3      	cmp	r3, r6
 8006b38:	bf28      	it	cs
 8006b3a:	4633      	movcs	r3, r6
 8006b3c:	b299      	uxth	r1, r3
    for (idx = 0U; idx < strlength; idx += 2U)
 8006b3e:	b14b      	cbz	r3, 8006b54 <USBH_Get_StringDesc+0x68>
 8006b40:	4603      	mov	r3, r0
 8006b42:	f504 748f 	add.w	r4, r4, #286	@ 0x11e
      *pdest =  psrc[idx];
 8006b46:	5ce2      	ldrb	r2, [r4, r3]
    for (idx = 0U; idx < strlength; idx += 2U)
 8006b48:	3302      	adds	r3, #2
      *pdest =  psrc[idx];
 8006b4a:	f805 2b01 	strb.w	r2, [r5], #1
    for (idx = 0U; idx < strlength; idx += 2U)
 8006b4e:	b29a      	uxth	r2, r3
 8006b50:	428a      	cmp	r2, r1
 8006b52:	d3f8      	bcc.n	8006b46 <USBH_Get_StringDesc+0x5a>
    *pdest = 0U; /* mark end of string */
 8006b54:	2300      	movs	r3, #0
 8006b56:	702b      	strb	r3, [r5, #0]
}
 8006b58:	bd70      	pop	{r4, r5, r6, pc}
    USBH_ErrLog("Control error: Get String Descriptor failed, data buffer size issue");
 8006b5a:	4805      	ldr	r0, [pc, #20]	@ (8006b70 <USBH_Get_StringDesc+0x84>)
 8006b5c:	f000 fb48 	bl	80071f0 <iprintf>
 8006b60:	4804      	ldr	r0, [pc, #16]	@ (8006b74 <USBH_Get_StringDesc+0x88>)
 8006b62:	f000 fb45 	bl	80071f0 <iprintf>
 8006b66:	200a      	movs	r0, #10
 8006b68:	f000 fb54 	bl	8007214 <putchar>
    return USBH_NOT_SUPPORTED;
 8006b6c:	2003      	movs	r0, #3
}
 8006b6e:	bd70      	pop	{r4, r5, r6, pc}
 8006b70:	08007e44 	.word	0x08007e44
 8006b74:	080082b8 	.word	0x080082b8

08006b78 <USBH_CtlSendSetup>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlSendSetup(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint8_t pipe_num)
{
 8006b78:	b530      	push	{r4, r5, lr}

  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 8006b7a:	2400      	movs	r4, #0
{
 8006b7c:	b085      	sub	sp, #20
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 8006b7e:	2508      	movs	r5, #8
 8006b80:	9101      	str	r1, [sp, #4]
 8006b82:	4623      	mov	r3, r4
 8006b84:	4611      	mov	r1, r2
 8006b86:	9403      	str	r4, [sp, #12]
 8006b88:	4622      	mov	r2, r4
 8006b8a:	9502      	str	r5, [sp, #8]
 8006b8c:	9400      	str	r4, [sp, #0]
 8006b8e:	f000 f983 	bl	8006e98 <USBH_LL_SubmitURB>
                          USBH_PID_SETUP,       /* Type setup       */
                          buff,                 /* data buffer      */
                          USBH_SETUP_PKT_SIZE,  /* data length      */
                          0U);
  return USBH_OK;
}
 8006b92:	4620      	mov	r0, r4
 8006b94:	b005      	add	sp, #20
 8006b96:	bd30      	pop	{r4, r5, pc}

08006b98 <USBH_CtlSendData>:
USBH_StatusTypeDef USBH_CtlSendData(USBH_HandleTypeDef *phost,
                                    uint8_t *buff,
                                    uint16_t length,
                                    uint8_t pipe_num,
                                    uint8_t do_ping)
{
 8006b98:	b510      	push	{r4, lr}
 8006b9a:	460c      	mov	r4, r1
 8006b9c:	4619      	mov	r1, r3
  if (phost->device.speed != USBH_SPEED_HIGH)
 8006b9e:	f890 331d 	ldrb.w	r3, [r0, #797]	@ 0x31d
{
 8006ba2:	b084      	sub	sp, #16
  {
    do_ping = 0U;
 8006ba4:	2b00      	cmp	r3, #0
  }

  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 8006ba6:	f04f 0300 	mov.w	r3, #0
 8006baa:	e9cd 4201 	strd	r4, r2, [sp, #4]
{
 8006bae:	f89d 4018 	ldrb.w	r4, [sp, #24]
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 8006bb2:	f04f 0201 	mov.w	r2, #1
    do_ping = 0U;
 8006bb6:	bf18      	it	ne
 8006bb8:	461c      	movne	r4, r3
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 8006bba:	9200      	str	r2, [sp, #0]
 8006bbc:	461a      	mov	r2, r3
 8006bbe:	9403      	str	r4, [sp, #12]
 8006bc0:	f000 f96a 	bl	8006e98 <USBH_LL_SubmitURB>
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          do_ping);             /* do ping (HS Only)*/

  return USBH_OK;
}
 8006bc4:	2000      	movs	r0, #0
 8006bc6:	b004      	add	sp, #16
 8006bc8:	bd10      	pop	{r4, pc}
 8006bca:	bf00      	nop

08006bcc <USBH_CtlReceiveData>:
  */
USBH_StatusTypeDef USBH_CtlReceiveData(USBH_HandleTypeDef *phost,
                                       uint8_t *buff,
                                       uint16_t length,
                                       uint8_t pipe_num)
{
 8006bcc:	b530      	push	{r4, r5, lr}
 8006bce:	b085      	sub	sp, #20
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 8006bd0:	2400      	movs	r4, #0
{
 8006bd2:	460d      	mov	r5, r1
  (void)USBH_LL_SubmitURB(phost,                /* Driver handle    */
 8006bd4:	4619      	mov	r1, r3
 8006bd6:	9202      	str	r2, [sp, #8]
 8006bd8:	2201      	movs	r2, #1
 8006bda:	4623      	mov	r3, r4
 8006bdc:	9403      	str	r4, [sp, #12]
 8006bde:	e9cd 2500 	strd	r2, r5, [sp]
 8006be2:	f000 f959 	bl	8006e98 <USBH_LL_SubmitURB>
                          buff,                 /* data buffer      */
                          length,               /* data length      */
                          0U);
  return USBH_OK;

}
 8006be6:	4620      	mov	r0, r4
 8006be8:	b005      	add	sp, #20
 8006bea:	bd30      	pop	{r4, r5, pc}

08006bec <USBH_OpenPipe>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num,
                                 uint8_t epnum, uint8_t dev_address,
                                 uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 8006bec:	b510      	push	{r4, lr}
 8006bee:	b084      	sub	sp, #16
 8006bf0:	f89d 4018 	ldrb.w	r4, [sp, #24]
  (void)USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 8006bf4:	9400      	str	r4, [sp, #0]
{
 8006bf6:	f89d 401c 	ldrb.w	r4, [sp, #28]
  (void)USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 8006bfa:	9401      	str	r4, [sp, #4]
{
 8006bfc:	f8bd 4020 	ldrh.w	r4, [sp, #32]
  (void)USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 8006c00:	9402      	str	r4, [sp, #8]
 8006c02:	f000 f933 	bl	8006e6c <USBH_LL_OpenPipe>

  return USBH_OK;
}
 8006c06:	2000      	movs	r0, #0
 8006c08:	b004      	add	sp, #16
 8006c0a:	bd10      	pop	{r4, pc}

08006c0c <USBH_AllocPipe>:
  * @param  phost: Host Handle
  * @param  ep_addr: End point for which the Pipe to be allocated
  * @retval Pipe number
  */
uint8_t USBH_AllocPipe(USBH_HandleTypeDef *phost, uint8_t ep_addr)
{
 8006c0c:	2300      	movs	r3, #0
 8006c0e:	4684      	mov	ip, r0
  */
static uint16_t USBH_GetFreePipe(USBH_HandleTypeDef *phost)
{
  uint8_t idx = 0U;

  for (idx = 0U; idx < USBH_MAX_PIPES_NBR; idx++)
 8006c10:	f500 727d 	add.w	r2, r0, #1012	@ 0x3f4
{
 8006c14:	b410      	push	{r4}
  {
    if ((phost->Pipes[idx] & 0x8000U) == 0U)
 8006c16:	f852 4f04 	ldr.w	r4, [r2, #4]!
 8006c1a:	0420      	lsls	r0, r4, #16
 8006c1c:	d506      	bpl.n	8006c2c <USBH_AllocPipe+0x20>
  for (idx = 0U; idx < USBH_MAX_PIPES_NBR; idx++)
 8006c1e:	3301      	adds	r3, #1
 8006c20:	2b10      	cmp	r3, #16
 8006c22:	d1f8      	bne.n	8006c16 <USBH_AllocPipe+0xa>
 8006c24:	20ff      	movs	r0, #255	@ 0xff
}
 8006c26:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006c2a:	4770      	bx	lr
    phost->Pipes[pipe & 0xFU] = (uint32_t)(0x8000U | ep_addr);
 8006c2c:	f103 02fe 	add.w	r2, r3, #254	@ 0xfe
 8006c30:	f441 4100 	orr.w	r1, r1, #32768	@ 0x8000
 8006c34:	b2d8      	uxtb	r0, r3
}
 8006c36:	f85d 4b04 	ldr.w	r4, [sp], #4
    phost->Pipes[pipe & 0xFU] = (uint32_t)(0x8000U | ep_addr);
 8006c3a:	f84c 1022 	str.w	r1, [ip, r2, lsl #2]
}
 8006c3e:	4770      	bx	lr

08006c40 <USBH_FreePipe>:
  if (idx < USBH_MAX_PIPES_NBR)
 8006c40:	290f      	cmp	r1, #15
 8006c42:	d807      	bhi.n	8006c54 <USBH_FreePipe+0x14>
    phost->Pipes[idx] &= 0x7FFFU;
 8006c44:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8006c48:	f8d1 33f8 	ldr.w	r3, [r1, #1016]	@ 0x3f8
 8006c4c:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8006c50:	f8c1 33f8 	str.w	r3, [r1, #1016]	@ 0x3f8
}
 8006c54:	2000      	movs	r0, #0
 8006c56:	4770      	bx	lr

08006c58 <HAL_PCD_SetupStageCallback>:
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8006c58:	f200 419c 	addw	r1, r0, #1180	@ 0x49c
 8006c5c:	f8d0 04e0 	ldr.w	r0, [r0, #1248]	@ 0x4e0
 8006c60:	f7fe bc26 	b.w	80054b0 <USBD_LL_SetupStage>

08006c64 <HAL_PCD_DataOutStageCallback>:
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8006c64:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
 8006c68:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8006c6c:	f8d0 04e0 	ldr.w	r0, [r0, #1248]	@ 0x4e0
 8006c70:	f8d3 2260 	ldr.w	r2, [r3, #608]	@ 0x260
 8006c74:	f7fe bc4c 	b.w	8005510 <USBD_LL_DataOutStage>

08006c78 <HAL_PCD_DataInStageCallback>:
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8006c78:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
 8006c7c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8006c80:	f8d0 04e0 	ldr.w	r0, [r0, #1248]	@ 0x4e0
 8006c84:	6a1a      	ldr	r2, [r3, #32]
 8006c86:	f7fe bc7d 	b.w	8005584 <USBD_LL_DataInStage>
 8006c8a:	bf00      	nop

08006c8c <HAL_PCD_SOFCallback>:
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8006c8c:	f8d0 04e0 	ldr.w	r0, [r0, #1248]	@ 0x4e0
 8006c90:	f7fe bd26 	b.w	80056e0 <USBD_LL_SOF>

08006c94 <HAL_PCD_ResetCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8006c94:	b510      	push	{r4, lr}
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 8006c96:	79c1      	ldrb	r1, [r0, #7]
{
 8006c98:	4604      	mov	r4, r0
  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 8006c9a:	b111      	cbz	r1, 8006ca2 <HAL_PCD_ResetCallback+0xe>
  {
    speed = USBD_SPEED_HIGH;
  }
  else if ( hpcd->Init.speed == PCD_SPEED_FULL)
 8006c9c:	2902      	cmp	r1, #2
 8006c9e:	d10a      	bne.n	8006cb6 <HAL_PCD_ResetCallback+0x22>
  {
    speed = USBD_SPEED_FULL;
 8006ca0:	2101      	movs	r1, #1
  else
  {
    Error_Handler();
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8006ca2:	f8d4 04e0 	ldr.w	r0, [r4, #1248]	@ 0x4e0
 8006ca6:	f7fe fcfb 	bl	80056a0 <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8006caa:	f8d4 04e0 	ldr.w	r0, [r4, #1248]	@ 0x4e0
}
 8006cae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8006cb2:	f7fe bcc7 	b.w	8005644 <USBD_LL_Reset>
    Error_Handler();
 8006cb6:	f7f9 fea5 	bl	8000a04 <Error_Handler>
    speed = USBD_SPEED_FULL;
 8006cba:	2101      	movs	r1, #1
 8006cbc:	e7f1      	b.n	8006ca2 <HAL_PCD_ResetCallback+0xe>
 8006cbe:	bf00      	nop

08006cc0 <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8006cc0:	b510      	push	{r4, lr}
 8006cc2:	4604      	mov	r4, r0
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8006cc4:	f8d0 04e0 	ldr.w	r0, [r0, #1248]	@ 0x4e0
 8006cc8:	f7fe fcee 	bl	80056a8 <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8006ccc:	6822      	ldr	r2, [r4, #0]
 8006cce:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	@ 0xe00
 8006cd2:	f043 0301 	orr.w	r3, r3, #1
 8006cd6:	f8c2 3e00 	str.w	r3, [r2, #3584]	@ 0xe00
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8006cda:	7ae3      	ldrb	r3, [r4, #11]
 8006cdc:	b123      	cbz	r3, 8006ce8 <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8006cde:	4a03      	ldr	r2, [pc, #12]	@ (8006cec <HAL_PCD_SuspendCallback+0x2c>)
 8006ce0:	6913      	ldr	r3, [r2, #16]
 8006ce2:	f043 0306 	orr.w	r3, r3, #6
 8006ce6:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 8006ce8:	bd10      	pop	{r4, pc}
 8006cea:	bf00      	nop
 8006cec:	e000ed00 	.word	0xe000ed00

08006cf0 <HAL_PCD_ResumeCallback>:
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8006cf0:	f8d0 04e0 	ldr.w	r0, [r0, #1248]	@ 0x4e0
 8006cf4:	f7fe bce8 	b.w	80056c8 <USBD_LL_Resume>

08006cf8 <HAL_PCD_ISOOUTIncompleteCallback>:
static void PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8006cf8:	f8d0 04e0 	ldr.w	r0, [r0, #1248]	@ 0x4e0
 8006cfc:	f7fe bd16 	b.w	800572c <USBD_LL_IsoOUTIncomplete>

08006d00 <HAL_PCD_ISOINIncompleteCallback>:
static void PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8006d00:	f8d0 04e0 	ldr.w	r0, [r0, #1248]	@ 0x4e0
 8006d04:	f7fe bcfc 	b.w	8005700 <USBD_LL_IsoINIncomplete>

08006d08 <HAL_PCD_ConnectCallback>:
static void PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 8006d08:	f8d0 04e0 	ldr.w	r0, [r0, #1248]	@ 0x4e0
 8006d0c:	f7fe bd24 	b.w	8005758 <USBD_LL_DevConnected>

08006d10 <HAL_PCD_DisconnectCallback>:
static void PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 8006d10:	f8d0 04e0 	ldr.w	r0, [r0, #1248]	@ 0x4e0
 8006d14:	f7fe bd22 	b.w	800575c <USBD_LL_DevDisconnected>

08006d18 <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 8006d18:	4694      	mov	ip, r2
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8006d1a:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
{
 8006d1e:	461a      	mov	r2, r3
 8006d20:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8006d22:	4663      	mov	r3, ip
 8006d24:	f7fc fdd6 	bl	80038d4 <HAL_PCD_EP_Open>
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
  USBD_StatusTypeDef usb_status = USBD_OK;

  switch (hal_status)
 8006d28:	b118      	cbz	r0, 8006d32 <USBD_LL_OpenEP+0x1a>
 8006d2a:	2802      	cmp	r0, #2
 8006d2c:	bf0c      	ite	eq
 8006d2e:	2001      	moveq	r0, #1
 8006d30:	2003      	movne	r0, #3
}
 8006d32:	bd08      	pop	{r3, pc}

08006d34 <USBD_LL_StallEP>:
{
 8006d34:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8006d36:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
 8006d3a:	f7fc fe4d 	bl	80039d8 <HAL_PCD_EP_SetStall>
  switch (hal_status)
 8006d3e:	b118      	cbz	r0, 8006d48 <USBD_LL_StallEP+0x14>
 8006d40:	2802      	cmp	r0, #2
 8006d42:	bf0c      	ite	eq
 8006d44:	2001      	moveq	r0, #1
 8006d46:	2003      	movne	r0, #3
}
 8006d48:	bd08      	pop	{r3, pc}
 8006d4a:	bf00      	nop

08006d4c <USBD_LL_ClearStallEP>:
{
 8006d4c:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8006d4e:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
 8006d52:	f7fc fe85 	bl	8003a60 <HAL_PCD_EP_ClrStall>
  switch (hal_status)
 8006d56:	b118      	cbz	r0, 8006d60 <USBD_LL_ClearStallEP+0x14>
 8006d58:	2802      	cmp	r0, #2
 8006d5a:	bf0c      	ite	eq
 8006d5c:	2001      	moveq	r0, #1
 8006d5e:	2003      	movne	r0, #3
}
 8006d60:	bd08      	pop	{r3, pc}
 8006d62:	bf00      	nop

08006d64 <USBD_LL_IsStallEP>:
  if((ep_addr & 0x80) == 0x80)
 8006d64:	060a      	lsls	r2, r1, #24
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8006d66:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
  if((ep_addr & 0x80) == 0x80)
 8006d6a:	d406      	bmi.n	8006d7a <USBD_LL_IsStallEP+0x16>
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 8006d6c:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 8006d70:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8006d74:	f893 0256 	ldrb.w	r0, [r3, #598]	@ 0x256
}
 8006d78:	4770      	bx	lr
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 8006d7a:	f001 017f 	and.w	r1, r1, #127	@ 0x7f
 8006d7e:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 8006d82:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8006d86:	7d98      	ldrb	r0, [r3, #22]
 8006d88:	4770      	bx	lr
 8006d8a:	bf00      	nop

08006d8c <USBD_LL_SetUSBAddress>:
{
 8006d8c:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8006d8e:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
 8006d92:	f7fc fd8b 	bl	80038ac <HAL_PCD_SetAddress>
  switch (hal_status)
 8006d96:	b118      	cbz	r0, 8006da0 <USBD_LL_SetUSBAddress+0x14>
 8006d98:	2802      	cmp	r0, #2
 8006d9a:	bf0c      	ite	eq
 8006d9c:	2001      	moveq	r0, #1
 8006d9e:	2003      	movne	r0, #3
}
 8006da0:	bd08      	pop	{r3, pc}
 8006da2:	bf00      	nop

08006da4 <USBD_LL_Transmit>:
{
 8006da4:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8006da6:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
 8006daa:	f7fc fdf3 	bl	8003994 <HAL_PCD_EP_Transmit>
  switch (hal_status)
 8006dae:	b118      	cbz	r0, 8006db8 <USBD_LL_Transmit+0x14>
 8006db0:	2802      	cmp	r0, #2
 8006db2:	bf0c      	ite	eq
 8006db4:	2001      	moveq	r0, #1
 8006db6:	2003      	movne	r0, #3
}
 8006db8:	bd08      	pop	{r3, pc}
 8006dba:	bf00      	nop

08006dbc <USBD_LL_PrepareReceive>:
{
 8006dbc:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8006dbe:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
 8006dc2:	f7fc fdc5 	bl	8003950 <HAL_PCD_EP_Receive>
  switch (hal_status)
 8006dc6:	b118      	cbz	r0, 8006dd0 <USBD_LL_PrepareReceive+0x14>
 8006dc8:	2802      	cmp	r0, #2
 8006dca:	bf0c      	ite	eq
 8006dcc:	2001      	moveq	r0, #1
 8006dce:	2003      	movne	r0, #3
}
 8006dd0:	bd08      	pop	{r3, pc}
 8006dd2:	bf00      	nop

08006dd4 <MX_USB_HOST_Process>:
 * Background task
 */
void MX_USB_HOST_Process(void)
{
  /* USB Host Background task */
  USBH_Process(&hUsbHostHS);
 8006dd4:	4801      	ldr	r0, [pc, #4]	@ (8006ddc <MX_USB_HOST_Process+0x8>)
 8006dd6:	f7fe bfe9 	b.w	8005dac <USBH_Process>
 8006dda:	bf00      	nop
 8006ddc:	24000840 	.word	0x24000840

08006de0 <HAL_HCD_SOF_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_IncTimer(hhcd->pData);
 8006de0:	f8d0 03dc 	ldr.w	r0, [r0, #988]	@ 0x3dc
 8006de4:	f7ff bb18 	b.w	8006418 <USBH_LL_IncTimer>

08006de8 <HAL_HCD_Connect_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_Connect(hhcd->pData);
 8006de8:	f8d0 03dc 	ldr.w	r0, [r0, #988]	@ 0x3dc
 8006dec:	f7ff bb2c 	b.w	8006448 <USBH_LL_Connect>

08006df0 <HAL_HCD_Disconnect_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_Disconnect(hhcd->pData);
 8006df0:	f8d0 03dc 	ldr.w	r0, [r0, #988]	@ 0x3dc
 8006df4:	f7ff bb34 	b.w	8006460 <USBH_LL_Disconnect>

08006df8 <HAL_HCD_HC_NotifyURBChange_Callback>:
{
  /* To be used with OS to sync URB state with the global state machine */
#if (USBH_USE_OS == 1)
  USBH_LL_NotifyURBChange(hhcd->pData);
#endif
}
 8006df8:	4770      	bx	lr
 8006dfa:	bf00      	nop

08006dfc <HAL_HCD_PortEnabled_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_PortEnabled_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_PortEnabled(hhcd->pData);
 8006dfc:	f8d0 03dc 	ldr.w	r0, [r0, #988]	@ 0x3dc
 8006e00:	f7ff bb1a 	b.w	8006438 <USBH_LL_PortEnabled>

08006e04 <HAL_HCD_PortDisabled_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_PortDisabled_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_PortDisabled(hhcd->pData);
 8006e04:	f8d0 03dc 	ldr.w	r0, [r0, #988]	@ 0x3dc
 8006e08:	f7ff bb1a 	b.w	8006440 <USBH_LL_PortDisabled>

08006e0c <USBH_LL_Start>:
  * @brief  Start the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef *phost)
{
 8006e0c:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_Start(phost->pData);
 8006e0e:	f8d0 0444 	ldr.w	r0, [r0, #1092]	@ 0x444
 8006e12:	f7fc f951 	bl	80030b8 <HAL_HCD_Start>
  */
USBH_StatusTypeDef USBH_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
  USBH_StatusTypeDef usb_status = USBH_OK;

  switch (hal_status)
 8006e16:	b118      	cbz	r0, 8006e20 <USBH_LL_Start+0x14>
 8006e18:	2802      	cmp	r0, #2
 8006e1a:	bf0c      	ite	eq
 8006e1c:	2001      	moveq	r0, #1
 8006e1e:	2002      	movne	r0, #2
}
 8006e20:	bd08      	pop	{r3, pc}
 8006e22:	bf00      	nop

08006e24 <USBH_LL_Stop>:
{
 8006e24:	b508      	push	{r3, lr}
  hal_status = HAL_HCD_Stop(phost->pData);
 8006e26:	f8d0 0444 	ldr.w	r0, [r0, #1092]	@ 0x444
 8006e2a:	f7fc f95b 	bl	80030e4 <HAL_HCD_Stop>
  switch (hal_status)
 8006e2e:	b118      	cbz	r0, 8006e38 <USBH_LL_Stop+0x14>
 8006e30:	2802      	cmp	r0, #2
 8006e32:	bf0c      	ite	eq
 8006e34:	2001      	moveq	r0, #1
 8006e36:	2002      	movne	r0, #2
}
 8006e38:	bd08      	pop	{r3, pc}
 8006e3a:	bf00      	nop

08006e3c <USBH_LL_GetSpeed>:
{
 8006e3c:	b508      	push	{r3, lr}
  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
 8006e3e:	f8d0 0444 	ldr.w	r0, [r0, #1092]	@ 0x444
 8006e42:	f7fc f96f 	bl	8003124 <HAL_HCD_GetCurrentSpeed>
 8006e46:	b118      	cbz	r0, 8006e50 <USBH_LL_GetSpeed+0x14>
 8006e48:	2802      	cmp	r0, #2
 8006e4a:	bf0c      	ite	eq
 8006e4c:	2002      	moveq	r0, #2
 8006e4e:	2001      	movne	r0, #1
}
 8006e50:	bd08      	pop	{r3, pc}
 8006e52:	bf00      	nop

08006e54 <USBH_LL_ResetPort>:
{
 8006e54:	b508      	push	{r3, lr}
  hal_status = HAL_HCD_ResetPort(phost->pData);
 8006e56:	f8d0 0444 	ldr.w	r0, [r0, #1092]	@ 0x444
 8006e5a:	f7fc f957 	bl	800310c <HAL_HCD_ResetPort>
  switch (hal_status)
 8006e5e:	b118      	cbz	r0, 8006e68 <USBH_LL_ResetPort+0x14>
 8006e60:	2802      	cmp	r0, #2
 8006e62:	bf0c      	ite	eq
 8006e64:	2001      	moveq	r0, #1
 8006e66:	2002      	movne	r0, #2
}
 8006e68:	bd08      	pop	{r3, pc}
 8006e6a:	bf00      	nop

08006e6c <USBH_LL_OpenPipe>:
{
 8006e6c:	b510      	push	{r4, lr}
 8006e6e:	b084      	sub	sp, #16
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 8006e70:	f8d0 0444 	ldr.w	r0, [r0, #1092]	@ 0x444
{
 8006e74:	f89d 4018 	ldrb.w	r4, [sp, #24]
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 8006e78:	9400      	str	r4, [sp, #0]
{
 8006e7a:	f89d 401c 	ldrb.w	r4, [sp, #28]
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 8006e7e:	9401      	str	r4, [sp, #4]
{
 8006e80:	f8bd 4020 	ldrh.w	r4, [sp, #32]
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 8006e84:	9402      	str	r4, [sp, #8]
 8006e86:	f7fb fb7d 	bl	8002584 <HAL_HCD_HC_Init>
  switch (hal_status)
 8006e8a:	b118      	cbz	r0, 8006e94 <USBH_LL_OpenPipe+0x28>
 8006e8c:	2802      	cmp	r0, #2
 8006e8e:	bf0c      	ite	eq
 8006e90:	2001      	moveq	r0, #1
 8006e92:	2002      	movne	r0, #2
}
 8006e94:	b004      	add	sp, #16
 8006e96:	bd10      	pop	{r4, pc}

08006e98 <USBH_LL_SubmitURB>:
{
 8006e98:	b510      	push	{r4, lr}
 8006e9a:	b084      	sub	sp, #16
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 8006e9c:	f8d0 0444 	ldr.w	r0, [r0, #1092]	@ 0x444
{
 8006ea0:	f89d 4018 	ldrb.w	r4, [sp, #24]
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 8006ea4:	9400      	str	r4, [sp, #0]
{
 8006ea6:	9c07      	ldr	r4, [sp, #28]
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 8006ea8:	9401      	str	r4, [sp, #4]
{
 8006eaa:	f8bd 4020 	ldrh.w	r4, [sp, #32]
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 8006eae:	9402      	str	r4, [sp, #8]
{
 8006eb0:	f89d 4024 	ldrb.w	r4, [sp, #36]	@ 0x24
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 8006eb4:	9403      	str	r4, [sp, #12]
 8006eb6:	f7fb fbc3 	bl	8002640 <HAL_HCD_HC_SubmitRequest>
  switch (hal_status)
 8006eba:	b118      	cbz	r0, 8006ec4 <USBH_LL_SubmitURB+0x2c>
 8006ebc:	2802      	cmp	r0, #2
 8006ebe:	bf0c      	ite	eq
 8006ec0:	2001      	moveq	r0, #1
 8006ec2:	2002      	movne	r0, #2
}
 8006ec4:	b004      	add	sp, #16
 8006ec6:	bd10      	pop	{r4, pc}

08006ec8 <USBH_LL_GetURBState>:
  return (USBH_URBStateTypeDef)HAL_HCD_HC_GetURBState (phost->pData, pipe);
 8006ec8:	f8d0 0444 	ldr.w	r0, [r0, #1092]	@ 0x444
 8006ecc:	f7fc b922 	b.w	8003114 <HAL_HCD_HC_GetURBState>

08006ed0 <USBH_LL_DriverVBUS>:
{
 8006ed0:	b508      	push	{r3, lr}
  if (phost->id == HOST_HS) {
 8006ed2:	f890 3440 	ldrb.w	r3, [r0, #1088]	@ 0x440
 8006ed6:	b123      	cbz	r3, 8006ee2 <USBH_LL_DriverVBUS+0x12>
  HAL_Delay(200);
 8006ed8:	20c8      	movs	r0, #200	@ 0xc8
 8006eda:	f7fb f8db 	bl	8002094 <HAL_Delay>
}
 8006ede:	2000      	movs	r0, #0
 8006ee0:	bd08      	pop	{r3, pc}
    MX_DriverVbusHS(state);
 8006ee2:	4608      	mov	r0, r1
 8006ee4:	f000 f808 	bl	8006ef8 <MX_DriverVbusHS>
  HAL_Delay(200);
 8006ee8:	20c8      	movs	r0, #200	@ 0xc8
 8006eea:	f7fb f8d3 	bl	8002094 <HAL_Delay>
}
 8006eee:	2000      	movs	r0, #0
 8006ef0:	bd08      	pop	{r3, pc}
 8006ef2:	bf00      	nop

08006ef4 <USBH_Delay>:
  HAL_Delay(Delay);
 8006ef4:	f7fb b8ce 	b.w	8002094 <HAL_Delay>

08006ef8 <MX_DriverVbusHS>:
  *          This parameter can be one of the these values:
  *          - 1 : VBUS Active
  *          - 0 : VBUS Inactive
  */
void MX_DriverVbusHS(uint8_t state)
{
 8006ef8:	4602      	mov	r2, r0
  {
    /* Drive low Charge pump */
    data = GPIO_PIN_RESET;
  }
  /* USER CODE END PREPARE_GPIO_DATA_VBUS_HS */
  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_13,(GPIO_PinState)data);
 8006efa:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 8006efe:	4803      	ldr	r0, [pc, #12]	@ (8006f0c <MX_DriverVbusHS+0x14>)
 8006f00:	fab2 f282 	clz	r2, r2
 8006f04:	0952      	lsrs	r2, r2, #5
 8006f06:	f7fb bb39 	b.w	800257c <HAL_GPIO_WritePin>
 8006f0a:	bf00      	nop
 8006f0c:	58021000 	.word	0x58021000

08006f10 <sbrk_aligned>:
 8006f10:	b570      	push	{r4, r5, r6, lr}
 8006f12:	4e0f      	ldr	r6, [pc, #60]	@ (8006f50 <sbrk_aligned+0x40>)
 8006f14:	460c      	mov	r4, r1
 8006f16:	6831      	ldr	r1, [r6, #0]
 8006f18:	4605      	mov	r5, r0
 8006f1a:	b911      	cbnz	r1, 8006f22 <sbrk_aligned+0x12>
 8006f1c:	f000 fa02 	bl	8007324 <_sbrk_r>
 8006f20:	6030      	str	r0, [r6, #0]
 8006f22:	4621      	mov	r1, r4
 8006f24:	4628      	mov	r0, r5
 8006f26:	f000 f9fd 	bl	8007324 <_sbrk_r>
 8006f2a:	1c43      	adds	r3, r0, #1
 8006f2c:	d103      	bne.n	8006f36 <sbrk_aligned+0x26>
 8006f2e:	f04f 34ff 	mov.w	r4, #4294967295
 8006f32:	4620      	mov	r0, r4
 8006f34:	bd70      	pop	{r4, r5, r6, pc}
 8006f36:	1cc4      	adds	r4, r0, #3
 8006f38:	f024 0403 	bic.w	r4, r4, #3
 8006f3c:	42a0      	cmp	r0, r4
 8006f3e:	d0f8      	beq.n	8006f32 <sbrk_aligned+0x22>
 8006f40:	1a21      	subs	r1, r4, r0
 8006f42:	4628      	mov	r0, r5
 8006f44:	f000 f9ee 	bl	8007324 <_sbrk_r>
 8006f48:	3001      	adds	r0, #1
 8006f4a:	d1f2      	bne.n	8006f32 <sbrk_aligned+0x22>
 8006f4c:	e7ef      	b.n	8006f2e <sbrk_aligned+0x1e>
 8006f4e:	bf00      	nop
 8006f50:	2400106c 	.word	0x2400106c

08006f54 <_malloc_r>:
 8006f54:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006f58:	1ccd      	adds	r5, r1, #3
 8006f5a:	f025 0503 	bic.w	r5, r5, #3
 8006f5e:	3508      	adds	r5, #8
 8006f60:	2d0c      	cmp	r5, #12
 8006f62:	bf38      	it	cc
 8006f64:	250c      	movcc	r5, #12
 8006f66:	2d00      	cmp	r5, #0
 8006f68:	4606      	mov	r6, r0
 8006f6a:	db01      	blt.n	8006f70 <_malloc_r+0x1c>
 8006f6c:	42a9      	cmp	r1, r5
 8006f6e:	d904      	bls.n	8006f7a <_malloc_r+0x26>
 8006f70:	230c      	movs	r3, #12
 8006f72:	6033      	str	r3, [r6, #0]
 8006f74:	2000      	movs	r0, #0
 8006f76:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006f7a:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 8007050 <_malloc_r+0xfc>
 8006f7e:	f000 f869 	bl	8007054 <__malloc_lock>
 8006f82:	f8d8 3000 	ldr.w	r3, [r8]
 8006f86:	461c      	mov	r4, r3
 8006f88:	bb44      	cbnz	r4, 8006fdc <_malloc_r+0x88>
 8006f8a:	4629      	mov	r1, r5
 8006f8c:	4630      	mov	r0, r6
 8006f8e:	f7ff ffbf 	bl	8006f10 <sbrk_aligned>
 8006f92:	1c43      	adds	r3, r0, #1
 8006f94:	4604      	mov	r4, r0
 8006f96:	d158      	bne.n	800704a <_malloc_r+0xf6>
 8006f98:	f8d8 4000 	ldr.w	r4, [r8]
 8006f9c:	4627      	mov	r7, r4
 8006f9e:	2f00      	cmp	r7, #0
 8006fa0:	d143      	bne.n	800702a <_malloc_r+0xd6>
 8006fa2:	2c00      	cmp	r4, #0
 8006fa4:	d04b      	beq.n	800703e <_malloc_r+0xea>
 8006fa6:	6823      	ldr	r3, [r4, #0]
 8006fa8:	4639      	mov	r1, r7
 8006faa:	4630      	mov	r0, r6
 8006fac:	eb04 0903 	add.w	r9, r4, r3
 8006fb0:	f000 f9b8 	bl	8007324 <_sbrk_r>
 8006fb4:	4581      	cmp	r9, r0
 8006fb6:	d142      	bne.n	800703e <_malloc_r+0xea>
 8006fb8:	6821      	ldr	r1, [r4, #0]
 8006fba:	1a6d      	subs	r5, r5, r1
 8006fbc:	4629      	mov	r1, r5
 8006fbe:	4630      	mov	r0, r6
 8006fc0:	f7ff ffa6 	bl	8006f10 <sbrk_aligned>
 8006fc4:	3001      	adds	r0, #1
 8006fc6:	d03a      	beq.n	800703e <_malloc_r+0xea>
 8006fc8:	6823      	ldr	r3, [r4, #0]
 8006fca:	442b      	add	r3, r5
 8006fcc:	6023      	str	r3, [r4, #0]
 8006fce:	f8d8 3000 	ldr.w	r3, [r8]
 8006fd2:	685a      	ldr	r2, [r3, #4]
 8006fd4:	bb62      	cbnz	r2, 8007030 <_malloc_r+0xdc>
 8006fd6:	f8c8 7000 	str.w	r7, [r8]
 8006fda:	e00f      	b.n	8006ffc <_malloc_r+0xa8>
 8006fdc:	6822      	ldr	r2, [r4, #0]
 8006fde:	1b52      	subs	r2, r2, r5
 8006fe0:	d420      	bmi.n	8007024 <_malloc_r+0xd0>
 8006fe2:	2a0b      	cmp	r2, #11
 8006fe4:	d917      	bls.n	8007016 <_malloc_r+0xc2>
 8006fe6:	1961      	adds	r1, r4, r5
 8006fe8:	42a3      	cmp	r3, r4
 8006fea:	6025      	str	r5, [r4, #0]
 8006fec:	bf18      	it	ne
 8006fee:	6059      	strne	r1, [r3, #4]
 8006ff0:	6863      	ldr	r3, [r4, #4]
 8006ff2:	bf08      	it	eq
 8006ff4:	f8c8 1000 	streq.w	r1, [r8]
 8006ff8:	5162      	str	r2, [r4, r5]
 8006ffa:	604b      	str	r3, [r1, #4]
 8006ffc:	4630      	mov	r0, r6
 8006ffe:	f000 f82f 	bl	8007060 <__malloc_unlock>
 8007002:	f104 000b 	add.w	r0, r4, #11
 8007006:	1d23      	adds	r3, r4, #4
 8007008:	f020 0007 	bic.w	r0, r0, #7
 800700c:	1ac2      	subs	r2, r0, r3
 800700e:	bf1c      	itt	ne
 8007010:	1a1b      	subne	r3, r3, r0
 8007012:	50a3      	strne	r3, [r4, r2]
 8007014:	e7af      	b.n	8006f76 <_malloc_r+0x22>
 8007016:	6862      	ldr	r2, [r4, #4]
 8007018:	42a3      	cmp	r3, r4
 800701a:	bf0c      	ite	eq
 800701c:	f8c8 2000 	streq.w	r2, [r8]
 8007020:	605a      	strne	r2, [r3, #4]
 8007022:	e7eb      	b.n	8006ffc <_malloc_r+0xa8>
 8007024:	4623      	mov	r3, r4
 8007026:	6864      	ldr	r4, [r4, #4]
 8007028:	e7ae      	b.n	8006f88 <_malloc_r+0x34>
 800702a:	463c      	mov	r4, r7
 800702c:	687f      	ldr	r7, [r7, #4]
 800702e:	e7b6      	b.n	8006f9e <_malloc_r+0x4a>
 8007030:	461a      	mov	r2, r3
 8007032:	685b      	ldr	r3, [r3, #4]
 8007034:	42a3      	cmp	r3, r4
 8007036:	d1fb      	bne.n	8007030 <_malloc_r+0xdc>
 8007038:	2300      	movs	r3, #0
 800703a:	6053      	str	r3, [r2, #4]
 800703c:	e7de      	b.n	8006ffc <_malloc_r+0xa8>
 800703e:	230c      	movs	r3, #12
 8007040:	6033      	str	r3, [r6, #0]
 8007042:	4630      	mov	r0, r6
 8007044:	f000 f80c 	bl	8007060 <__malloc_unlock>
 8007048:	e794      	b.n	8006f74 <_malloc_r+0x20>
 800704a:	6005      	str	r5, [r0, #0]
 800704c:	e7d6      	b.n	8006ffc <_malloc_r+0xa8>
 800704e:	bf00      	nop
 8007050:	24001070 	.word	0x24001070

08007054 <__malloc_lock>:
 8007054:	4801      	ldr	r0, [pc, #4]	@ (800705c <__malloc_lock+0x8>)
 8007056:	f000 b9b2 	b.w	80073be <__retarget_lock_acquire_recursive>
 800705a:	bf00      	nop
 800705c:	240011b4 	.word	0x240011b4

08007060 <__malloc_unlock>:
 8007060:	4801      	ldr	r0, [pc, #4]	@ (8007068 <__malloc_unlock+0x8>)
 8007062:	f000 b9ad 	b.w	80073c0 <__retarget_lock_release_recursive>
 8007066:	bf00      	nop
 8007068:	240011b4 	.word	0x240011b4

0800706c <std>:
 800706c:	2300      	movs	r3, #0
 800706e:	b510      	push	{r4, lr}
 8007070:	4604      	mov	r4, r0
 8007072:	e9c0 3300 	strd	r3, r3, [r0]
 8007076:	e9c0 3304 	strd	r3, r3, [r0, #16]
 800707a:	6083      	str	r3, [r0, #8]
 800707c:	8181      	strh	r1, [r0, #12]
 800707e:	6643      	str	r3, [r0, #100]	@ 0x64
 8007080:	81c2      	strh	r2, [r0, #14]
 8007082:	6183      	str	r3, [r0, #24]
 8007084:	4619      	mov	r1, r3
 8007086:	2208      	movs	r2, #8
 8007088:	305c      	adds	r0, #92	@ 0x5c
 800708a:	f000 f90e 	bl	80072aa <memset>
 800708e:	4b0d      	ldr	r3, [pc, #52]	@ (80070c4 <std+0x58>)
 8007090:	6263      	str	r3, [r4, #36]	@ 0x24
 8007092:	4b0d      	ldr	r3, [pc, #52]	@ (80070c8 <std+0x5c>)
 8007094:	62a3      	str	r3, [r4, #40]	@ 0x28
 8007096:	4b0d      	ldr	r3, [pc, #52]	@ (80070cc <std+0x60>)
 8007098:	62e3      	str	r3, [r4, #44]	@ 0x2c
 800709a:	4b0d      	ldr	r3, [pc, #52]	@ (80070d0 <std+0x64>)
 800709c:	6323      	str	r3, [r4, #48]	@ 0x30
 800709e:	4b0d      	ldr	r3, [pc, #52]	@ (80070d4 <std+0x68>)
 80070a0:	6224      	str	r4, [r4, #32]
 80070a2:	429c      	cmp	r4, r3
 80070a4:	d006      	beq.n	80070b4 <std+0x48>
 80070a6:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 80070aa:	4294      	cmp	r4, r2
 80070ac:	d002      	beq.n	80070b4 <std+0x48>
 80070ae:	33d0      	adds	r3, #208	@ 0xd0
 80070b0:	429c      	cmp	r4, r3
 80070b2:	d105      	bne.n	80070c0 <std+0x54>
 80070b4:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 80070b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80070bc:	f000 b97e 	b.w	80073bc <__retarget_lock_init_recursive>
 80070c0:	bd10      	pop	{r4, pc}
 80070c2:	bf00      	nop
 80070c4:	08007225 	.word	0x08007225
 80070c8:	08007247 	.word	0x08007247
 80070cc:	0800727f 	.word	0x0800727f
 80070d0:	080072a3 	.word	0x080072a3
 80070d4:	24001074 	.word	0x24001074

080070d8 <stdio_exit_handler>:
 80070d8:	4a02      	ldr	r2, [pc, #8]	@ (80070e4 <stdio_exit_handler+0xc>)
 80070da:	4903      	ldr	r1, [pc, #12]	@ (80070e8 <stdio_exit_handler+0x10>)
 80070dc:	4803      	ldr	r0, [pc, #12]	@ (80070ec <stdio_exit_handler+0x14>)
 80070de:	f000 b869 	b.w	80071b4 <_fwalk_sglue>
 80070e2:	bf00      	nop
 80070e4:	24000034 	.word	0x24000034
 80070e8:	08007afd 	.word	0x08007afd
 80070ec:	24000044 	.word	0x24000044

080070f0 <cleanup_stdio>:
 80070f0:	6841      	ldr	r1, [r0, #4]
 80070f2:	4b0c      	ldr	r3, [pc, #48]	@ (8007124 <cleanup_stdio+0x34>)
 80070f4:	4299      	cmp	r1, r3
 80070f6:	b510      	push	{r4, lr}
 80070f8:	4604      	mov	r4, r0
 80070fa:	d001      	beq.n	8007100 <cleanup_stdio+0x10>
 80070fc:	f000 fcfe 	bl	8007afc <_fflush_r>
 8007100:	68a1      	ldr	r1, [r4, #8]
 8007102:	4b09      	ldr	r3, [pc, #36]	@ (8007128 <cleanup_stdio+0x38>)
 8007104:	4299      	cmp	r1, r3
 8007106:	d002      	beq.n	800710e <cleanup_stdio+0x1e>
 8007108:	4620      	mov	r0, r4
 800710a:	f000 fcf7 	bl	8007afc <_fflush_r>
 800710e:	68e1      	ldr	r1, [r4, #12]
 8007110:	4b06      	ldr	r3, [pc, #24]	@ (800712c <cleanup_stdio+0x3c>)
 8007112:	4299      	cmp	r1, r3
 8007114:	d004      	beq.n	8007120 <cleanup_stdio+0x30>
 8007116:	4620      	mov	r0, r4
 8007118:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800711c:	f000 bcee 	b.w	8007afc <_fflush_r>
 8007120:	bd10      	pop	{r4, pc}
 8007122:	bf00      	nop
 8007124:	24001074 	.word	0x24001074
 8007128:	240010dc 	.word	0x240010dc
 800712c:	24001144 	.word	0x24001144

08007130 <global_stdio_init.part.0>:
 8007130:	b510      	push	{r4, lr}
 8007132:	4b0b      	ldr	r3, [pc, #44]	@ (8007160 <global_stdio_init.part.0+0x30>)
 8007134:	4c0b      	ldr	r4, [pc, #44]	@ (8007164 <global_stdio_init.part.0+0x34>)
 8007136:	4a0c      	ldr	r2, [pc, #48]	@ (8007168 <global_stdio_init.part.0+0x38>)
 8007138:	601a      	str	r2, [r3, #0]
 800713a:	4620      	mov	r0, r4
 800713c:	2200      	movs	r2, #0
 800713e:	2104      	movs	r1, #4
 8007140:	f7ff ff94 	bl	800706c <std>
 8007144:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 8007148:	2201      	movs	r2, #1
 800714a:	2109      	movs	r1, #9
 800714c:	f7ff ff8e 	bl	800706c <std>
 8007150:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 8007154:	2202      	movs	r2, #2
 8007156:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800715a:	2112      	movs	r1, #18
 800715c:	f7ff bf86 	b.w	800706c <std>
 8007160:	240011ac 	.word	0x240011ac
 8007164:	24001074 	.word	0x24001074
 8007168:	080070d9 	.word	0x080070d9

0800716c <__sfp_lock_acquire>:
 800716c:	4801      	ldr	r0, [pc, #4]	@ (8007174 <__sfp_lock_acquire+0x8>)
 800716e:	f000 b926 	b.w	80073be <__retarget_lock_acquire_recursive>
 8007172:	bf00      	nop
 8007174:	240011b5 	.word	0x240011b5

08007178 <__sfp_lock_release>:
 8007178:	4801      	ldr	r0, [pc, #4]	@ (8007180 <__sfp_lock_release+0x8>)
 800717a:	f000 b921 	b.w	80073c0 <__retarget_lock_release_recursive>
 800717e:	bf00      	nop
 8007180:	240011b5 	.word	0x240011b5

08007184 <__sinit>:
 8007184:	b510      	push	{r4, lr}
 8007186:	4604      	mov	r4, r0
 8007188:	f7ff fff0 	bl	800716c <__sfp_lock_acquire>
 800718c:	6a23      	ldr	r3, [r4, #32]
 800718e:	b11b      	cbz	r3, 8007198 <__sinit+0x14>
 8007190:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8007194:	f7ff bff0 	b.w	8007178 <__sfp_lock_release>
 8007198:	4b04      	ldr	r3, [pc, #16]	@ (80071ac <__sinit+0x28>)
 800719a:	6223      	str	r3, [r4, #32]
 800719c:	4b04      	ldr	r3, [pc, #16]	@ (80071b0 <__sinit+0x2c>)
 800719e:	681b      	ldr	r3, [r3, #0]
 80071a0:	2b00      	cmp	r3, #0
 80071a2:	d1f5      	bne.n	8007190 <__sinit+0xc>
 80071a4:	f7ff ffc4 	bl	8007130 <global_stdio_init.part.0>
 80071a8:	e7f2      	b.n	8007190 <__sinit+0xc>
 80071aa:	bf00      	nop
 80071ac:	080070f1 	.word	0x080070f1
 80071b0:	240011ac 	.word	0x240011ac

080071b4 <_fwalk_sglue>:
 80071b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80071b8:	4607      	mov	r7, r0
 80071ba:	4688      	mov	r8, r1
 80071bc:	4614      	mov	r4, r2
 80071be:	2600      	movs	r6, #0
 80071c0:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 80071c4:	f1b9 0901 	subs.w	r9, r9, #1
 80071c8:	d505      	bpl.n	80071d6 <_fwalk_sglue+0x22>
 80071ca:	6824      	ldr	r4, [r4, #0]
 80071cc:	2c00      	cmp	r4, #0
 80071ce:	d1f7      	bne.n	80071c0 <_fwalk_sglue+0xc>
 80071d0:	4630      	mov	r0, r6
 80071d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80071d6:	89ab      	ldrh	r3, [r5, #12]
 80071d8:	2b01      	cmp	r3, #1
 80071da:	d907      	bls.n	80071ec <_fwalk_sglue+0x38>
 80071dc:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 80071e0:	3301      	adds	r3, #1
 80071e2:	d003      	beq.n	80071ec <_fwalk_sglue+0x38>
 80071e4:	4629      	mov	r1, r5
 80071e6:	4638      	mov	r0, r7
 80071e8:	47c0      	blx	r8
 80071ea:	4306      	orrs	r6, r0
 80071ec:	3568      	adds	r5, #104	@ 0x68
 80071ee:	e7e9      	b.n	80071c4 <_fwalk_sglue+0x10>

080071f0 <iprintf>:
 80071f0:	b40f      	push	{r0, r1, r2, r3}
 80071f2:	b507      	push	{r0, r1, r2, lr}
 80071f4:	4906      	ldr	r1, [pc, #24]	@ (8007210 <iprintf+0x20>)
 80071f6:	ab04      	add	r3, sp, #16
 80071f8:	6808      	ldr	r0, [r1, #0]
 80071fa:	f853 2b04 	ldr.w	r2, [r3], #4
 80071fe:	6881      	ldr	r1, [r0, #8]
 8007200:	9301      	str	r3, [sp, #4]
 8007202:	f000 f953 	bl	80074ac <_vfiprintf_r>
 8007206:	b003      	add	sp, #12
 8007208:	f85d eb04 	ldr.w	lr, [sp], #4
 800720c:	b004      	add	sp, #16
 800720e:	4770      	bx	lr
 8007210:	24000040 	.word	0x24000040

08007214 <putchar>:
 8007214:	4b02      	ldr	r3, [pc, #8]	@ (8007220 <putchar+0xc>)
 8007216:	4601      	mov	r1, r0
 8007218:	6818      	ldr	r0, [r3, #0]
 800721a:	6882      	ldr	r2, [r0, #8]
 800721c:	f000 bc96 	b.w	8007b4c <_putc_r>
 8007220:	24000040 	.word	0x24000040

08007224 <__sread>:
 8007224:	b510      	push	{r4, lr}
 8007226:	460c      	mov	r4, r1
 8007228:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800722c:	f000 f868 	bl	8007300 <_read_r>
 8007230:	2800      	cmp	r0, #0
 8007232:	bfab      	itete	ge
 8007234:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 8007236:	89a3      	ldrhlt	r3, [r4, #12]
 8007238:	181b      	addge	r3, r3, r0
 800723a:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 800723e:	bfac      	ite	ge
 8007240:	6563      	strge	r3, [r4, #84]	@ 0x54
 8007242:	81a3      	strhlt	r3, [r4, #12]
 8007244:	bd10      	pop	{r4, pc}

08007246 <__swrite>:
 8007246:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800724a:	461f      	mov	r7, r3
 800724c:	898b      	ldrh	r3, [r1, #12]
 800724e:	05db      	lsls	r3, r3, #23
 8007250:	4605      	mov	r5, r0
 8007252:	460c      	mov	r4, r1
 8007254:	4616      	mov	r6, r2
 8007256:	d505      	bpl.n	8007264 <__swrite+0x1e>
 8007258:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800725c:	2302      	movs	r3, #2
 800725e:	2200      	movs	r2, #0
 8007260:	f000 f83c 	bl	80072dc <_lseek_r>
 8007264:	89a3      	ldrh	r3, [r4, #12]
 8007266:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800726a:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 800726e:	81a3      	strh	r3, [r4, #12]
 8007270:	4632      	mov	r2, r6
 8007272:	463b      	mov	r3, r7
 8007274:	4628      	mov	r0, r5
 8007276:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800727a:	f000 b863 	b.w	8007344 <_write_r>

0800727e <__sseek>:
 800727e:	b510      	push	{r4, lr}
 8007280:	460c      	mov	r4, r1
 8007282:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8007286:	f000 f829 	bl	80072dc <_lseek_r>
 800728a:	1c43      	adds	r3, r0, #1
 800728c:	89a3      	ldrh	r3, [r4, #12]
 800728e:	bf15      	itete	ne
 8007290:	6560      	strne	r0, [r4, #84]	@ 0x54
 8007292:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 8007296:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 800729a:	81a3      	strheq	r3, [r4, #12]
 800729c:	bf18      	it	ne
 800729e:	81a3      	strhne	r3, [r4, #12]
 80072a0:	bd10      	pop	{r4, pc}

080072a2 <__sclose>:
 80072a2:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80072a6:	f000 b809 	b.w	80072bc <_close_r>

080072aa <memset>:
 80072aa:	4402      	add	r2, r0
 80072ac:	4603      	mov	r3, r0
 80072ae:	4293      	cmp	r3, r2
 80072b0:	d100      	bne.n	80072b4 <memset+0xa>
 80072b2:	4770      	bx	lr
 80072b4:	f803 1b01 	strb.w	r1, [r3], #1
 80072b8:	e7f9      	b.n	80072ae <memset+0x4>
	...

080072bc <_close_r>:
 80072bc:	b538      	push	{r3, r4, r5, lr}
 80072be:	4d06      	ldr	r5, [pc, #24]	@ (80072d8 <_close_r+0x1c>)
 80072c0:	2300      	movs	r3, #0
 80072c2:	4604      	mov	r4, r0
 80072c4:	4608      	mov	r0, r1
 80072c6:	602b      	str	r3, [r5, #0]
 80072c8:	f7fa fc2c 	bl	8001b24 <_close>
 80072cc:	1c43      	adds	r3, r0, #1
 80072ce:	d102      	bne.n	80072d6 <_close_r+0x1a>
 80072d0:	682b      	ldr	r3, [r5, #0]
 80072d2:	b103      	cbz	r3, 80072d6 <_close_r+0x1a>
 80072d4:	6023      	str	r3, [r4, #0]
 80072d6:	bd38      	pop	{r3, r4, r5, pc}
 80072d8:	240011b0 	.word	0x240011b0

080072dc <_lseek_r>:
 80072dc:	b538      	push	{r3, r4, r5, lr}
 80072de:	4d07      	ldr	r5, [pc, #28]	@ (80072fc <_lseek_r+0x20>)
 80072e0:	4604      	mov	r4, r0
 80072e2:	4608      	mov	r0, r1
 80072e4:	4611      	mov	r1, r2
 80072e6:	2200      	movs	r2, #0
 80072e8:	602a      	str	r2, [r5, #0]
 80072ea:	461a      	mov	r2, r3
 80072ec:	f7fa fc26 	bl	8001b3c <_lseek>
 80072f0:	1c43      	adds	r3, r0, #1
 80072f2:	d102      	bne.n	80072fa <_lseek_r+0x1e>
 80072f4:	682b      	ldr	r3, [r5, #0]
 80072f6:	b103      	cbz	r3, 80072fa <_lseek_r+0x1e>
 80072f8:	6023      	str	r3, [r4, #0]
 80072fa:	bd38      	pop	{r3, r4, r5, pc}
 80072fc:	240011b0 	.word	0x240011b0

08007300 <_read_r>:
 8007300:	b538      	push	{r3, r4, r5, lr}
 8007302:	4d07      	ldr	r5, [pc, #28]	@ (8007320 <_read_r+0x20>)
 8007304:	4604      	mov	r4, r0
 8007306:	4608      	mov	r0, r1
 8007308:	4611      	mov	r1, r2
 800730a:	2200      	movs	r2, #0
 800730c:	602a      	str	r2, [r5, #0]
 800730e:	461a      	mov	r2, r3
 8007310:	f7fa fbec 	bl	8001aec <_read>
 8007314:	1c43      	adds	r3, r0, #1
 8007316:	d102      	bne.n	800731e <_read_r+0x1e>
 8007318:	682b      	ldr	r3, [r5, #0]
 800731a:	b103      	cbz	r3, 800731e <_read_r+0x1e>
 800731c:	6023      	str	r3, [r4, #0]
 800731e:	bd38      	pop	{r3, r4, r5, pc}
 8007320:	240011b0 	.word	0x240011b0

08007324 <_sbrk_r>:
 8007324:	b538      	push	{r3, r4, r5, lr}
 8007326:	4d06      	ldr	r5, [pc, #24]	@ (8007340 <_sbrk_r+0x1c>)
 8007328:	2300      	movs	r3, #0
 800732a:	4604      	mov	r4, r0
 800732c:	4608      	mov	r0, r1
 800732e:	602b      	str	r3, [r5, #0]
 8007330:	f7fa fc06 	bl	8001b40 <_sbrk>
 8007334:	1c43      	adds	r3, r0, #1
 8007336:	d102      	bne.n	800733e <_sbrk_r+0x1a>
 8007338:	682b      	ldr	r3, [r5, #0]
 800733a:	b103      	cbz	r3, 800733e <_sbrk_r+0x1a>
 800733c:	6023      	str	r3, [r4, #0]
 800733e:	bd38      	pop	{r3, r4, r5, pc}
 8007340:	240011b0 	.word	0x240011b0

08007344 <_write_r>:
 8007344:	b538      	push	{r3, r4, r5, lr}
 8007346:	4d07      	ldr	r5, [pc, #28]	@ (8007364 <_write_r+0x20>)
 8007348:	4604      	mov	r4, r0
 800734a:	4608      	mov	r0, r1
 800734c:	4611      	mov	r1, r2
 800734e:	2200      	movs	r2, #0
 8007350:	602a      	str	r2, [r5, #0]
 8007352:	461a      	mov	r2, r3
 8007354:	f7fa fbd8 	bl	8001b08 <_write>
 8007358:	1c43      	adds	r3, r0, #1
 800735a:	d102      	bne.n	8007362 <_write_r+0x1e>
 800735c:	682b      	ldr	r3, [r5, #0]
 800735e:	b103      	cbz	r3, 8007362 <_write_r+0x1e>
 8007360:	6023      	str	r3, [r4, #0]
 8007362:	bd38      	pop	{r3, r4, r5, pc}
 8007364:	240011b0 	.word	0x240011b0

08007368 <__errno>:
 8007368:	4b01      	ldr	r3, [pc, #4]	@ (8007370 <__errno+0x8>)
 800736a:	6818      	ldr	r0, [r3, #0]
 800736c:	4770      	bx	lr
 800736e:	bf00      	nop
 8007370:	24000040 	.word	0x24000040

08007374 <__libc_init_array>:
 8007374:	b570      	push	{r4, r5, r6, lr}
 8007376:	4d0d      	ldr	r5, [pc, #52]	@ (80073ac <__libc_init_array+0x38>)
 8007378:	4c0d      	ldr	r4, [pc, #52]	@ (80073b0 <__libc_init_array+0x3c>)
 800737a:	1b64      	subs	r4, r4, r5
 800737c:	10a4      	asrs	r4, r4, #2
 800737e:	2600      	movs	r6, #0
 8007380:	42a6      	cmp	r6, r4
 8007382:	d109      	bne.n	8007398 <__libc_init_array+0x24>
 8007384:	4d0b      	ldr	r5, [pc, #44]	@ (80073b4 <__libc_init_array+0x40>)
 8007386:	4c0c      	ldr	r4, [pc, #48]	@ (80073b8 <__libc_init_array+0x44>)
 8007388:	f000 fd2c 	bl	8007de4 <_init>
 800738c:	1b64      	subs	r4, r4, r5
 800738e:	10a4      	asrs	r4, r4, #2
 8007390:	2600      	movs	r6, #0
 8007392:	42a6      	cmp	r6, r4
 8007394:	d105      	bne.n	80073a2 <__libc_init_array+0x2e>
 8007396:	bd70      	pop	{r4, r5, r6, pc}
 8007398:	f855 3b04 	ldr.w	r3, [r5], #4
 800739c:	4798      	blx	r3
 800739e:	3601      	adds	r6, #1
 80073a0:	e7ee      	b.n	8007380 <__libc_init_array+0xc>
 80073a2:	f855 3b04 	ldr.w	r3, [r5], #4
 80073a6:	4798      	blx	r3
 80073a8:	3601      	adds	r6, #1
 80073aa:	e7f2      	b.n	8007392 <__libc_init_array+0x1e>
 80073ac:	080087c4 	.word	0x080087c4
 80073b0:	080087c4 	.word	0x080087c4
 80073b4:	080087c4 	.word	0x080087c4
 80073b8:	080087c8 	.word	0x080087c8

080073bc <__retarget_lock_init_recursive>:
 80073bc:	4770      	bx	lr

080073be <__retarget_lock_acquire_recursive>:
 80073be:	4770      	bx	lr

080073c0 <__retarget_lock_release_recursive>:
 80073c0:	4770      	bx	lr
	...

080073c4 <_free_r>:
 80073c4:	b538      	push	{r3, r4, r5, lr}
 80073c6:	4605      	mov	r5, r0
 80073c8:	2900      	cmp	r1, #0
 80073ca:	d041      	beq.n	8007450 <_free_r+0x8c>
 80073cc:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80073d0:	1f0c      	subs	r4, r1, #4
 80073d2:	2b00      	cmp	r3, #0
 80073d4:	bfb8      	it	lt
 80073d6:	18e4      	addlt	r4, r4, r3
 80073d8:	f7ff fe3c 	bl	8007054 <__malloc_lock>
 80073dc:	4a1d      	ldr	r2, [pc, #116]	@ (8007454 <_free_r+0x90>)
 80073de:	6813      	ldr	r3, [r2, #0]
 80073e0:	b933      	cbnz	r3, 80073f0 <_free_r+0x2c>
 80073e2:	6063      	str	r3, [r4, #4]
 80073e4:	6014      	str	r4, [r2, #0]
 80073e6:	4628      	mov	r0, r5
 80073e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80073ec:	f7ff be38 	b.w	8007060 <__malloc_unlock>
 80073f0:	42a3      	cmp	r3, r4
 80073f2:	d908      	bls.n	8007406 <_free_r+0x42>
 80073f4:	6820      	ldr	r0, [r4, #0]
 80073f6:	1821      	adds	r1, r4, r0
 80073f8:	428b      	cmp	r3, r1
 80073fa:	bf01      	itttt	eq
 80073fc:	6819      	ldreq	r1, [r3, #0]
 80073fe:	685b      	ldreq	r3, [r3, #4]
 8007400:	1809      	addeq	r1, r1, r0
 8007402:	6021      	streq	r1, [r4, #0]
 8007404:	e7ed      	b.n	80073e2 <_free_r+0x1e>
 8007406:	461a      	mov	r2, r3
 8007408:	685b      	ldr	r3, [r3, #4]
 800740a:	b10b      	cbz	r3, 8007410 <_free_r+0x4c>
 800740c:	42a3      	cmp	r3, r4
 800740e:	d9fa      	bls.n	8007406 <_free_r+0x42>
 8007410:	6811      	ldr	r1, [r2, #0]
 8007412:	1850      	adds	r0, r2, r1
 8007414:	42a0      	cmp	r0, r4
 8007416:	d10b      	bne.n	8007430 <_free_r+0x6c>
 8007418:	6820      	ldr	r0, [r4, #0]
 800741a:	4401      	add	r1, r0
 800741c:	1850      	adds	r0, r2, r1
 800741e:	4283      	cmp	r3, r0
 8007420:	6011      	str	r1, [r2, #0]
 8007422:	d1e0      	bne.n	80073e6 <_free_r+0x22>
 8007424:	6818      	ldr	r0, [r3, #0]
 8007426:	685b      	ldr	r3, [r3, #4]
 8007428:	6053      	str	r3, [r2, #4]
 800742a:	4408      	add	r0, r1
 800742c:	6010      	str	r0, [r2, #0]
 800742e:	e7da      	b.n	80073e6 <_free_r+0x22>
 8007430:	d902      	bls.n	8007438 <_free_r+0x74>
 8007432:	230c      	movs	r3, #12
 8007434:	602b      	str	r3, [r5, #0]
 8007436:	e7d6      	b.n	80073e6 <_free_r+0x22>
 8007438:	6820      	ldr	r0, [r4, #0]
 800743a:	1821      	adds	r1, r4, r0
 800743c:	428b      	cmp	r3, r1
 800743e:	bf04      	itt	eq
 8007440:	6819      	ldreq	r1, [r3, #0]
 8007442:	685b      	ldreq	r3, [r3, #4]
 8007444:	6063      	str	r3, [r4, #4]
 8007446:	bf04      	itt	eq
 8007448:	1809      	addeq	r1, r1, r0
 800744a:	6021      	streq	r1, [r4, #0]
 800744c:	6054      	str	r4, [r2, #4]
 800744e:	e7ca      	b.n	80073e6 <_free_r+0x22>
 8007450:	bd38      	pop	{r3, r4, r5, pc}
 8007452:	bf00      	nop
 8007454:	24001070 	.word	0x24001070

08007458 <__sfputc_r>:
 8007458:	6893      	ldr	r3, [r2, #8]
 800745a:	3b01      	subs	r3, #1
 800745c:	2b00      	cmp	r3, #0
 800745e:	b410      	push	{r4}
 8007460:	6093      	str	r3, [r2, #8]
 8007462:	da08      	bge.n	8007476 <__sfputc_r+0x1e>
 8007464:	6994      	ldr	r4, [r2, #24]
 8007466:	42a3      	cmp	r3, r4
 8007468:	db01      	blt.n	800746e <__sfputc_r+0x16>
 800746a:	290a      	cmp	r1, #10
 800746c:	d103      	bne.n	8007476 <__sfputc_r+0x1e>
 800746e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007472:	f000 bb9f 	b.w	8007bb4 <__swbuf_r>
 8007476:	6813      	ldr	r3, [r2, #0]
 8007478:	1c58      	adds	r0, r3, #1
 800747a:	6010      	str	r0, [r2, #0]
 800747c:	7019      	strb	r1, [r3, #0]
 800747e:	4608      	mov	r0, r1
 8007480:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007484:	4770      	bx	lr

08007486 <__sfputs_r>:
 8007486:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007488:	4606      	mov	r6, r0
 800748a:	460f      	mov	r7, r1
 800748c:	4614      	mov	r4, r2
 800748e:	18d5      	adds	r5, r2, r3
 8007490:	42ac      	cmp	r4, r5
 8007492:	d101      	bne.n	8007498 <__sfputs_r+0x12>
 8007494:	2000      	movs	r0, #0
 8007496:	e007      	b.n	80074a8 <__sfputs_r+0x22>
 8007498:	f814 1b01 	ldrb.w	r1, [r4], #1
 800749c:	463a      	mov	r2, r7
 800749e:	4630      	mov	r0, r6
 80074a0:	f7ff ffda 	bl	8007458 <__sfputc_r>
 80074a4:	1c43      	adds	r3, r0, #1
 80074a6:	d1f3      	bne.n	8007490 <__sfputs_r+0xa>
 80074a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080074ac <_vfiprintf_r>:
 80074ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80074b0:	460d      	mov	r5, r1
 80074b2:	b09d      	sub	sp, #116	@ 0x74
 80074b4:	4614      	mov	r4, r2
 80074b6:	4698      	mov	r8, r3
 80074b8:	4606      	mov	r6, r0
 80074ba:	b118      	cbz	r0, 80074c4 <_vfiprintf_r+0x18>
 80074bc:	6a03      	ldr	r3, [r0, #32]
 80074be:	b90b      	cbnz	r3, 80074c4 <_vfiprintf_r+0x18>
 80074c0:	f7ff fe60 	bl	8007184 <__sinit>
 80074c4:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 80074c6:	07d9      	lsls	r1, r3, #31
 80074c8:	d405      	bmi.n	80074d6 <_vfiprintf_r+0x2a>
 80074ca:	89ab      	ldrh	r3, [r5, #12]
 80074cc:	059a      	lsls	r2, r3, #22
 80074ce:	d402      	bmi.n	80074d6 <_vfiprintf_r+0x2a>
 80074d0:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 80074d2:	f7ff ff74 	bl	80073be <__retarget_lock_acquire_recursive>
 80074d6:	89ab      	ldrh	r3, [r5, #12]
 80074d8:	071b      	lsls	r3, r3, #28
 80074da:	d501      	bpl.n	80074e0 <_vfiprintf_r+0x34>
 80074dc:	692b      	ldr	r3, [r5, #16]
 80074de:	b99b      	cbnz	r3, 8007508 <_vfiprintf_r+0x5c>
 80074e0:	4629      	mov	r1, r5
 80074e2:	4630      	mov	r0, r6
 80074e4:	f000 fba4 	bl	8007c30 <__swsetup_r>
 80074e8:	b170      	cbz	r0, 8007508 <_vfiprintf_r+0x5c>
 80074ea:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 80074ec:	07dc      	lsls	r4, r3, #31
 80074ee:	d504      	bpl.n	80074fa <_vfiprintf_r+0x4e>
 80074f0:	f04f 30ff 	mov.w	r0, #4294967295
 80074f4:	b01d      	add	sp, #116	@ 0x74
 80074f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80074fa:	89ab      	ldrh	r3, [r5, #12]
 80074fc:	0598      	lsls	r0, r3, #22
 80074fe:	d4f7      	bmi.n	80074f0 <_vfiprintf_r+0x44>
 8007500:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 8007502:	f7ff ff5d 	bl	80073c0 <__retarget_lock_release_recursive>
 8007506:	e7f3      	b.n	80074f0 <_vfiprintf_r+0x44>
 8007508:	2300      	movs	r3, #0
 800750a:	9309      	str	r3, [sp, #36]	@ 0x24
 800750c:	2320      	movs	r3, #32
 800750e:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 8007512:	f8cd 800c 	str.w	r8, [sp, #12]
 8007516:	2330      	movs	r3, #48	@ 0x30
 8007518:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 80076c8 <_vfiprintf_r+0x21c>
 800751c:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 8007520:	f04f 0901 	mov.w	r9, #1
 8007524:	4623      	mov	r3, r4
 8007526:	469a      	mov	sl, r3
 8007528:	f813 2b01 	ldrb.w	r2, [r3], #1
 800752c:	b10a      	cbz	r2, 8007532 <_vfiprintf_r+0x86>
 800752e:	2a25      	cmp	r2, #37	@ 0x25
 8007530:	d1f9      	bne.n	8007526 <_vfiprintf_r+0x7a>
 8007532:	ebba 0b04 	subs.w	fp, sl, r4
 8007536:	d00b      	beq.n	8007550 <_vfiprintf_r+0xa4>
 8007538:	465b      	mov	r3, fp
 800753a:	4622      	mov	r2, r4
 800753c:	4629      	mov	r1, r5
 800753e:	4630      	mov	r0, r6
 8007540:	f7ff ffa1 	bl	8007486 <__sfputs_r>
 8007544:	3001      	adds	r0, #1
 8007546:	f000 80a7 	beq.w	8007698 <_vfiprintf_r+0x1ec>
 800754a:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800754c:	445a      	add	r2, fp
 800754e:	9209      	str	r2, [sp, #36]	@ 0x24
 8007550:	f89a 3000 	ldrb.w	r3, [sl]
 8007554:	2b00      	cmp	r3, #0
 8007556:	f000 809f 	beq.w	8007698 <_vfiprintf_r+0x1ec>
 800755a:	2300      	movs	r3, #0
 800755c:	f04f 32ff 	mov.w	r2, #4294967295
 8007560:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8007564:	f10a 0a01 	add.w	sl, sl, #1
 8007568:	9304      	str	r3, [sp, #16]
 800756a:	9307      	str	r3, [sp, #28]
 800756c:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 8007570:	931a      	str	r3, [sp, #104]	@ 0x68
 8007572:	4654      	mov	r4, sl
 8007574:	2205      	movs	r2, #5
 8007576:	f814 1b01 	ldrb.w	r1, [r4], #1
 800757a:	4853      	ldr	r0, [pc, #332]	@ (80076c8 <_vfiprintf_r+0x21c>)
 800757c:	f7f8 feb0 	bl	80002e0 <memchr>
 8007580:	9a04      	ldr	r2, [sp, #16]
 8007582:	b9d8      	cbnz	r0, 80075bc <_vfiprintf_r+0x110>
 8007584:	06d1      	lsls	r1, r2, #27
 8007586:	bf44      	itt	mi
 8007588:	2320      	movmi	r3, #32
 800758a:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 800758e:	0713      	lsls	r3, r2, #28
 8007590:	bf44      	itt	mi
 8007592:	232b      	movmi	r3, #43	@ 0x2b
 8007594:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8007598:	f89a 3000 	ldrb.w	r3, [sl]
 800759c:	2b2a      	cmp	r3, #42	@ 0x2a
 800759e:	d015      	beq.n	80075cc <_vfiprintf_r+0x120>
 80075a0:	9a07      	ldr	r2, [sp, #28]
 80075a2:	4654      	mov	r4, sl
 80075a4:	2000      	movs	r0, #0
 80075a6:	f04f 0c0a 	mov.w	ip, #10
 80075aa:	4621      	mov	r1, r4
 80075ac:	f811 3b01 	ldrb.w	r3, [r1], #1
 80075b0:	3b30      	subs	r3, #48	@ 0x30
 80075b2:	2b09      	cmp	r3, #9
 80075b4:	d94b      	bls.n	800764e <_vfiprintf_r+0x1a2>
 80075b6:	b1b0      	cbz	r0, 80075e6 <_vfiprintf_r+0x13a>
 80075b8:	9207      	str	r2, [sp, #28]
 80075ba:	e014      	b.n	80075e6 <_vfiprintf_r+0x13a>
 80075bc:	eba0 0308 	sub.w	r3, r0, r8
 80075c0:	fa09 f303 	lsl.w	r3, r9, r3
 80075c4:	4313      	orrs	r3, r2
 80075c6:	9304      	str	r3, [sp, #16]
 80075c8:	46a2      	mov	sl, r4
 80075ca:	e7d2      	b.n	8007572 <_vfiprintf_r+0xc6>
 80075cc:	9b03      	ldr	r3, [sp, #12]
 80075ce:	1d19      	adds	r1, r3, #4
 80075d0:	681b      	ldr	r3, [r3, #0]
 80075d2:	9103      	str	r1, [sp, #12]
 80075d4:	2b00      	cmp	r3, #0
 80075d6:	bfbb      	ittet	lt
 80075d8:	425b      	neglt	r3, r3
 80075da:	f042 0202 	orrlt.w	r2, r2, #2
 80075de:	9307      	strge	r3, [sp, #28]
 80075e0:	9307      	strlt	r3, [sp, #28]
 80075e2:	bfb8      	it	lt
 80075e4:	9204      	strlt	r2, [sp, #16]
 80075e6:	7823      	ldrb	r3, [r4, #0]
 80075e8:	2b2e      	cmp	r3, #46	@ 0x2e
 80075ea:	d10a      	bne.n	8007602 <_vfiprintf_r+0x156>
 80075ec:	7863      	ldrb	r3, [r4, #1]
 80075ee:	2b2a      	cmp	r3, #42	@ 0x2a
 80075f0:	d132      	bne.n	8007658 <_vfiprintf_r+0x1ac>
 80075f2:	9b03      	ldr	r3, [sp, #12]
 80075f4:	1d1a      	adds	r2, r3, #4
 80075f6:	681b      	ldr	r3, [r3, #0]
 80075f8:	9203      	str	r2, [sp, #12]
 80075fa:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 80075fe:	3402      	adds	r4, #2
 8007600:	9305      	str	r3, [sp, #20]
 8007602:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 80076d8 <_vfiprintf_r+0x22c>
 8007606:	7821      	ldrb	r1, [r4, #0]
 8007608:	2203      	movs	r2, #3
 800760a:	4650      	mov	r0, sl
 800760c:	f7f8 fe68 	bl	80002e0 <memchr>
 8007610:	b138      	cbz	r0, 8007622 <_vfiprintf_r+0x176>
 8007612:	9b04      	ldr	r3, [sp, #16]
 8007614:	eba0 000a 	sub.w	r0, r0, sl
 8007618:	2240      	movs	r2, #64	@ 0x40
 800761a:	4082      	lsls	r2, r0
 800761c:	4313      	orrs	r3, r2
 800761e:	3401      	adds	r4, #1
 8007620:	9304      	str	r3, [sp, #16]
 8007622:	f814 1b01 	ldrb.w	r1, [r4], #1
 8007626:	4829      	ldr	r0, [pc, #164]	@ (80076cc <_vfiprintf_r+0x220>)
 8007628:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 800762c:	2206      	movs	r2, #6
 800762e:	f7f8 fe57 	bl	80002e0 <memchr>
 8007632:	2800      	cmp	r0, #0
 8007634:	d03f      	beq.n	80076b6 <_vfiprintf_r+0x20a>
 8007636:	4b26      	ldr	r3, [pc, #152]	@ (80076d0 <_vfiprintf_r+0x224>)
 8007638:	bb1b      	cbnz	r3, 8007682 <_vfiprintf_r+0x1d6>
 800763a:	9b03      	ldr	r3, [sp, #12]
 800763c:	3307      	adds	r3, #7
 800763e:	f023 0307 	bic.w	r3, r3, #7
 8007642:	3308      	adds	r3, #8
 8007644:	9303      	str	r3, [sp, #12]
 8007646:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8007648:	443b      	add	r3, r7
 800764a:	9309      	str	r3, [sp, #36]	@ 0x24
 800764c:	e76a      	b.n	8007524 <_vfiprintf_r+0x78>
 800764e:	fb0c 3202 	mla	r2, ip, r2, r3
 8007652:	460c      	mov	r4, r1
 8007654:	2001      	movs	r0, #1
 8007656:	e7a8      	b.n	80075aa <_vfiprintf_r+0xfe>
 8007658:	2300      	movs	r3, #0
 800765a:	3401      	adds	r4, #1
 800765c:	9305      	str	r3, [sp, #20]
 800765e:	4619      	mov	r1, r3
 8007660:	f04f 0c0a 	mov.w	ip, #10
 8007664:	4620      	mov	r0, r4
 8007666:	f810 2b01 	ldrb.w	r2, [r0], #1
 800766a:	3a30      	subs	r2, #48	@ 0x30
 800766c:	2a09      	cmp	r2, #9
 800766e:	d903      	bls.n	8007678 <_vfiprintf_r+0x1cc>
 8007670:	2b00      	cmp	r3, #0
 8007672:	d0c6      	beq.n	8007602 <_vfiprintf_r+0x156>
 8007674:	9105      	str	r1, [sp, #20]
 8007676:	e7c4      	b.n	8007602 <_vfiprintf_r+0x156>
 8007678:	fb0c 2101 	mla	r1, ip, r1, r2
 800767c:	4604      	mov	r4, r0
 800767e:	2301      	movs	r3, #1
 8007680:	e7f0      	b.n	8007664 <_vfiprintf_r+0x1b8>
 8007682:	ab03      	add	r3, sp, #12
 8007684:	9300      	str	r3, [sp, #0]
 8007686:	462a      	mov	r2, r5
 8007688:	4b12      	ldr	r3, [pc, #72]	@ (80076d4 <_vfiprintf_r+0x228>)
 800768a:	a904      	add	r1, sp, #16
 800768c:	4630      	mov	r0, r6
 800768e:	f3af 8000 	nop.w
 8007692:	4607      	mov	r7, r0
 8007694:	1c78      	adds	r0, r7, #1
 8007696:	d1d6      	bne.n	8007646 <_vfiprintf_r+0x19a>
 8007698:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 800769a:	07d9      	lsls	r1, r3, #31
 800769c:	d405      	bmi.n	80076aa <_vfiprintf_r+0x1fe>
 800769e:	89ab      	ldrh	r3, [r5, #12]
 80076a0:	059a      	lsls	r2, r3, #22
 80076a2:	d402      	bmi.n	80076aa <_vfiprintf_r+0x1fe>
 80076a4:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 80076a6:	f7ff fe8b 	bl	80073c0 <__retarget_lock_release_recursive>
 80076aa:	89ab      	ldrh	r3, [r5, #12]
 80076ac:	065b      	lsls	r3, r3, #25
 80076ae:	f53f af1f 	bmi.w	80074f0 <_vfiprintf_r+0x44>
 80076b2:	9809      	ldr	r0, [sp, #36]	@ 0x24
 80076b4:	e71e      	b.n	80074f4 <_vfiprintf_r+0x48>
 80076b6:	ab03      	add	r3, sp, #12
 80076b8:	9300      	str	r3, [sp, #0]
 80076ba:	462a      	mov	r2, r5
 80076bc:	4b05      	ldr	r3, [pc, #20]	@ (80076d4 <_vfiprintf_r+0x228>)
 80076be:	a904      	add	r1, sp, #16
 80076c0:	4630      	mov	r0, r6
 80076c2:	f000 f879 	bl	80077b8 <_printf_i>
 80076c6:	e7e4      	b.n	8007692 <_vfiprintf_r+0x1e6>
 80076c8:	08008788 	.word	0x08008788
 80076cc:	08008792 	.word	0x08008792
 80076d0:	00000000 	.word	0x00000000
 80076d4:	08007487 	.word	0x08007487
 80076d8:	0800878e 	.word	0x0800878e

080076dc <_printf_common>:
 80076dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80076e0:	4616      	mov	r6, r2
 80076e2:	4698      	mov	r8, r3
 80076e4:	688a      	ldr	r2, [r1, #8]
 80076e6:	690b      	ldr	r3, [r1, #16]
 80076e8:	f8dd 9020 	ldr.w	r9, [sp, #32]
 80076ec:	4293      	cmp	r3, r2
 80076ee:	bfb8      	it	lt
 80076f0:	4613      	movlt	r3, r2
 80076f2:	6033      	str	r3, [r6, #0]
 80076f4:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 80076f8:	4607      	mov	r7, r0
 80076fa:	460c      	mov	r4, r1
 80076fc:	b10a      	cbz	r2, 8007702 <_printf_common+0x26>
 80076fe:	3301      	adds	r3, #1
 8007700:	6033      	str	r3, [r6, #0]
 8007702:	6823      	ldr	r3, [r4, #0]
 8007704:	0699      	lsls	r1, r3, #26
 8007706:	bf42      	ittt	mi
 8007708:	6833      	ldrmi	r3, [r6, #0]
 800770a:	3302      	addmi	r3, #2
 800770c:	6033      	strmi	r3, [r6, #0]
 800770e:	6825      	ldr	r5, [r4, #0]
 8007710:	f015 0506 	ands.w	r5, r5, #6
 8007714:	d106      	bne.n	8007724 <_printf_common+0x48>
 8007716:	f104 0a19 	add.w	sl, r4, #25
 800771a:	68e3      	ldr	r3, [r4, #12]
 800771c:	6832      	ldr	r2, [r6, #0]
 800771e:	1a9b      	subs	r3, r3, r2
 8007720:	42ab      	cmp	r3, r5
 8007722:	dc26      	bgt.n	8007772 <_printf_common+0x96>
 8007724:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 8007728:	6822      	ldr	r2, [r4, #0]
 800772a:	3b00      	subs	r3, #0
 800772c:	bf18      	it	ne
 800772e:	2301      	movne	r3, #1
 8007730:	0692      	lsls	r2, r2, #26
 8007732:	d42b      	bmi.n	800778c <_printf_common+0xb0>
 8007734:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 8007738:	4641      	mov	r1, r8
 800773a:	4638      	mov	r0, r7
 800773c:	47c8      	blx	r9
 800773e:	3001      	adds	r0, #1
 8007740:	d01e      	beq.n	8007780 <_printf_common+0xa4>
 8007742:	6823      	ldr	r3, [r4, #0]
 8007744:	6922      	ldr	r2, [r4, #16]
 8007746:	f003 0306 	and.w	r3, r3, #6
 800774a:	2b04      	cmp	r3, #4
 800774c:	bf02      	ittt	eq
 800774e:	68e5      	ldreq	r5, [r4, #12]
 8007750:	6833      	ldreq	r3, [r6, #0]
 8007752:	1aed      	subeq	r5, r5, r3
 8007754:	68a3      	ldr	r3, [r4, #8]
 8007756:	bf0c      	ite	eq
 8007758:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 800775c:	2500      	movne	r5, #0
 800775e:	4293      	cmp	r3, r2
 8007760:	bfc4      	itt	gt
 8007762:	1a9b      	subgt	r3, r3, r2
 8007764:	18ed      	addgt	r5, r5, r3
 8007766:	2600      	movs	r6, #0
 8007768:	341a      	adds	r4, #26
 800776a:	42b5      	cmp	r5, r6
 800776c:	d11a      	bne.n	80077a4 <_printf_common+0xc8>
 800776e:	2000      	movs	r0, #0
 8007770:	e008      	b.n	8007784 <_printf_common+0xa8>
 8007772:	2301      	movs	r3, #1
 8007774:	4652      	mov	r2, sl
 8007776:	4641      	mov	r1, r8
 8007778:	4638      	mov	r0, r7
 800777a:	47c8      	blx	r9
 800777c:	3001      	adds	r0, #1
 800777e:	d103      	bne.n	8007788 <_printf_common+0xac>
 8007780:	f04f 30ff 	mov.w	r0, #4294967295
 8007784:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007788:	3501      	adds	r5, #1
 800778a:	e7c6      	b.n	800771a <_printf_common+0x3e>
 800778c:	18e1      	adds	r1, r4, r3
 800778e:	1c5a      	adds	r2, r3, #1
 8007790:	2030      	movs	r0, #48	@ 0x30
 8007792:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 8007796:	4422      	add	r2, r4
 8007798:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 800779c:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 80077a0:	3302      	adds	r3, #2
 80077a2:	e7c7      	b.n	8007734 <_printf_common+0x58>
 80077a4:	2301      	movs	r3, #1
 80077a6:	4622      	mov	r2, r4
 80077a8:	4641      	mov	r1, r8
 80077aa:	4638      	mov	r0, r7
 80077ac:	47c8      	blx	r9
 80077ae:	3001      	adds	r0, #1
 80077b0:	d0e6      	beq.n	8007780 <_printf_common+0xa4>
 80077b2:	3601      	adds	r6, #1
 80077b4:	e7d9      	b.n	800776a <_printf_common+0x8e>
	...

080077b8 <_printf_i>:
 80077b8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80077bc:	7e0f      	ldrb	r7, [r1, #24]
 80077be:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 80077c0:	2f78      	cmp	r7, #120	@ 0x78
 80077c2:	4691      	mov	r9, r2
 80077c4:	4680      	mov	r8, r0
 80077c6:	460c      	mov	r4, r1
 80077c8:	469a      	mov	sl, r3
 80077ca:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 80077ce:	d807      	bhi.n	80077e0 <_printf_i+0x28>
 80077d0:	2f62      	cmp	r7, #98	@ 0x62
 80077d2:	d80a      	bhi.n	80077ea <_printf_i+0x32>
 80077d4:	2f00      	cmp	r7, #0
 80077d6:	f000 80d1 	beq.w	800797c <_printf_i+0x1c4>
 80077da:	2f58      	cmp	r7, #88	@ 0x58
 80077dc:	f000 80b8 	beq.w	8007950 <_printf_i+0x198>
 80077e0:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 80077e4:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 80077e8:	e03a      	b.n	8007860 <_printf_i+0xa8>
 80077ea:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 80077ee:	2b15      	cmp	r3, #21
 80077f0:	d8f6      	bhi.n	80077e0 <_printf_i+0x28>
 80077f2:	a101      	add	r1, pc, #4	@ (adr r1, 80077f8 <_printf_i+0x40>)
 80077f4:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 80077f8:	08007851 	.word	0x08007851
 80077fc:	08007865 	.word	0x08007865
 8007800:	080077e1 	.word	0x080077e1
 8007804:	080077e1 	.word	0x080077e1
 8007808:	080077e1 	.word	0x080077e1
 800780c:	080077e1 	.word	0x080077e1
 8007810:	08007865 	.word	0x08007865
 8007814:	080077e1 	.word	0x080077e1
 8007818:	080077e1 	.word	0x080077e1
 800781c:	080077e1 	.word	0x080077e1
 8007820:	080077e1 	.word	0x080077e1
 8007824:	08007963 	.word	0x08007963
 8007828:	0800788f 	.word	0x0800788f
 800782c:	0800791d 	.word	0x0800791d
 8007830:	080077e1 	.word	0x080077e1
 8007834:	080077e1 	.word	0x080077e1
 8007838:	08007985 	.word	0x08007985
 800783c:	080077e1 	.word	0x080077e1
 8007840:	0800788f 	.word	0x0800788f
 8007844:	080077e1 	.word	0x080077e1
 8007848:	080077e1 	.word	0x080077e1
 800784c:	08007925 	.word	0x08007925
 8007850:	6833      	ldr	r3, [r6, #0]
 8007852:	1d1a      	adds	r2, r3, #4
 8007854:	681b      	ldr	r3, [r3, #0]
 8007856:	6032      	str	r2, [r6, #0]
 8007858:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 800785c:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8007860:	2301      	movs	r3, #1
 8007862:	e09c      	b.n	800799e <_printf_i+0x1e6>
 8007864:	6833      	ldr	r3, [r6, #0]
 8007866:	6820      	ldr	r0, [r4, #0]
 8007868:	1d19      	adds	r1, r3, #4
 800786a:	6031      	str	r1, [r6, #0]
 800786c:	0606      	lsls	r6, r0, #24
 800786e:	d501      	bpl.n	8007874 <_printf_i+0xbc>
 8007870:	681d      	ldr	r5, [r3, #0]
 8007872:	e003      	b.n	800787c <_printf_i+0xc4>
 8007874:	0645      	lsls	r5, r0, #25
 8007876:	d5fb      	bpl.n	8007870 <_printf_i+0xb8>
 8007878:	f9b3 5000 	ldrsh.w	r5, [r3]
 800787c:	2d00      	cmp	r5, #0
 800787e:	da03      	bge.n	8007888 <_printf_i+0xd0>
 8007880:	232d      	movs	r3, #45	@ 0x2d
 8007882:	426d      	negs	r5, r5
 8007884:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8007888:	4858      	ldr	r0, [pc, #352]	@ (80079ec <_printf_i+0x234>)
 800788a:	230a      	movs	r3, #10
 800788c:	e011      	b.n	80078b2 <_printf_i+0xfa>
 800788e:	6821      	ldr	r1, [r4, #0]
 8007890:	6833      	ldr	r3, [r6, #0]
 8007892:	0608      	lsls	r0, r1, #24
 8007894:	f853 5b04 	ldr.w	r5, [r3], #4
 8007898:	d402      	bmi.n	80078a0 <_printf_i+0xe8>
 800789a:	0649      	lsls	r1, r1, #25
 800789c:	bf48      	it	mi
 800789e:	b2ad      	uxthmi	r5, r5
 80078a0:	2f6f      	cmp	r7, #111	@ 0x6f
 80078a2:	4852      	ldr	r0, [pc, #328]	@ (80079ec <_printf_i+0x234>)
 80078a4:	6033      	str	r3, [r6, #0]
 80078a6:	bf14      	ite	ne
 80078a8:	230a      	movne	r3, #10
 80078aa:	2308      	moveq	r3, #8
 80078ac:	2100      	movs	r1, #0
 80078ae:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 80078b2:	6866      	ldr	r6, [r4, #4]
 80078b4:	60a6      	str	r6, [r4, #8]
 80078b6:	2e00      	cmp	r6, #0
 80078b8:	db05      	blt.n	80078c6 <_printf_i+0x10e>
 80078ba:	6821      	ldr	r1, [r4, #0]
 80078bc:	432e      	orrs	r6, r5
 80078be:	f021 0104 	bic.w	r1, r1, #4
 80078c2:	6021      	str	r1, [r4, #0]
 80078c4:	d04b      	beq.n	800795e <_printf_i+0x1a6>
 80078c6:	4616      	mov	r6, r2
 80078c8:	fbb5 f1f3 	udiv	r1, r5, r3
 80078cc:	fb03 5711 	mls	r7, r3, r1, r5
 80078d0:	5dc7      	ldrb	r7, [r0, r7]
 80078d2:	f806 7d01 	strb.w	r7, [r6, #-1]!
 80078d6:	462f      	mov	r7, r5
 80078d8:	42bb      	cmp	r3, r7
 80078da:	460d      	mov	r5, r1
 80078dc:	d9f4      	bls.n	80078c8 <_printf_i+0x110>
 80078de:	2b08      	cmp	r3, #8
 80078e0:	d10b      	bne.n	80078fa <_printf_i+0x142>
 80078e2:	6823      	ldr	r3, [r4, #0]
 80078e4:	07df      	lsls	r7, r3, #31
 80078e6:	d508      	bpl.n	80078fa <_printf_i+0x142>
 80078e8:	6923      	ldr	r3, [r4, #16]
 80078ea:	6861      	ldr	r1, [r4, #4]
 80078ec:	4299      	cmp	r1, r3
 80078ee:	bfde      	ittt	le
 80078f0:	2330      	movle	r3, #48	@ 0x30
 80078f2:	f806 3c01 	strble.w	r3, [r6, #-1]
 80078f6:	f106 36ff 	addle.w	r6, r6, #4294967295
 80078fa:	1b92      	subs	r2, r2, r6
 80078fc:	6122      	str	r2, [r4, #16]
 80078fe:	f8cd a000 	str.w	sl, [sp]
 8007902:	464b      	mov	r3, r9
 8007904:	aa03      	add	r2, sp, #12
 8007906:	4621      	mov	r1, r4
 8007908:	4640      	mov	r0, r8
 800790a:	f7ff fee7 	bl	80076dc <_printf_common>
 800790e:	3001      	adds	r0, #1
 8007910:	d14a      	bne.n	80079a8 <_printf_i+0x1f0>
 8007912:	f04f 30ff 	mov.w	r0, #4294967295
 8007916:	b004      	add	sp, #16
 8007918:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800791c:	6823      	ldr	r3, [r4, #0]
 800791e:	f043 0320 	orr.w	r3, r3, #32
 8007922:	6023      	str	r3, [r4, #0]
 8007924:	4832      	ldr	r0, [pc, #200]	@ (80079f0 <_printf_i+0x238>)
 8007926:	2778      	movs	r7, #120	@ 0x78
 8007928:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 800792c:	6823      	ldr	r3, [r4, #0]
 800792e:	6831      	ldr	r1, [r6, #0]
 8007930:	061f      	lsls	r7, r3, #24
 8007932:	f851 5b04 	ldr.w	r5, [r1], #4
 8007936:	d402      	bmi.n	800793e <_printf_i+0x186>
 8007938:	065f      	lsls	r7, r3, #25
 800793a:	bf48      	it	mi
 800793c:	b2ad      	uxthmi	r5, r5
 800793e:	6031      	str	r1, [r6, #0]
 8007940:	07d9      	lsls	r1, r3, #31
 8007942:	bf44      	itt	mi
 8007944:	f043 0320 	orrmi.w	r3, r3, #32
 8007948:	6023      	strmi	r3, [r4, #0]
 800794a:	b11d      	cbz	r5, 8007954 <_printf_i+0x19c>
 800794c:	2310      	movs	r3, #16
 800794e:	e7ad      	b.n	80078ac <_printf_i+0xf4>
 8007950:	4826      	ldr	r0, [pc, #152]	@ (80079ec <_printf_i+0x234>)
 8007952:	e7e9      	b.n	8007928 <_printf_i+0x170>
 8007954:	6823      	ldr	r3, [r4, #0]
 8007956:	f023 0320 	bic.w	r3, r3, #32
 800795a:	6023      	str	r3, [r4, #0]
 800795c:	e7f6      	b.n	800794c <_printf_i+0x194>
 800795e:	4616      	mov	r6, r2
 8007960:	e7bd      	b.n	80078de <_printf_i+0x126>
 8007962:	6833      	ldr	r3, [r6, #0]
 8007964:	6825      	ldr	r5, [r4, #0]
 8007966:	6961      	ldr	r1, [r4, #20]
 8007968:	1d18      	adds	r0, r3, #4
 800796a:	6030      	str	r0, [r6, #0]
 800796c:	062e      	lsls	r6, r5, #24
 800796e:	681b      	ldr	r3, [r3, #0]
 8007970:	d501      	bpl.n	8007976 <_printf_i+0x1be>
 8007972:	6019      	str	r1, [r3, #0]
 8007974:	e002      	b.n	800797c <_printf_i+0x1c4>
 8007976:	0668      	lsls	r0, r5, #25
 8007978:	d5fb      	bpl.n	8007972 <_printf_i+0x1ba>
 800797a:	8019      	strh	r1, [r3, #0]
 800797c:	2300      	movs	r3, #0
 800797e:	6123      	str	r3, [r4, #16]
 8007980:	4616      	mov	r6, r2
 8007982:	e7bc      	b.n	80078fe <_printf_i+0x146>
 8007984:	6833      	ldr	r3, [r6, #0]
 8007986:	1d1a      	adds	r2, r3, #4
 8007988:	6032      	str	r2, [r6, #0]
 800798a:	681e      	ldr	r6, [r3, #0]
 800798c:	6862      	ldr	r2, [r4, #4]
 800798e:	2100      	movs	r1, #0
 8007990:	4630      	mov	r0, r6
 8007992:	f7f8 fca5 	bl	80002e0 <memchr>
 8007996:	b108      	cbz	r0, 800799c <_printf_i+0x1e4>
 8007998:	1b80      	subs	r0, r0, r6
 800799a:	6060      	str	r0, [r4, #4]
 800799c:	6863      	ldr	r3, [r4, #4]
 800799e:	6123      	str	r3, [r4, #16]
 80079a0:	2300      	movs	r3, #0
 80079a2:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 80079a6:	e7aa      	b.n	80078fe <_printf_i+0x146>
 80079a8:	6923      	ldr	r3, [r4, #16]
 80079aa:	4632      	mov	r2, r6
 80079ac:	4649      	mov	r1, r9
 80079ae:	4640      	mov	r0, r8
 80079b0:	47d0      	blx	sl
 80079b2:	3001      	adds	r0, #1
 80079b4:	d0ad      	beq.n	8007912 <_printf_i+0x15a>
 80079b6:	6823      	ldr	r3, [r4, #0]
 80079b8:	079b      	lsls	r3, r3, #30
 80079ba:	d413      	bmi.n	80079e4 <_printf_i+0x22c>
 80079bc:	68e0      	ldr	r0, [r4, #12]
 80079be:	9b03      	ldr	r3, [sp, #12]
 80079c0:	4298      	cmp	r0, r3
 80079c2:	bfb8      	it	lt
 80079c4:	4618      	movlt	r0, r3
 80079c6:	e7a6      	b.n	8007916 <_printf_i+0x15e>
 80079c8:	2301      	movs	r3, #1
 80079ca:	4632      	mov	r2, r6
 80079cc:	4649      	mov	r1, r9
 80079ce:	4640      	mov	r0, r8
 80079d0:	47d0      	blx	sl
 80079d2:	3001      	adds	r0, #1
 80079d4:	d09d      	beq.n	8007912 <_printf_i+0x15a>
 80079d6:	3501      	adds	r5, #1
 80079d8:	68e3      	ldr	r3, [r4, #12]
 80079da:	9903      	ldr	r1, [sp, #12]
 80079dc:	1a5b      	subs	r3, r3, r1
 80079de:	42ab      	cmp	r3, r5
 80079e0:	dcf2      	bgt.n	80079c8 <_printf_i+0x210>
 80079e2:	e7eb      	b.n	80079bc <_printf_i+0x204>
 80079e4:	2500      	movs	r5, #0
 80079e6:	f104 0619 	add.w	r6, r4, #25
 80079ea:	e7f5      	b.n	80079d8 <_printf_i+0x220>
 80079ec:	08008799 	.word	0x08008799
 80079f0:	080087aa 	.word	0x080087aa

080079f4 <__sflush_r>:
 80079f4:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 80079f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80079fc:	0716      	lsls	r6, r2, #28
 80079fe:	4605      	mov	r5, r0
 8007a00:	460c      	mov	r4, r1
 8007a02:	d454      	bmi.n	8007aae <__sflush_r+0xba>
 8007a04:	684b      	ldr	r3, [r1, #4]
 8007a06:	2b00      	cmp	r3, #0
 8007a08:	dc02      	bgt.n	8007a10 <__sflush_r+0x1c>
 8007a0a:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 8007a0c:	2b00      	cmp	r3, #0
 8007a0e:	dd48      	ble.n	8007aa2 <__sflush_r+0xae>
 8007a10:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 8007a12:	2e00      	cmp	r6, #0
 8007a14:	d045      	beq.n	8007aa2 <__sflush_r+0xae>
 8007a16:	2300      	movs	r3, #0
 8007a18:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 8007a1c:	682f      	ldr	r7, [r5, #0]
 8007a1e:	6a21      	ldr	r1, [r4, #32]
 8007a20:	602b      	str	r3, [r5, #0]
 8007a22:	d030      	beq.n	8007a86 <__sflush_r+0x92>
 8007a24:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 8007a26:	89a3      	ldrh	r3, [r4, #12]
 8007a28:	0759      	lsls	r1, r3, #29
 8007a2a:	d505      	bpl.n	8007a38 <__sflush_r+0x44>
 8007a2c:	6863      	ldr	r3, [r4, #4]
 8007a2e:	1ad2      	subs	r2, r2, r3
 8007a30:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8007a32:	b10b      	cbz	r3, 8007a38 <__sflush_r+0x44>
 8007a34:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8007a36:	1ad2      	subs	r2, r2, r3
 8007a38:	2300      	movs	r3, #0
 8007a3a:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 8007a3c:	6a21      	ldr	r1, [r4, #32]
 8007a3e:	4628      	mov	r0, r5
 8007a40:	47b0      	blx	r6
 8007a42:	1c43      	adds	r3, r0, #1
 8007a44:	89a3      	ldrh	r3, [r4, #12]
 8007a46:	d106      	bne.n	8007a56 <__sflush_r+0x62>
 8007a48:	6829      	ldr	r1, [r5, #0]
 8007a4a:	291d      	cmp	r1, #29
 8007a4c:	d82b      	bhi.n	8007aa6 <__sflush_r+0xb2>
 8007a4e:	4a2a      	ldr	r2, [pc, #168]	@ (8007af8 <__sflush_r+0x104>)
 8007a50:	40ca      	lsrs	r2, r1
 8007a52:	07d6      	lsls	r6, r2, #31
 8007a54:	d527      	bpl.n	8007aa6 <__sflush_r+0xb2>
 8007a56:	2200      	movs	r2, #0
 8007a58:	6062      	str	r2, [r4, #4]
 8007a5a:	04d9      	lsls	r1, r3, #19
 8007a5c:	6922      	ldr	r2, [r4, #16]
 8007a5e:	6022      	str	r2, [r4, #0]
 8007a60:	d504      	bpl.n	8007a6c <__sflush_r+0x78>
 8007a62:	1c42      	adds	r2, r0, #1
 8007a64:	d101      	bne.n	8007a6a <__sflush_r+0x76>
 8007a66:	682b      	ldr	r3, [r5, #0]
 8007a68:	b903      	cbnz	r3, 8007a6c <__sflush_r+0x78>
 8007a6a:	6560      	str	r0, [r4, #84]	@ 0x54
 8007a6c:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8007a6e:	602f      	str	r7, [r5, #0]
 8007a70:	b1b9      	cbz	r1, 8007aa2 <__sflush_r+0xae>
 8007a72:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8007a76:	4299      	cmp	r1, r3
 8007a78:	d002      	beq.n	8007a80 <__sflush_r+0x8c>
 8007a7a:	4628      	mov	r0, r5
 8007a7c:	f7ff fca2 	bl	80073c4 <_free_r>
 8007a80:	2300      	movs	r3, #0
 8007a82:	6363      	str	r3, [r4, #52]	@ 0x34
 8007a84:	e00d      	b.n	8007aa2 <__sflush_r+0xae>
 8007a86:	2301      	movs	r3, #1
 8007a88:	4628      	mov	r0, r5
 8007a8a:	47b0      	blx	r6
 8007a8c:	4602      	mov	r2, r0
 8007a8e:	1c50      	adds	r0, r2, #1
 8007a90:	d1c9      	bne.n	8007a26 <__sflush_r+0x32>
 8007a92:	682b      	ldr	r3, [r5, #0]
 8007a94:	2b00      	cmp	r3, #0
 8007a96:	d0c6      	beq.n	8007a26 <__sflush_r+0x32>
 8007a98:	2b1d      	cmp	r3, #29
 8007a9a:	d001      	beq.n	8007aa0 <__sflush_r+0xac>
 8007a9c:	2b16      	cmp	r3, #22
 8007a9e:	d11e      	bne.n	8007ade <__sflush_r+0xea>
 8007aa0:	602f      	str	r7, [r5, #0]
 8007aa2:	2000      	movs	r0, #0
 8007aa4:	e022      	b.n	8007aec <__sflush_r+0xf8>
 8007aa6:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8007aaa:	b21b      	sxth	r3, r3
 8007aac:	e01b      	b.n	8007ae6 <__sflush_r+0xf2>
 8007aae:	690f      	ldr	r7, [r1, #16]
 8007ab0:	2f00      	cmp	r7, #0
 8007ab2:	d0f6      	beq.n	8007aa2 <__sflush_r+0xae>
 8007ab4:	0793      	lsls	r3, r2, #30
 8007ab6:	680e      	ldr	r6, [r1, #0]
 8007ab8:	bf08      	it	eq
 8007aba:	694b      	ldreq	r3, [r1, #20]
 8007abc:	600f      	str	r7, [r1, #0]
 8007abe:	bf18      	it	ne
 8007ac0:	2300      	movne	r3, #0
 8007ac2:	eba6 0807 	sub.w	r8, r6, r7
 8007ac6:	608b      	str	r3, [r1, #8]
 8007ac8:	f1b8 0f00 	cmp.w	r8, #0
 8007acc:	dde9      	ble.n	8007aa2 <__sflush_r+0xae>
 8007ace:	6a21      	ldr	r1, [r4, #32]
 8007ad0:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 8007ad2:	4643      	mov	r3, r8
 8007ad4:	463a      	mov	r2, r7
 8007ad6:	4628      	mov	r0, r5
 8007ad8:	47b0      	blx	r6
 8007ada:	2800      	cmp	r0, #0
 8007adc:	dc08      	bgt.n	8007af0 <__sflush_r+0xfc>
 8007ade:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8007ae2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8007ae6:	81a3      	strh	r3, [r4, #12]
 8007ae8:	f04f 30ff 	mov.w	r0, #4294967295
 8007aec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8007af0:	4407      	add	r7, r0
 8007af2:	eba8 0800 	sub.w	r8, r8, r0
 8007af6:	e7e7      	b.n	8007ac8 <__sflush_r+0xd4>
 8007af8:	20400001 	.word	0x20400001

08007afc <_fflush_r>:
 8007afc:	b538      	push	{r3, r4, r5, lr}
 8007afe:	690b      	ldr	r3, [r1, #16]
 8007b00:	4605      	mov	r5, r0
 8007b02:	460c      	mov	r4, r1
 8007b04:	b913      	cbnz	r3, 8007b0c <_fflush_r+0x10>
 8007b06:	2500      	movs	r5, #0
 8007b08:	4628      	mov	r0, r5
 8007b0a:	bd38      	pop	{r3, r4, r5, pc}
 8007b0c:	b118      	cbz	r0, 8007b16 <_fflush_r+0x1a>
 8007b0e:	6a03      	ldr	r3, [r0, #32]
 8007b10:	b90b      	cbnz	r3, 8007b16 <_fflush_r+0x1a>
 8007b12:	f7ff fb37 	bl	8007184 <__sinit>
 8007b16:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8007b1a:	2b00      	cmp	r3, #0
 8007b1c:	d0f3      	beq.n	8007b06 <_fflush_r+0xa>
 8007b1e:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 8007b20:	07d0      	lsls	r0, r2, #31
 8007b22:	d404      	bmi.n	8007b2e <_fflush_r+0x32>
 8007b24:	0599      	lsls	r1, r3, #22
 8007b26:	d402      	bmi.n	8007b2e <_fflush_r+0x32>
 8007b28:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8007b2a:	f7ff fc48 	bl	80073be <__retarget_lock_acquire_recursive>
 8007b2e:	4628      	mov	r0, r5
 8007b30:	4621      	mov	r1, r4
 8007b32:	f7ff ff5f 	bl	80079f4 <__sflush_r>
 8007b36:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8007b38:	07da      	lsls	r2, r3, #31
 8007b3a:	4605      	mov	r5, r0
 8007b3c:	d4e4      	bmi.n	8007b08 <_fflush_r+0xc>
 8007b3e:	89a3      	ldrh	r3, [r4, #12]
 8007b40:	059b      	lsls	r3, r3, #22
 8007b42:	d4e1      	bmi.n	8007b08 <_fflush_r+0xc>
 8007b44:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8007b46:	f7ff fc3b 	bl	80073c0 <__retarget_lock_release_recursive>
 8007b4a:	e7dd      	b.n	8007b08 <_fflush_r+0xc>

08007b4c <_putc_r>:
 8007b4c:	b570      	push	{r4, r5, r6, lr}
 8007b4e:	460d      	mov	r5, r1
 8007b50:	4614      	mov	r4, r2
 8007b52:	4606      	mov	r6, r0
 8007b54:	b118      	cbz	r0, 8007b5e <_putc_r+0x12>
 8007b56:	6a03      	ldr	r3, [r0, #32]
 8007b58:	b90b      	cbnz	r3, 8007b5e <_putc_r+0x12>
 8007b5a:	f7ff fb13 	bl	8007184 <__sinit>
 8007b5e:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8007b60:	07d8      	lsls	r0, r3, #31
 8007b62:	d405      	bmi.n	8007b70 <_putc_r+0x24>
 8007b64:	89a3      	ldrh	r3, [r4, #12]
 8007b66:	0599      	lsls	r1, r3, #22
 8007b68:	d402      	bmi.n	8007b70 <_putc_r+0x24>
 8007b6a:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8007b6c:	f7ff fc27 	bl	80073be <__retarget_lock_acquire_recursive>
 8007b70:	68a3      	ldr	r3, [r4, #8]
 8007b72:	3b01      	subs	r3, #1
 8007b74:	2b00      	cmp	r3, #0
 8007b76:	60a3      	str	r3, [r4, #8]
 8007b78:	da05      	bge.n	8007b86 <_putc_r+0x3a>
 8007b7a:	69a2      	ldr	r2, [r4, #24]
 8007b7c:	4293      	cmp	r3, r2
 8007b7e:	db12      	blt.n	8007ba6 <_putc_r+0x5a>
 8007b80:	b2eb      	uxtb	r3, r5
 8007b82:	2b0a      	cmp	r3, #10
 8007b84:	d00f      	beq.n	8007ba6 <_putc_r+0x5a>
 8007b86:	6823      	ldr	r3, [r4, #0]
 8007b88:	1c5a      	adds	r2, r3, #1
 8007b8a:	6022      	str	r2, [r4, #0]
 8007b8c:	701d      	strb	r5, [r3, #0]
 8007b8e:	b2ed      	uxtb	r5, r5
 8007b90:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8007b92:	07da      	lsls	r2, r3, #31
 8007b94:	d405      	bmi.n	8007ba2 <_putc_r+0x56>
 8007b96:	89a3      	ldrh	r3, [r4, #12]
 8007b98:	059b      	lsls	r3, r3, #22
 8007b9a:	d402      	bmi.n	8007ba2 <_putc_r+0x56>
 8007b9c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8007b9e:	f7ff fc0f 	bl	80073c0 <__retarget_lock_release_recursive>
 8007ba2:	4628      	mov	r0, r5
 8007ba4:	bd70      	pop	{r4, r5, r6, pc}
 8007ba6:	4629      	mov	r1, r5
 8007ba8:	4622      	mov	r2, r4
 8007baa:	4630      	mov	r0, r6
 8007bac:	f000 f802 	bl	8007bb4 <__swbuf_r>
 8007bb0:	4605      	mov	r5, r0
 8007bb2:	e7ed      	b.n	8007b90 <_putc_r+0x44>

08007bb4 <__swbuf_r>:
 8007bb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007bb6:	460e      	mov	r6, r1
 8007bb8:	4614      	mov	r4, r2
 8007bba:	4605      	mov	r5, r0
 8007bbc:	b118      	cbz	r0, 8007bc6 <__swbuf_r+0x12>
 8007bbe:	6a03      	ldr	r3, [r0, #32]
 8007bc0:	b90b      	cbnz	r3, 8007bc6 <__swbuf_r+0x12>
 8007bc2:	f7ff fadf 	bl	8007184 <__sinit>
 8007bc6:	69a3      	ldr	r3, [r4, #24]
 8007bc8:	60a3      	str	r3, [r4, #8]
 8007bca:	89a3      	ldrh	r3, [r4, #12]
 8007bcc:	071a      	lsls	r2, r3, #28
 8007bce:	d501      	bpl.n	8007bd4 <__swbuf_r+0x20>
 8007bd0:	6923      	ldr	r3, [r4, #16]
 8007bd2:	b943      	cbnz	r3, 8007be6 <__swbuf_r+0x32>
 8007bd4:	4621      	mov	r1, r4
 8007bd6:	4628      	mov	r0, r5
 8007bd8:	f000 f82a 	bl	8007c30 <__swsetup_r>
 8007bdc:	b118      	cbz	r0, 8007be6 <__swbuf_r+0x32>
 8007bde:	f04f 37ff 	mov.w	r7, #4294967295
 8007be2:	4638      	mov	r0, r7
 8007be4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007be6:	6823      	ldr	r3, [r4, #0]
 8007be8:	6922      	ldr	r2, [r4, #16]
 8007bea:	1a98      	subs	r0, r3, r2
 8007bec:	6963      	ldr	r3, [r4, #20]
 8007bee:	b2f6      	uxtb	r6, r6
 8007bf0:	4283      	cmp	r3, r0
 8007bf2:	4637      	mov	r7, r6
 8007bf4:	dc05      	bgt.n	8007c02 <__swbuf_r+0x4e>
 8007bf6:	4621      	mov	r1, r4
 8007bf8:	4628      	mov	r0, r5
 8007bfa:	f7ff ff7f 	bl	8007afc <_fflush_r>
 8007bfe:	2800      	cmp	r0, #0
 8007c00:	d1ed      	bne.n	8007bde <__swbuf_r+0x2a>
 8007c02:	68a3      	ldr	r3, [r4, #8]
 8007c04:	3b01      	subs	r3, #1
 8007c06:	60a3      	str	r3, [r4, #8]
 8007c08:	6823      	ldr	r3, [r4, #0]
 8007c0a:	1c5a      	adds	r2, r3, #1
 8007c0c:	6022      	str	r2, [r4, #0]
 8007c0e:	701e      	strb	r6, [r3, #0]
 8007c10:	6962      	ldr	r2, [r4, #20]
 8007c12:	1c43      	adds	r3, r0, #1
 8007c14:	429a      	cmp	r2, r3
 8007c16:	d004      	beq.n	8007c22 <__swbuf_r+0x6e>
 8007c18:	89a3      	ldrh	r3, [r4, #12]
 8007c1a:	07db      	lsls	r3, r3, #31
 8007c1c:	d5e1      	bpl.n	8007be2 <__swbuf_r+0x2e>
 8007c1e:	2e0a      	cmp	r6, #10
 8007c20:	d1df      	bne.n	8007be2 <__swbuf_r+0x2e>
 8007c22:	4621      	mov	r1, r4
 8007c24:	4628      	mov	r0, r5
 8007c26:	f7ff ff69 	bl	8007afc <_fflush_r>
 8007c2a:	2800      	cmp	r0, #0
 8007c2c:	d0d9      	beq.n	8007be2 <__swbuf_r+0x2e>
 8007c2e:	e7d6      	b.n	8007bde <__swbuf_r+0x2a>

08007c30 <__swsetup_r>:
 8007c30:	b538      	push	{r3, r4, r5, lr}
 8007c32:	4b29      	ldr	r3, [pc, #164]	@ (8007cd8 <__swsetup_r+0xa8>)
 8007c34:	4605      	mov	r5, r0
 8007c36:	6818      	ldr	r0, [r3, #0]
 8007c38:	460c      	mov	r4, r1
 8007c3a:	b118      	cbz	r0, 8007c44 <__swsetup_r+0x14>
 8007c3c:	6a03      	ldr	r3, [r0, #32]
 8007c3e:	b90b      	cbnz	r3, 8007c44 <__swsetup_r+0x14>
 8007c40:	f7ff faa0 	bl	8007184 <__sinit>
 8007c44:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8007c48:	0719      	lsls	r1, r3, #28
 8007c4a:	d422      	bmi.n	8007c92 <__swsetup_r+0x62>
 8007c4c:	06da      	lsls	r2, r3, #27
 8007c4e:	d407      	bmi.n	8007c60 <__swsetup_r+0x30>
 8007c50:	2209      	movs	r2, #9
 8007c52:	602a      	str	r2, [r5, #0]
 8007c54:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8007c58:	81a3      	strh	r3, [r4, #12]
 8007c5a:	f04f 30ff 	mov.w	r0, #4294967295
 8007c5e:	e033      	b.n	8007cc8 <__swsetup_r+0x98>
 8007c60:	0758      	lsls	r0, r3, #29
 8007c62:	d512      	bpl.n	8007c8a <__swsetup_r+0x5a>
 8007c64:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8007c66:	b141      	cbz	r1, 8007c7a <__swsetup_r+0x4a>
 8007c68:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8007c6c:	4299      	cmp	r1, r3
 8007c6e:	d002      	beq.n	8007c76 <__swsetup_r+0x46>
 8007c70:	4628      	mov	r0, r5
 8007c72:	f7ff fba7 	bl	80073c4 <_free_r>
 8007c76:	2300      	movs	r3, #0
 8007c78:	6363      	str	r3, [r4, #52]	@ 0x34
 8007c7a:	89a3      	ldrh	r3, [r4, #12]
 8007c7c:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 8007c80:	81a3      	strh	r3, [r4, #12]
 8007c82:	2300      	movs	r3, #0
 8007c84:	6063      	str	r3, [r4, #4]
 8007c86:	6923      	ldr	r3, [r4, #16]
 8007c88:	6023      	str	r3, [r4, #0]
 8007c8a:	89a3      	ldrh	r3, [r4, #12]
 8007c8c:	f043 0308 	orr.w	r3, r3, #8
 8007c90:	81a3      	strh	r3, [r4, #12]
 8007c92:	6923      	ldr	r3, [r4, #16]
 8007c94:	b94b      	cbnz	r3, 8007caa <__swsetup_r+0x7a>
 8007c96:	89a3      	ldrh	r3, [r4, #12]
 8007c98:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 8007c9c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8007ca0:	d003      	beq.n	8007caa <__swsetup_r+0x7a>
 8007ca2:	4621      	mov	r1, r4
 8007ca4:	4628      	mov	r0, r5
 8007ca6:	f000 f83f 	bl	8007d28 <__smakebuf_r>
 8007caa:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8007cae:	f013 0201 	ands.w	r2, r3, #1
 8007cb2:	d00a      	beq.n	8007cca <__swsetup_r+0x9a>
 8007cb4:	2200      	movs	r2, #0
 8007cb6:	60a2      	str	r2, [r4, #8]
 8007cb8:	6962      	ldr	r2, [r4, #20]
 8007cba:	4252      	negs	r2, r2
 8007cbc:	61a2      	str	r2, [r4, #24]
 8007cbe:	6922      	ldr	r2, [r4, #16]
 8007cc0:	b942      	cbnz	r2, 8007cd4 <__swsetup_r+0xa4>
 8007cc2:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 8007cc6:	d1c5      	bne.n	8007c54 <__swsetup_r+0x24>
 8007cc8:	bd38      	pop	{r3, r4, r5, pc}
 8007cca:	0799      	lsls	r1, r3, #30
 8007ccc:	bf58      	it	pl
 8007cce:	6962      	ldrpl	r2, [r4, #20]
 8007cd0:	60a2      	str	r2, [r4, #8]
 8007cd2:	e7f4      	b.n	8007cbe <__swsetup_r+0x8e>
 8007cd4:	2000      	movs	r0, #0
 8007cd6:	e7f7      	b.n	8007cc8 <__swsetup_r+0x98>
 8007cd8:	24000040 	.word	0x24000040

08007cdc <__swhatbuf_r>:
 8007cdc:	b570      	push	{r4, r5, r6, lr}
 8007cde:	460c      	mov	r4, r1
 8007ce0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8007ce4:	2900      	cmp	r1, #0
 8007ce6:	b096      	sub	sp, #88	@ 0x58
 8007ce8:	4615      	mov	r5, r2
 8007cea:	461e      	mov	r6, r3
 8007cec:	da0d      	bge.n	8007d0a <__swhatbuf_r+0x2e>
 8007cee:	89a3      	ldrh	r3, [r4, #12]
 8007cf0:	f013 0f80 	tst.w	r3, #128	@ 0x80
 8007cf4:	f04f 0100 	mov.w	r1, #0
 8007cf8:	bf14      	ite	ne
 8007cfa:	2340      	movne	r3, #64	@ 0x40
 8007cfc:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 8007d00:	2000      	movs	r0, #0
 8007d02:	6031      	str	r1, [r6, #0]
 8007d04:	602b      	str	r3, [r5, #0]
 8007d06:	b016      	add	sp, #88	@ 0x58
 8007d08:	bd70      	pop	{r4, r5, r6, pc}
 8007d0a:	466a      	mov	r2, sp
 8007d0c:	f000 f848 	bl	8007da0 <_fstat_r>
 8007d10:	2800      	cmp	r0, #0
 8007d12:	dbec      	blt.n	8007cee <__swhatbuf_r+0x12>
 8007d14:	9901      	ldr	r1, [sp, #4]
 8007d16:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 8007d1a:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 8007d1e:	4259      	negs	r1, r3
 8007d20:	4159      	adcs	r1, r3
 8007d22:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8007d26:	e7eb      	b.n	8007d00 <__swhatbuf_r+0x24>

08007d28 <__smakebuf_r>:
 8007d28:	898b      	ldrh	r3, [r1, #12]
 8007d2a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8007d2c:	079d      	lsls	r5, r3, #30
 8007d2e:	4606      	mov	r6, r0
 8007d30:	460c      	mov	r4, r1
 8007d32:	d507      	bpl.n	8007d44 <__smakebuf_r+0x1c>
 8007d34:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 8007d38:	6023      	str	r3, [r4, #0]
 8007d3a:	6123      	str	r3, [r4, #16]
 8007d3c:	2301      	movs	r3, #1
 8007d3e:	6163      	str	r3, [r4, #20]
 8007d40:	b003      	add	sp, #12
 8007d42:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007d44:	ab01      	add	r3, sp, #4
 8007d46:	466a      	mov	r2, sp
 8007d48:	f7ff ffc8 	bl	8007cdc <__swhatbuf_r>
 8007d4c:	9f00      	ldr	r7, [sp, #0]
 8007d4e:	4605      	mov	r5, r0
 8007d50:	4639      	mov	r1, r7
 8007d52:	4630      	mov	r0, r6
 8007d54:	f7ff f8fe 	bl	8006f54 <_malloc_r>
 8007d58:	b948      	cbnz	r0, 8007d6e <__smakebuf_r+0x46>
 8007d5a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8007d5e:	059a      	lsls	r2, r3, #22
 8007d60:	d4ee      	bmi.n	8007d40 <__smakebuf_r+0x18>
 8007d62:	f023 0303 	bic.w	r3, r3, #3
 8007d66:	f043 0302 	orr.w	r3, r3, #2
 8007d6a:	81a3      	strh	r3, [r4, #12]
 8007d6c:	e7e2      	b.n	8007d34 <__smakebuf_r+0xc>
 8007d6e:	89a3      	ldrh	r3, [r4, #12]
 8007d70:	6020      	str	r0, [r4, #0]
 8007d72:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8007d76:	81a3      	strh	r3, [r4, #12]
 8007d78:	9b01      	ldr	r3, [sp, #4]
 8007d7a:	e9c4 0704 	strd	r0, r7, [r4, #16]
 8007d7e:	b15b      	cbz	r3, 8007d98 <__smakebuf_r+0x70>
 8007d80:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8007d84:	4630      	mov	r0, r6
 8007d86:	f000 f81d 	bl	8007dc4 <_isatty_r>
 8007d8a:	b128      	cbz	r0, 8007d98 <__smakebuf_r+0x70>
 8007d8c:	89a3      	ldrh	r3, [r4, #12]
 8007d8e:	f023 0303 	bic.w	r3, r3, #3
 8007d92:	f043 0301 	orr.w	r3, r3, #1
 8007d96:	81a3      	strh	r3, [r4, #12]
 8007d98:	89a3      	ldrh	r3, [r4, #12]
 8007d9a:	431d      	orrs	r5, r3
 8007d9c:	81a5      	strh	r5, [r4, #12]
 8007d9e:	e7cf      	b.n	8007d40 <__smakebuf_r+0x18>

08007da0 <_fstat_r>:
 8007da0:	b538      	push	{r3, r4, r5, lr}
 8007da2:	4d07      	ldr	r5, [pc, #28]	@ (8007dc0 <_fstat_r+0x20>)
 8007da4:	2300      	movs	r3, #0
 8007da6:	4604      	mov	r4, r0
 8007da8:	4608      	mov	r0, r1
 8007daa:	4611      	mov	r1, r2
 8007dac:	602b      	str	r3, [r5, #0]
 8007dae:	f7f9 febd 	bl	8001b2c <_fstat>
 8007db2:	1c43      	adds	r3, r0, #1
 8007db4:	d102      	bne.n	8007dbc <_fstat_r+0x1c>
 8007db6:	682b      	ldr	r3, [r5, #0]
 8007db8:	b103      	cbz	r3, 8007dbc <_fstat_r+0x1c>
 8007dba:	6023      	str	r3, [r4, #0]
 8007dbc:	bd38      	pop	{r3, r4, r5, pc}
 8007dbe:	bf00      	nop
 8007dc0:	240011b0 	.word	0x240011b0

08007dc4 <_isatty_r>:
 8007dc4:	b538      	push	{r3, r4, r5, lr}
 8007dc6:	4d06      	ldr	r5, [pc, #24]	@ (8007de0 <_isatty_r+0x1c>)
 8007dc8:	2300      	movs	r3, #0
 8007dca:	4604      	mov	r4, r0
 8007dcc:	4608      	mov	r0, r1
 8007dce:	602b      	str	r3, [r5, #0]
 8007dd0:	f7f9 feb2 	bl	8001b38 <_isatty>
 8007dd4:	1c43      	adds	r3, r0, #1
 8007dd6:	d102      	bne.n	8007dde <_isatty_r+0x1a>
 8007dd8:	682b      	ldr	r3, [r5, #0]
 8007dda:	b103      	cbz	r3, 8007dde <_isatty_r+0x1a>
 8007ddc:	6023      	str	r3, [r4, #0]
 8007dde:	bd38      	pop	{r3, r4, r5, pc}
 8007de0:	240011b0 	.word	0x240011b0

08007de4 <_init>:
 8007de4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007de6:	bf00      	nop
 8007de8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8007dea:	bc08      	pop	{r3}
 8007dec:	469e      	mov	lr, r3
 8007dee:	4770      	bx	lr

08007df0 <_fini>:
 8007df0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007df2:	bf00      	nop
 8007df4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8007df6:	bc08      	pop	{r3}
 8007df8:	469e      	mov	lr, r3
 8007dfa:	4770      	bx	lr
